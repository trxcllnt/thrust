---
title: thrust
nav_exclude: true
has_children: true
has_toc: false
---

# Namespace `thrust`

<code class="doxybook">
<span>namespace thrust {</span>
<br>
<span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1async.html">thrust::async</a></b> { <i>…</i> }</span>
<br>
<span class="doxybook-comment">/* <code>thrust::cpp</code> is a top-level alias for thrust::system::cpp.  */</span><span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1cpp.html">thrust::cpp</a></b> { <i>…</i> }</span>
<br>
<span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1cub.html">thrust::cub</a></b> { <i>…</i> }</span>
<br>
<span class="doxybook-comment">/* <code>thrust::cuda</code> is a top-level alias for <code>thrust::system::cuda</code>.  */</span><span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1cuda.html">thrust::cuda</a></b> { <i>…</i> }</span>
<br>
<span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1cuda__cub.html">thrust::cuda&#95;cub</a></b> { <i>…</i> }</span>
<br>
<span class="doxybook-comment">/* \exclude  */</span><span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1detail.html">thrust::detail</a></b> { <i>…</i> }</span>
<br>
<span class="doxybook-comment">/* <code>thrust::mr</code> is the namespace containing system agnostic types and functions for <code>memory&#95;resource</code> related functionalities.  */</span><span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1mr.html">thrust::mr</a></b> { <i>…</i> }</span>
<br>
<span class="doxybook-comment">/* <code>thrust::omp</code> is a top-level alias for thrust::system::omp.  */</span><span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1omp.html">thrust::omp</a></b> { <i>…</i> }</span>
<br>
<span class="doxybook-comment">/* Facilities for constructing simple functions inline.  */</span><span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1placeholders.html">thrust::placeholders</a></b> { <i>…</i> }</span>
<br>
<span class="doxybook-comment">/* <code>thrust::random</code> is the namespace which contains random number engine class templates, random number engine adaptor class templates, engines with predefined parameters, and random number distribution class templates. They are provided in a separate namespace for import convenience but are also aliased in the top-level <code>thrust</code> namespace for easy access.  */</span><span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1random.html">thrust::random</a></b> { <i>…</i> }</span>
<br>
<span class="doxybook-comment">/* <code>thrust::system</code> is the namespace which contains specific Thrust backend systems. It also contains functionality for reporting error conditions originating from the operating system or other low-level application program interfaces such as the CUDA runtime. They are provided in a separate namespace for import convenience but are also aliased in the top-level <code>thrust</code> namespace for easy access.  */</span><span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1system.html">thrust::system</a></b> { <i>…</i> }</span>
<br>
<span class="doxybook-comment">/* <code>thrust::tbb</code> is a top-level alias for thrust::system::tbb.  */</span><span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1tbb.html">thrust::tbb</a></b> { <i>…</i> }</span>
<br>
<span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1unimplemented.html">thrust::unimplemented</a></b> { <i>…</i> }</span>
<br>
<span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1unique__eager__event__type__detail.html">thrust::unique&#95;eager&#95;event&#95;type&#95;detail</a></b> { <i>…</i> }</span>
<br>
<span>namespace <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust_1_1unique__eager__future__type__detail.html">thrust::unique&#95;eager&#95;future&#95;type&#95;detail</a></b> { <i>…</i> }</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator,</span>
<span>&nbsp;&nbsp;bool Uninitialized = false&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1allocator__delete.html">allocator&#95;delete</a></b>;</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator,</span>
<span>&nbsp;&nbsp;bool Uninitialized = false&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1array__allocator__delete.html">array&#95;allocator&#95;delete</a></b>;</span>
<br>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1bad__optional__access.html">bad&#95;optional&#95;access</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1bidirectional__device__iterator__tag.html">bidirectional&#95;device&#95;iterator&#95;tag</a></b>;</span>
<br>
<span>template &lt;typename Argument1,</span>
<span>&nbsp;&nbsp;typename Argument2,</span>
<span>&nbsp;&nbsp;typename Result&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1binary__function.html">binary&#95;function</a></b>;</span>
<br>
<span>template &lt;typename Predicate&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1binary__negate.html">binary&#95;negate</a></b>;</span>
<br>
<span>template &lt;typename Operation&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1binary__traits.html">binary&#95;traits</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__and.html">bit&#95;and</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__and_3_01void_01_4.html">bit&#95;and&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__or.html">bit&#95;or</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__or_3_01void_01_4.html">bit&#95;or&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__xor.html">bit&#95;xor</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__xor_3_01void_01_4.html">bit&#95;xor&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a></b>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>(... && Bs)</code>.  */</span><span>template &lt;bool... Bs&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1conjunction__value.html">conjunction&#95;value</a></b>;</span>
<br>
<span>template &lt;typename Value,</span>
<span>&nbsp;&nbsp;typename Incrementable = use&#95;default,</span>
<span>&nbsp;&nbsp;typename System = use&#95;default&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a></b>;</span>
<br>
<span>template &lt;typename Incrementable,</span>
<span>&nbsp;&nbsp;typename System = use&#95;default,</span>
<span>&nbsp;&nbsp;typename Traversal = use&#95;default,</span>
<span>&nbsp;&nbsp;typename Difference = use&#95;default&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1counting__iterator.html">counting&#95;iterator</a></b>;</span>
<br>
<span class="doxybook-comment">/* An allocator which creates new elements in memory accessible by devices.  */</span><span>template &lt;typename T&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__allocator.html">device&#95;allocator</a></b>;</span>
<br>
<span>template &lt;typename DerivedPolicy&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1device__execution__policy.html">device&#95;execution&#95;policy</a></b>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__malloc__allocator.html">device&#95;malloc&#95;allocator</a></b>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__new__allocator.html">device&#95;new&#95;allocator</a></b>;</span>
<br>
<span class="doxybook-comment">/* <code>device&#95;ptr</code> is a pointer-like object which points to an object that resides in memory associated with the device system.  */</span><span>template &lt;typename T&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></b>;</span>
<br>
<span>template &lt;typename Upstream&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr__memory__resource.html">device&#95;ptr&#95;memory&#95;resource</a></b>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device&#95;reference</a></b>;</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Alloc = thrust::device&#95;allocator&lt;T&gt;&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></b>;</span>
<br>
<span>template &lt;typename System = use&#95;default&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1discard__iterator.html">discard&#95;iterator</a></b>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>(... || Bs)</code>.  */</span><span>template &lt;bool... Bs&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1disjunction__value.html">disjunction&#95;value</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1divides.html">divides</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1divides_3_01void_01_4.html">divides&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html">equal&#95;to</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to_3_01void_01_4.html">equal&#95;to&lt; void &gt;</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1forward__device__iterator__tag.html">forward&#95;device&#95;iterator&#95;tag</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1greater.html">greater</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1greater_3_01void_01_4.html">greater&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1greater__equal.html">greater&#95;equal</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1greater__equal_3_01void_01_4.html">greater&#95;equal&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename DerivedPolicy&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1host__execution__policy.html">host&#95;execution&#95;policy</a></b>;</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Alloc = std::allocator&lt;T&gt;&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host&#95;vector</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1identity.html">identity</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1identity_3_01void_01_4.html">identity&lt; void &gt;</a></b>;</span>
<br>
<span class="doxybook-comment">/* A tag type to tell optional to construct its value in-place.  */</span><span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1in__place__t.html">in&#95;place&#95;t</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1input__device__iterator__tag.html">input&#95;device&#95;iterator&#95;tag</a></b>;</span>
<br>
<span>template &lt;typename Derived,</span>
<span>&nbsp;&nbsp;typename Base,</span>
<span>&nbsp;&nbsp;typename Value = use&#95;default,</span>
<span>&nbsp;&nbsp;typename System = use&#95;default,</span>
<span>&nbsp;&nbsp;typename Traversal = use&#95;default,</span>
<span>&nbsp;&nbsp;typename Reference = use&#95;default,</span>
<span>&nbsp;&nbsp;typename Difference = use&#95;default&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1iterator__adaptor.html">iterator&#95;adaptor</a></b>;</span>
<br>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1iterator__core__access.html">iterator&#95;core&#95;access</a></b>;</span>
<br>
<span>template &lt;typename Iterator&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__difference.html">iterator&#95;difference</a></b>;</span>
<br>
<span>template &lt;typename Derived,</span>
<span>&nbsp;&nbsp;typename Value,</span>
<span>&nbsp;&nbsp;typename System,</span>
<span>&nbsp;&nbsp;typename Traversal,</span>
<span>&nbsp;&nbsp;typename Reference,</span>
<span>&nbsp;&nbsp;typename Difference = std::ptrdiff&#95;t&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1iterator__facade.html">iterator&#95;facade</a></b>;</span>
<br>
<span>template &lt;typename Iterator&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__pointer.html">iterator&#95;pointer</a></b>;</span>
<br>
<span>template &lt;typename Iterator&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__reference.html">iterator&#95;reference</a></b>;</span>
<br>
<span>template &lt;typename Iterator&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__system.html">iterator&#95;system</a></b>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">iterator&#95;traits</a></b>;</span>
<br>
<span>template &lt;typename Iterator&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traversal.html">iterator&#95;traversal</a></b>;</span>
<br>
<span>template &lt;typename Iterator&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__value.html">iterator&#95;value</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1less.html">less</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1less_3_01void_01_4.html">less&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1less__equal.html">less&#95;equal</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1less__equal_3_01void_01_4.html">less&#95;equal&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__and.html">logical&#95;and</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__and_3_01void_01_4.html">logical&#95;and&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__not.html">logical&#95;not</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__not_3_01void_01_4.html">logical&#95;not&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__or.html">logical&#95;or</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__or_3_01void_01_4.html">logical&#95;or&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1maximum.html">maximum</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1maximum_3_01void_01_4.html">maximum&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1minimum.html">minimum</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1minimum_3_01void_01_4.html">minimum&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1minus.html">minus</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1minus_3_01void_01_4.html">minus&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1modulus.html">modulus</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1modulus_3_01void_01_4.html">modulus&lt; void &gt;</a></b>;</span>
<br>
<span class="doxybook-comment">/* Used to represent an optional with no data; essentially a bool.  */</span><span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1monostate.html">monostate</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1multiplies.html">multiplies</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1multiplies_3_01void_01_4.html">multiplies&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1negate.html">negate</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1negate_3_01void_01_4.html">negate&lt; void &gt;</a></b>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>!Bs</code>.  */</span><span>template &lt;bool B&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1negation__value.html">negation&#95;value</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1new__stream__t.html">new&#95;stream&#95;t</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1not__equal__to.html">not&#95;equal&#95;to</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1not__equal__to_3_01void_01_4.html">not&#95;equal&#95;to&lt; void &gt;</a></b>;</span>
<br>
<span class="doxybook-comment">/* A tag type to represent an empty optional.  */</span><span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt&#95;t</a></b>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1numeric__limits.html">numeric&#95;limits</a></b>;</span>
<br>
<span class="doxybook-comment">/* An optional object is an object that contains the storage for another object and manages the lifetime of this contained object, if any.  */</span><span>template &lt;class T&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a></b>;</span>
<br>
<span class="doxybook-comment">/* Specialization for when <code>T</code> is a reference.  */</span><span>template &lt;class T&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional_3_01t_01_6_01_4.html">optional&lt; T & &gt;</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1output__device__iterator__tag.html">output&#95;device&#95;iterator&#95;tag</a></b>;</span>
<br>
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a></b>;</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Upstream,</span>
<span>&nbsp;&nbsp;typename ExecutionPolicy&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1per__device__allocator.html">per&#95;device&#95;allocator</a></b>;</span>
<br>
<span>template &lt;typename ElementIterator,</span>
<span>&nbsp;&nbsp;typename IndexIterator&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1permutation__iterator.html">permutation&#95;iterator</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1plus.html">plus</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1plus_3_01void_01_4.html">plus&lt; void &gt;</a></b>;</span>
<br>
<span class="doxybook-comment">/* Customization point that can be customized to indicate that an iterator type <code>Iterator</code> satisfies <a href="https://en.cppreference.com/w/cpp/named_req/ContiguousIterator">ContiguousIterator</a>, aka it points to elements that are contiguous in memory.  */</span><span>template &lt;typename Iterator&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1proclaim__contiguous__iterator.html">proclaim&#95;contiguous&#95;iterator</a></b>;</span>
<br>
<span>template &lt;typename T1 = void,</span>
<span>&nbsp;&nbsp;typename T2 = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">project1st</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st_3_01void_00_01void_01_4.html">project1st&lt; void, void &gt;</a></b>;</span>
<br>
<span>template &lt;typename T1 = void,</span>
<span>&nbsp;&nbsp;typename T2 = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project2nd.html">project2nd</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project2nd_3_01void_00_01void_01_4.html">project2nd&lt; void, void &gt;</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1random__access__device__iterator__tag.html">random&#95;access&#95;device&#95;iterator&#95;tag</a></b>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that removes <a href="https://en.cppreference.com/w/cpp/language/cv">const-volatile qualifiers</a> and <a href="https://en.cppreference.com/w/cpp/language/reference">references</a> from <code>T</code>. Equivalent to <code>remove&#95;cv&#95;t&lt;remove&#95;reference&#95;t&lt;T&gt;&gt;</code>.  */</span><span>template &lt;typename T&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1remove__cvref.html">remove&#95;cvref</a></b>;</span>
<br>
<span>template &lt;typename BidirectionalIterator&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">reverse&#95;iterator</a></b>;</span>
<br>
<span>template &lt;typename T = void&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1square.html">square</a></b>;</span>
<br>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1square_3_01void_01_4.html">square&lt; void &gt;</a></b>;</span>
<br>
<span>template &lt;typename Pointer,</span>
<span>&nbsp;&nbsp;typename Lambda&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1tagged__deleter.html">tagged&#95;deleter</a></b>;</span>
<br>
<span>template &lt;typename InputFunction,</span>
<span>&nbsp;&nbsp;typename OutputFunction,</span>
<span>&nbsp;&nbsp;typename Iterator&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__input__output__iterator.html">transform&#95;input&#95;output&#95;iterator</a></b>;</span>
<br>
<span>template &lt;class AdaptableUnaryFunction,</span>
<span>&nbsp;&nbsp;class Iterator,</span>
<span>&nbsp;&nbsp;class Reference = use&#95;default,</span>
<span>&nbsp;&nbsp;class Value = use&#95;default&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__iterator.html">transform&#95;iterator</a></b>;</span>
<br>
<span>template &lt;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__output__iterator.html">transform&#95;output&#95;iterator</a></b>;</span>
<br>
<span class="doxybook-comment">/* <code>tuple</code> is a class template that can be instantiated with up to ten arguments. Each template argument specifies the type of element in the <code>tuple</code>. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of <code>tuple</code> with two arguments is similar to an instantiation of <code>pair</code> with the same two arguments. Individual elements of a <code>tuple</code> may be accessed with the <code>get</code> function.  */</span><span>template &lt;class T0,</span>
<span>&nbsp;&nbsp;class T1,</span>
<span>&nbsp;&nbsp;class T2,</span>
<span>&nbsp;&nbsp;class T3,</span>
<span>&nbsp;&nbsp;class T4,</span>
<span>&nbsp;&nbsp;class T5,</span>
<span>&nbsp;&nbsp;class T6,</span>
<span>&nbsp;&nbsp;class T7,</span>
<span>&nbsp;&nbsp;class T8,</span>
<span>&nbsp;&nbsp;class T9&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a></b>;</span>
<br>
<span>template &lt;size_t N,</span>
<span>&nbsp;&nbsp;class T&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1tuple__element.html">tuple&#95;element</a></b>;</span>
<br>
<span>template &lt;typename Pair&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1tuple__size.html">tuple&#95;size</a></b>;</span>
<br>
<span>template &lt;typename Argument,</span>
<span>&nbsp;&nbsp;typename Result&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1unary__function.html">unary&#95;function</a></b>;</span>
<br>
<span>template &lt;typename Predicate&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1unary__negate.html">unary&#95;negate</a></b>;</span>
<br>
<span>template &lt;typename Operation&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1unary__traits.html">unary&#95;traits</a></b>;</span>
<br>
<span>template &lt;typename...&gt;</span>
<span>struct <b><a href="{{ site.baseurl }}/api/classes/structthrust_1_1voider.html">voider</a></b>;</span>
<br>
<span>template &lt;typename Function&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__function.html">zip&#95;function</a></b>;</span>
<br>
<span>template &lt;typename IteratorTuple&gt;</span>
<span>class <b><a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip&#95;iterator</a></b>;</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-uninitialized-allocator-delete">uninitialized&#95;allocator&#95;delete</a></b> = <i>see below</i>;</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-uninitialized-array-allocator-delete">uninitialized&#95;array&#95;allocator&#95;delete</a></b> = <i>see below</i>;</span>
<br>
<span>template &lt;typename System&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-unique-eager-event">unique&#95;eager&#95;event</a></b> = <i>see below</i>;</span>
<br>
<span>template &lt;typename System&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-event">event</a></b> = <i>see below</i>;</span>
<br>
<span>template &lt;typename System,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-unique-eager-future">unique&#95;eager&#95;future</a></b> = <i>see below</i>;</span>
<br>
<span>template &lt;typename System,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-future">future</a></b> = <i>see below</i>;</span>
<br>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-device-unique-eager-event">device&#95;unique&#95;eager&#95;event</a></b> = <i>see below</i>;</span>
<br>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-device-event">device&#95;event</a></b> = <i>see below</i>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-device-unique-eager-future">device&#95;unique&#95;eager&#95;future</a></b> = <i>see below</i>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#using-device-future">device&#95;future</a></b> = <i>see below</i>;</span>
<br>
<span>typedef <i>see below</i> <b><a href="{{ site.baseurl }}/api/groups/group__iterator__tag__classes.html#typedef-input-host-iterator-tag">input&#95;host&#95;iterator&#95;tag</a></b>;</span>
<br>
<span>typedef <i>see below</i> <b><a href="{{ site.baseurl }}/api/groups/group__iterator__tag__classes.html#typedef-output-host-iterator-tag">output&#95;host&#95;iterator&#95;tag</a></b>;</span>
<br>
<span>typedef <i>see below</i> <b><a href="{{ site.baseurl }}/api/groups/group__iterator__tag__classes.html#typedef-forward-host-iterator-tag">forward&#95;host&#95;iterator&#95;tag</a></b>;</span>
<br>
<span>typedef <i>see below</i> <b><a href="{{ site.baseurl }}/api/groups/group__iterator__tag__classes.html#typedef-bidirectional-host-iterator-tag">bidirectional&#95;host&#95;iterator&#95;tag</a></b>;</span>
<br>
<span>typedef <i>see below</i> <b><a href="{{ site.baseurl }}/api/groups/group__iterator__tag__classes.html#typedef-random-access-host-iterator-tag">random&#95;access&#95;host&#95;iterator&#95;tag</a></b>;</span>
<br>
<span>typedef <i>see below</i> <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#typedef-device-memory-resource">device&#95;memory&#95;resource</a></b>;</span>
<br>
<span>typedef <i>see below</i> <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#typedef-universal-memory-resource">universal&#95;memory&#95;resource</a></b>;</span>
<br>
<span>typedef <i>see below</i> <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#typedef-universal-host-pinned-memory-resource">universal&#95;host&#95;pinned&#95;memory&#95;resource</a></b>;</span>
<br>
<span>typedef <i>see below</i> <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#typedef-host-memory-resource">host&#95;memory&#95;resource</a></b>;</span>
<br>
<span class="doxybook-comment">/* A compile-time sequence of <a href="https://en.cppreference.com/w/cpp/language/constant_expression#Integral_constant_expression">_integral constants_</a> of type <code>T</code> with values <code>Is...</code>.  */</span><span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;T... Is&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-integer-sequence">integer&#95;sequence</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* A compile-time sequence of type <a href="https://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> with values <code>Is...</code>.  */</span><span>template &lt;std::size_t... Is&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-index-sequence">index&#95;sequence</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* Create a new <code>integer&#95;sequence</code> with elements <code>0, 1, 2, ..., N - 1</code> of type <code>T</code>.  */</span><span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;std::size_t N&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-make-integer-sequence">make&#95;integer&#95;sequence</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* Create a new <code>integer&#95;sequence</code> with elements <code>0, 1, 2, ..., N - 1</code> of type <a href="https://en.cppreference.com/w/cpp/types/size_t">std::size_t</a>.  */</span><span>template &lt;std::size_t N&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-make-index-sequence">make&#95;index&#95;sequence</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* Create a new <code>integer&#95;sequence</code> with elements <code>N - 1, N - 2, N - 3, ..., 0</code>.  */</span><span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;std::size_t N&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-make-reversed-integer-sequence">make&#95;reversed&#95;integer&#95;sequence</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* Create a new <code>index&#95;sequence</code> with elements <code>N - 1, N - 2, N - 3, ..., 0</code>.  */</span><span>template &lt;std::size_t N&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-make-reversed-index-sequence">make&#95;reversed&#95;index&#95;sequence</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* Add a new element to the front of an <code>integer&#95;sequence</code>.  */</span><span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;T Value,</span>
<span>&nbsp;&nbsp;typename Sequence&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-integer-sequence-push-front">integer&#95;sequence&#95;push&#95;front</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* Add a new element to the back of an <code>integer&#95;sequence</code>.  */</span><span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;T Value,</span>
<span>&nbsp;&nbsp;typename Sequence&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-integer-sequence-push-back">integer&#95;sequence&#95;push&#95;back</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>Iterator</code> satisfies <a href="https://en.cppreference.com/w/cpp/named_req/ContiguousIterator">ContiguousIterator</a>, aka it points to elements that are contiguous in memory, and <code>false&#95;type</code> otherwise.  */</span><span>template &lt;typename Iterator&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-is-contiguous-iterator">is&#95;contiguous&#95;iterator</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is an _ExecutionPolicy_ and <code>false&#95;type</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-is-execution-policy">is&#95;execution&#95;policy</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&lt;</code>, and <code>false&#95;type</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-is-operator-less-function-object">is&#95;operator&#95;less&#95;function&#95;object</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&gt;</code>, and <code>false&#95;type</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-is-operator-greater-function-object">is&#95;operator&#95;greater&#95;function&#95;object</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&lt;</code> or <code>operator&gt;</code>, and <code>false&#95;type</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-is-operator-less-or-greater-function-object">is&#95;operator&#95;less&#95;or&#95;greater&#95;function&#95;object</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/FunctionObject">FunctionObject</a> equivalent to <code>operator+</code>, and <code>false&#95;type</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-is-operator-plus-function-object">is&#95;operator&#95;plus&#95;function&#95;object</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>(... && Ts::value)</code>.  */</span><span>template &lt;typename... Ts&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-conjunction">conjunction</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>(... || Ts::value)</code>.  */</span><span>template &lt;typename... Ts&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-disjunction">disjunction</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>!Ts::value</code>.  */</span><span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-negation">negation</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* Type alias that removes <a href="https://en.cppreference.com/w/cpp/language/cv">const-volatile qualifiers</a> and <a href="https://en.cppreference.com/w/cpp/language/reference">references</a> from <code>T</code>. Equivalent to <code>remove&#95;cv&#95;t&lt;remove&#95;reference&#95;t&lt;T&gt;&gt;</code>.  */</span><span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#using-remove-cvref-t">remove&#95;cvref&#95;t</a></b> = <i>see below</i>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>using <b><a href="{{ site.baseurl }}/api/groups/group__memory__resources.html#using-universal-ptr">universal&#95;ptr</a></b> = <i>see below</i>;</span>
<br>
<span>static const detail::host_t <b><a href="{{ site.baseurl }}/api/groups/group__execution__policies.html#variable-host">host</a></b>;</span>
<br>
<span>THRUST_INLINE_CONSTANT detail::device_t <b><a href="{{ site.baseurl }}/api/groups/group__execution__policies.html#variable-device">device</a></b>;</span>
<br>
<span>THRUST_INLINE_CONSTANT new_stream_t <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#variable-new-stream">new&#95;stream</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* A tag to tell optional to construct its value in-place.  */</span><span>static constexpr <a href="{{ site.baseurl }}/api/classes/structthrust_1_1in__place__t.html">in_place_t</a> <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#variable-in-place">in&#95;place</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* Represents an empty optional \synopsis static constexpr nullopt_t nullopt;.  */</span><span>static constexpr <a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a> <b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#variable-nullopt">nullopt</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> that is <code>true</code> if <code>Iterator</code> satisfies <a href="https://en.cppreference.com/w/cpp/named_req/ContiguousIterator">ContiguousIterator</a>, aka it points to elements that are contiguous in memory, and <code>false</code> otherwise.  */</span><span>template &lt;typename Iterator&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-is-contiguous-iterator-v">is&#95;contiguous&#95;iterator&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> that is <code>true</code> if <code>T</code> is an _ExecutionPolicy_ and <code>false</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-is-execution-policy-v">is&#95;execution&#95;policy&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> that is <code>true</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&lt;</code>, and <code>false</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-is-operator-less-function-object-v">is&#95;operator&#95;less&#95;function&#95;object&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> that is <code>true</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&gt;</code>, and <code>false</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-is-operator-greater-function-object-v">is&#95;operator&#95;greater&#95;function&#95;object&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> that is <code>true</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&lt;</code> or <code>operator&gt;</code>, and <code>false</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-is-operator-less-or-greater-function-object-v">is&#95;operator&#95;less&#95;or&#95;greater&#95;function&#95;object&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> that is <code>true</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/FunctionObject">FunctionObject</a> equivalent to <code>operator&lt;</code>, and <code>false</code> otherwise.  */</span><span>template &lt;typename T&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-is-operator-plus-function-object-v">is&#95;operator&#95;plus&#95;function&#95;object&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> whose value is <code>(... && Ts::value)</code>.  */</span><span>template &lt;typename... Ts&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-conjunction-v">conjunction&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> whose value is <code>(... || Ts::value)</code>.  */</span><span>template &lt;typename... Ts&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-disjunction-v">disjunction&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> whose value is <code>!Ts::value</code>.  */</span><span>template &lt;typename T&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-negation-v">negation&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> whose value is <code>(... && Bs)</code>.  */</span><span>template &lt;bool... Bs&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-conjunction-value-v">conjunction&#95;value&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> whose value is <code>(... || Bs)</code>.  */</span><span>template &lt;bool... Bs&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-disjunction-value-v">disjunction&#95;value&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span class="doxybook-comment">/* <code>constexpr bool</code> whose value is <code>!Ts::value</code>.  */</span><span>template &lt;bool B&gt;</span>
<span>constexpr bool <b><a href="{{ site.baseurl }}/api/groups/group__type__traits.html#variable-negation-value-v">negation&#95;value&#95;v</a></b> = <i>see below</i>;</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T * </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-addressof">addressof</a></b>(T & arg);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-adjacent-difference">adjacent&#95;difference</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-adjacent-difference">adjacent&#95;difference</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-adjacent-difference">adjacent&#95;difference</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-adjacent-difference">adjacent&#95;difference</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Distance&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__iterators.html#function-advance">advance</a></b>(InputIterator & i,</span>
<span>&nbsp;&nbsp;Distance n);</span>
<br>
<span>template &lt;typename Pointer,</span>
<span>&nbsp;&nbsp;typename Lambda&gt;</span>
<span>__host__ __device__ tagged_deleter< Pointer, Lambda > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-make-tagged-deleter">make&#95;tagged&#95;deleter</a></b>(Lambda && l);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator,</span>
<span>&nbsp;&nbsp;typename... Args&gt;</span>
<span>__host__ std::unique_ptr< T, allocator_delete< T, typename detail::allocator_traits< typename std::remove_cv< typename std::remove_reference< Allocator >::type >::type >::template rebind_traits< T >::allocator_type > > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-allocate-unique">allocate&#95;unique</a></b>(Allocator const & alloc,</span>
<span>&nbsp;&nbsp;Args &&... args);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator&gt;</span>
<span>__host__ std::unique_ptr< T, uninitialized_allocator_delete< T, typename detail::allocator_traits< typename std::remove_cv< typename std::remove_reference< Allocator >::type >::type >::template rebind_traits< T >::allocator_type > > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-uninitialized-allocate-unique">uninitialized&#95;allocate&#95;unique</a></b>(Allocator const & alloc);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename... Args&gt;</span>
<span>__host__ std::unique_ptr< T[], array_allocator_delete< T, typename detail::allocator_traits< typename std::remove_cv< typename std::remove_reference< Allocator >::type >::type >::template rebind_traits< T >::allocator_type > > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-allocate-unique-n">allocate&#95;unique&#95;n</a></b>(Allocator const & alloc,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;Args &&... args);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator,</span>
<span>&nbsp;&nbsp;typename Size&gt;</span>
<span>__host__ std::unique_ptr< T[], uninitialized_array_allocator_delete< T, typename detail::allocator_traits< typename std::remove_cv< typename std::remove_reference< Allocator >::type >::type >::template rebind_traits< T >::allocator_type > > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-uninitialized-allocate-unique-n">uninitialized&#95;allocate&#95;unique&#95;n</a></b>(Allocator const & alloc,</span>
<span>&nbsp;&nbsp;Size n);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename LessThanComparable&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-lower-bound">lower&#95;bound</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class LessThanComparable&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-lower-bound">lower&#95;bound</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-lower-bound">lower&#95;bound</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class T,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-lower-bound">lower&#95;bound</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename LessThanComparable&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-upper-bound">upper&#95;bound</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class LessThanComparable&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-upper-bound">upper&#95;bound</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-upper-bound">upper&#95;bound</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class T,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-upper-bound">upper&#95;bound</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename LessThanComparable&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-binary-search">binary&#95;search</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class LessThanComparable&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-binary-search">binary&#95;search</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-binary-search">binary&#95;search</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class T,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-binary-search">binary&#95;search</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename LessThanComparable&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-equal-range">equal&#95;range</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class LessThanComparable&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-equal-range">equal&#95;range</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-equal-range">equal&#95;range</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class T,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__binary__search.html#function-equal-range">equal&#95;range</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-lower-bound">lower&#95;bound</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-lower-bound">lower&#95;bound</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-lower-bound">lower&#95;bound</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-lower-bound">lower&#95;bound</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-upper-bound">upper&#95;bound</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-upper-bound">upper&#95;bound</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-upper-bound">upper&#95;bound</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-upper-bound">upper&#95;bound</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-binary-search">binary&#95;search</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-binary-search">binary&#95;search</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-binary-search">binary&#95;search</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__vectorized__binary__search.html#function-binary-search">binary&#95;search</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-abs">abs</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-arg">arg</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-norm">norm</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-conj">conj</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-polar">polar</a></b>(const T0 & m,</span>
<span>&nbsp;&nbsp;const T1 & theta = T1());</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-proj">proj</a></b>(const T & z);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator+">operator+</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator+">operator+</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator+">operator+</a></b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator-">operator-</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator-">operator-</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator-">operator-</a></b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator*">operator&#42;</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator*">operator&#42;</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator*">operator&#42;</a></b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator/">operator/</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator/">operator/</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator/">operator/</a></b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator+">operator+</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & y);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator-">operator-</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & y);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-exp">exp</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-log">log</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-log10">log10</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-pow">pow</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-pow">pow</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-pow">pow</a></b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-sqrt">sqrt</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-cos">cos</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-sin">sin</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-tan">tan</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-cosh">cosh</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-sinh">sinh</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-tanh">tanh</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-acos">acos</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-asin">asin</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-atan">atan</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-acosh">acosh</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-asinh">asinh</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-atanh">atanh</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename CharT,</span>
<span>&nbsp;&nbsp;typename Traits&gt;</span>
<span>std::basic_ostream< CharT, Traits > & </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator<<">operator&lt;&lt;</a></b>(std::basic_ostream< CharT, Traits > & os,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename CharT,</span>
<span>&nbsp;&nbsp;typename Traits&gt;</span>
<span>__host__ std::basic_istream< CharT, Traits > & </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator>>">operator&gt;&gt;</a></b>(std::basic_istream< CharT, Traits > & is,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator==">operator==</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator==">operator==</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const std::complex< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator==">operator==</a></b>(const std::complex< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator==">operator==</a></b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator==">operator==</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator!=">operator!=</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator!=">operator!=</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const std::complex< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator!=">operator!=</a></b>(const std::complex< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator!=">operator!=</a></b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__complex__numbers.html#function-operator!=">operator!=</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-copy">copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-copy-n">copy&#95;n</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-copy">copy</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-copy-n">copy&#95;n</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-copy-if">copy&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-copy-if">copy&#95;if</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-copy-if">copy&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-copy-if">copy&#95;if</a></b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename EqualityComparable&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__counting.html#function-count">count</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;const EqualityComparable & value);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename EqualityComparable&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__counting.html#function-count">count</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;const EqualityComparable & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__counting.html#function-count-if">count&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__counting.html#function-count-if">count&#95;if</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-device-delete">device&#95;delete</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">thrust::device_ptr</a>< T > ptr,</span>
<span>&nbsp;&nbsp;const size_t n = 1);</span>
<br>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-device-free">device&#95;free</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">thrust::device_ptr</a>< void > ptr);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename... Args&gt;</span>
<span>__host__ auto </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-device-make-unique">device&#95;make&#95;unique</a></b>(Args &&... args);</span>
<br>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">thrust::device_ptr</a>< void > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-device-malloc">device&#95;malloc</a></b>(const std::size_t n);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">thrust::device_ptr</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-device-malloc">device&#95;malloc</a></b>(const std::size_t n);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-device-malloc">device&#95;malloc</a></b>(const std::size_t n);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-device-new">device&#95;new</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< void > p,</span>
<span>&nbsp;&nbsp;const size_t n = 1);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-device-new">device&#95;new</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< void > p,</span>
<span>&nbsp;&nbsp;const T & exemplar,</span>
<span>&nbsp;&nbsp;const size_t n = 1);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-device-new">device&#95;new</a></b>(const size_t n = 1);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename CharT,</span>
<span>&nbsp;&nbsp;typename Traits&gt;</span>
<span>__host__ std::basic_ostream< CharT, Traits > & </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-operator<<">operator&lt;&lt;</a></b>(std::basic_ostream< CharT, Traits > & os,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > const & dp);</span>
<br>
<span class="doxybook-comment">/* Create a <code>device&#95;ptr</code> from a raw pointer.  */</span><span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-device-pointer-cast">device&#95;pointer&#95;cast</a></b>(T * ptr);</span>
<br>
<span class="doxybook-comment">/* Create a <code>device&#95;ptr</code> from another <code>device&#95;ptr</code>.  */</span><span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-device-pointer-cast">device&#95;pointer&#95;cast</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > const & dptr);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-swap">swap</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device_reference</a>< T > & x,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device_reference</a>< T > & y);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename charT,</span>
<span>&nbsp;&nbsp;typename traits&gt;</span>
<span>std::basic_ostream< charT, traits > & </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-operator<<">operator&lt;&lt;</a></b>(std::basic_ostream< charT, traits > & os,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device_reference</a>< T > & y);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Alloc&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__containers.html#function-swap">swap</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device_vector</a>< T, Alloc > & a,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device_vector</a>< T, Alloc > & b);</span>
<br>
<span>template &lt;typename InputIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__iterators.html#function-distance">distance</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__comparisons.html#function-equal">equal</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__comparisons.html#function-equal">equal</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__comparisons.html#function-equal">equal</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__comparisons.html#function-equal">equal</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ T min </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-thrust-prevent-macro-substitution">THRUST&#95;PREVENT&#95;MACRO&#95;SUBSTITUTION</a></b>(const T & lhs,</span>
<span>&nbsp;&nbsp;const T & rhs,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T min </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-thrust-prevent-macro-substitution">THRUST&#95;PREVENT&#95;MACRO&#95;SUBSTITUTION</a></b>(const T & lhs,</span>
<span>&nbsp;&nbsp;const T & rhs);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ T max </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-thrust-prevent-macro-substitution">THRUST&#95;PREVENT&#95;MACRO&#95;SUBSTITUTION</a></b>(const T & lhs,</span>
<span>&nbsp;&nbsp;const T & rhs,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T max </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-thrust-prevent-macro-substitution">THRUST&#95;PREVENT&#95;MACRO&#95;SUBSTITUTION</a></b>(const T & lhs,</span>
<span>&nbsp;&nbsp;const T & rhs);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-min-element">min&#95;element</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-min-element">min&#95;element</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-min-element">min&#95;element</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-min-element">min&#95;element</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-max-element">max&#95;element</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-max-element">max&#95;element</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-max-element">max&#95;element</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-max-element">max&#95;element</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-minmax-element">minmax&#95;element</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename ForwardIterator&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-minmax-element">minmax&#95;element</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-minmax-element">minmax&#95;element</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__extrema.html#function-minmax-element">minmax&#95;element</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__filling.html#function-fill">fill</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__filling.html#function-fill">fill</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__filling.html#function-fill-n">fill&#95;n</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;OutputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__filling.html#function-fill-n">fill&#95;n</a></b>(OutputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-find">find</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-find">find</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-find-if">find&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-find-if">find&#95;if</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-find-if-not">find&#95;if&#95;not</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-find-if-not">find&#95;if&#95;not</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__modifying.html#function-for-each">for&#95;each</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;UnaryFunction f);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__modifying.html#function-for-each-n">for&#95;each&#95;n</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;UnaryFunction f);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__modifying.html#function-for-each">for&#95;each</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;UnaryFunction f);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>InputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__modifying.html#function-for-each-n">for&#95;each&#95;n</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;UnaryFunction f);</span>
<br>
<span>template &lt;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1unary__negate.html">unary_negate</a>< Predicate > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__function__object__adaptors.html#function-not1">not1</a></b>(const Predicate & pred);</span>
<br>
<span>template &lt;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1binary__negate.html">binary_negate</a>< BinaryPredicate > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__function__object__adaptors.html#function-not2">not2</a></b>(const BinaryPredicate & pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__gathering.html#function-gather">gather</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator map_first,</span>
<span>&nbsp;&nbsp;InputIterator map_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__gathering.html#function-gather">gather</a></b>(InputIterator map_first,</span>
<span>&nbsp;&nbsp;InputIterator map_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__gathering.html#function-gather-if">gather&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 map_first,</span>
<span>&nbsp;&nbsp;InputIterator1 map_last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__gathering.html#function-gather-if">gather&#95;if</a></b>(InputIterator1 map_first,</span>
<span>&nbsp;&nbsp;InputIterator1 map_last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__gathering.html#function-gather-if">gather&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 map_first,</span>
<span>&nbsp;&nbsp;InputIterator1 map_last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__gathering.html#function-gather-if">gather&#95;if</a></b>(InputIterator1 map_first,</span>
<span>&nbsp;&nbsp;InputIterator1 map_last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Generator&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-generate">generate</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Generator gen);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Generator&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-generate">generate</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Generator gen);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename Generator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-generate-n">generate&#95;n</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;OutputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;Generator gen);</span>
<br>
<span>template &lt;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename Generator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-generate-n">generate&#95;n</a></b>(OutputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;Generator gen);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Alloc&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__host__containers.html#function-swap">swap</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host_vector</a>< T, Alloc > & a,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host_vector</a>< T, Alloc > & b);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputType&gt;</span>
<span>__host__ __device__ OutputType </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__reductions.html#function-inner-product">inner&#95;product</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputType init);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputType&gt;</span>
<span>OutputType </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__reductions.html#function-inner-product">inner&#95;product</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputType init);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputType,</span>
<span>&nbsp;&nbsp;typename BinaryFunction1,</span>
<span>&nbsp;&nbsp;typename BinaryFunction2&gt;</span>
<span>__host__ __device__ OutputType </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__reductions.html#function-inner-product">inner&#95;product</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputType init,</span>
<span>&nbsp;&nbsp;BinaryFunction1 binary_op1,</span>
<span>&nbsp;&nbsp;BinaryFunction2 binary_op2);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputType,</span>
<span>&nbsp;&nbsp;typename BinaryFunction1,</span>
<span>&nbsp;&nbsp;typename BinaryFunction2&gt;</span>
<span>OutputType </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__reductions.html#function-inner-product">inner&#95;product</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputType init,</span>
<span>&nbsp;&nbsp;BinaryFunction1 binary_op1,</span>
<span>&nbsp;&nbsp;BinaryFunction2 binary_op2);</span>
<br>
<span>template &lt;typename ValueT,</span>
<span>&nbsp;&nbsp;typename IndexT&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant_iterator</a>< ValueT, IndexT > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-constant-iterator">make&#95;constant&#95;iterator</a></b>(ValueT x,</span>
<span>&nbsp;&nbsp;IndexT i = int());</span>
<br>
<span>template &lt;typename V&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant_iterator</a>< V > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-constant-iterator">make&#95;constant&#95;iterator</a></b>(V x);</span>
<br>
<span>template &lt;typename Incrementable&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1counting__iterator.html">counting_iterator</a>< Incrementable > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-counting-iterator">make&#95;counting&#95;iterator</a></b>(Incrementable x);</span>
<br>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1discard__iterator.html">discard_iterator</a> </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-discard-iterator">make&#95;discard&#95;iterator</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1discard__iterator.html">discard_iterator</a><>::difference_type i = discard&#95;iterator&lt;&gt;::difference&#95;type(0));</span>
<br>
<span>template &lt;typename ElementIterator,</span>
<span>&nbsp;&nbsp;typename IndexIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1permutation__iterator.html">permutation_iterator</a>< ElementIterator, IndexIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-permutation-iterator">make&#95;permutation&#95;iterator</a></b>(ElementIterator e,</span>
<span>&nbsp;&nbsp;IndexIterator i);</span>
<br>
<span>template &lt;typename BidirectionalIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">reverse_iterator</a>< BidirectionalIterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-reverse-iterator">make&#95;reverse&#95;iterator</a></b>(BidirectionalIterator x);</span>
<br>
<span>template &lt;typename InputFunction,</span>
<span>&nbsp;&nbsp;typename OutputFunction,</span>
<span>&nbsp;&nbsp;typename Iterator&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__input__output__iterator.html">transform_input_output_iterator</a>< InputFunction, OutputFunction, Iterator > __host__ __device__ </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-transform-input-output-iterator">make&#95;transform&#95;input&#95;output&#95;iterator</a></b>(Iterator io,</span>
<span>&nbsp;&nbsp;InputFunction input_function,</span>
<span>&nbsp;&nbsp;OutputFunction output_function);</span>
<br>
<span>template &lt;class AdaptableUnaryFunction,</span>
<span>&nbsp;&nbsp;class Iterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__iterator.html">transform_iterator</a>< AdaptableUnaryFunction, Iterator > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-transform-iterator">make&#95;transform&#95;iterator</a></b>(Iterator it,</span>
<span>&nbsp;&nbsp;AdaptableUnaryFunction fun);</span>
<br>
<span>template &lt;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__output__iterator.html">transform_output_iterator</a>< UnaryFunction, OutputIterator > __host__ __device__ </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-transform-output-iterator">make&#95;transform&#95;output&#95;iterator</a></b>(OutputIterator out,</span>
<span>&nbsp;&nbsp;UnaryFunction fun);</span>
<br>
<span>template &lt;typename... Iterators&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip_iterator</a>< <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">thrust::tuple</a>< Iterators... > > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-zip-iterator">make&#95;zip&#95;iterator</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">thrust::tuple</a>< Iterators... > t);</span>
<br>
<span>template &lt;typename... Iterators&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip_iterator</a>< <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">thrust::tuple</a>< Iterators... > > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__fancyiterator.html#function-make-zip-iterator">make&#95;zip&#95;iterator</a></b>(Iterators... its);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__logical.html#function-all-of">all&#95;of</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__logical.html#function-all-of">all&#95;of</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__logical.html#function-any-of">any&#95;of</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__logical.html#function-any-of">any&#95;of</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__logical.html#function-none-of">none&#95;of</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__logical.html#function-none-of">none&#95;of</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy&gt;</span>
<span>__host__ __device__ pointer< void, DerivedPolicy > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-malloc">malloc</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;std::size_t n);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename DerivedPolicy&gt;</span>
<span>__host__ __device__ pointer< T, DerivedPolicy > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-malloc">malloc</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;std::size_t n);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename DerivedPolicy&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< thrust::pointer< T, DerivedPolicy >, typename thrust::pointer< T, DerivedPolicy >::difference_type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-get-temporary-buffer">get&#95;temporary&#95;buffer</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;typename thrust::pointer< T, DerivedPolicy >::difference_type n);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename Pointer&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-free">free</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;Pointer ptr);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename Pointer&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-return-temporary-buffer">return&#95;temporary&#95;buffer</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;Pointer p,</span>
<span>&nbsp;&nbsp;std::ptrdiff_t n);</span>
<br>
<span>template &lt;typename Pointer&gt;</span>
<span>__host__ __device__ thrust::detail::pointer_traits< Pointer >::raw_pointer </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-raw-pointer-cast">raw&#95;pointer&#95;cast</a></b>(Pointer ptr);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ detail::raw_reference< T >::type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-raw-reference-cast">raw&#95;reference&#95;cast</a></b>(T & ref);</span>
<br>
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ detail::raw_reference< constT >::type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__memory__management.html#function-raw-reference-cast">raw&#95;reference&#95;cast</a></b>(const T & ref);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__merging.html#function-merge">merge</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__merging.html#function-merge">merge</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__merging.html#function-merge">merge</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__merging.html#function-merge">merge</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__merging.html#function-merge-by-key">merge&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__merging.html#function-merge-by-key">merge&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__merging.html#function-merge-by-key">merge&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;Compare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__merging.html#function-merge-by-key">merge&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< InputIterator1, InputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-mismatch">mismatch</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< InputIterator1, InputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-mismatch">mismatch</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< InputIterator1, InputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-mismatch">mismatch</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;BinaryPredicate pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< InputIterator1, InputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-mismatch">mismatch</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;BinaryPredicate pred);</span>
<br>
<span class="doxybook-comment">/* \group relop  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator==">operator==</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator!=">operator!=</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<">operator&lt;</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>">operator&gt;</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<=">operator&lt;=</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>=">operator&gt;=</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator==">operator==</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator==">operator==</a></b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator!=">operator!=</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator!=">operator!=</a></b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<">operator&lt;</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > &,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<">operator&lt;</a></b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<=">operator&lt;=</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<=">operator&lt;=</a></b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > &);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>">operator&gt;</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>">operator&gt;</a></b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > &);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>=">operator&gt;=</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > &,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span>
<br>
<span class="doxybook-comment">/* \group relop_nullopt  */</span><span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>=">operator&gt;=</a></b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator==">operator==</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator==">operator==</a></b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator!=">operator!=</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator!=">operator!=</a></b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<">operator&lt;</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<">operator&lt;</a></b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<=">operator&lt;=</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator<=">operator&lt;=</a></b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>">operator&gt;</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>">operator&gt;</a></b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>=">operator&gt;=</a></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span>
<br>
<span class="doxybook-comment">/* \group relop_t  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-operator>=">operator&gt;=</a></b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span class="doxybook-comment">/* \synopsis template <class T>\nvoid swap(optional<T> &lhs, optional<T> &rhs);  */</span><span>template &lt;class T,</span>
<span>&nbsp;&nbsp;detail::enable_if_t< std::is_move_constructible< T >::value > * = nullptr,</span>
<span>&nbsp;&nbsp;detail::enable_if_t< detail::is_swappable< T >::value > * = nullptr&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-swap">swap</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span>
<br>
<span>template &lt;class T = detail::i&#95;am&#95;secret,</span>
<span>&nbsp;&nbsp;class U,</span>
<span>&nbsp;&nbsp;class Ret = detail::conditional&#95;t&lt;std::is&#95;same&lt;T, detail::i&#95;am&#95;secret&gt;::value,                                    detail::decay&#95;t&lt;U&gt;, T&gt;&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< Ret > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-make-optional">make&#95;optional</a></b>(U && v);</span>
<br>
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class... Args&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-make-optional">make&#95;optional</a></b>(Args &&... args);</span>
<br>
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U,</span>
<span>&nbsp;&nbsp;class... Args&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-make-optional">make&#95;optional</a></b>(std::initializer_list< U > il,</span>
<span>&nbsp;&nbsp;Args &&... args);</span>
<br>
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__pair.html#function-operator==">operator==</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span>
<br>
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__pair.html#function-operator<">operator&lt;</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span>
<br>
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__pair.html#function-operator!=">operator!=</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span>
<br>
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__pair.html#function-operator>">operator&gt;</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span>
<br>
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__pair.html#function-operator<=">operator&lt;=</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span>
<br>
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__pair.html#function-operator>=">operator&gt;=</a></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span>
<br>
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__pair.html#function-swap">swap</a></b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span>
<br>
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__pair.html#function-make-pair">make&#95;pair</a></b>(T1 x,</span>
<span>&nbsp;&nbsp;T2 y);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-partition">partition</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-partition">partition</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-partition">partition</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-partition">partition</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-partition-copy">partition&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-partition-copy">partition&#95;copy</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-partition-copy">partition&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-partition-copy">partition&#95;copy</a></b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-stable-partition">stable&#95;partition</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-stable-partition">stable&#95;partition</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-stable-partition">stable&#95;partition</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-stable-partition">stable&#95;partition</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-stable-partition-copy">stable&#95;partition&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-stable-partition-copy">stable&#95;partition&#95;copy</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-stable-partition-copy">stable&#95;partition&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__partitioning.html#function-stable-partition-copy">stable&#95;partition&#95;copy</a></b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-partition-point">partition&#95;point</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__searching.html#function-partition-point">partition&#95;point</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-partitioned">is&#95;partitioned</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-partitioned">is&#95;partitioned</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename MR,</span>
<span>&nbsp;&nbsp;typename DerivedPolicy&gt;</span>
<span>__host__ MR * </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-get-per-device-resource">get&#95;per&#95;device&#95;resource</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::value_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce">reduce</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last);</span>
<br>
<span>template &lt;typename InputIterator&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::value_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce">reduce</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ T </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce">reduce</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;T init);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>T </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce">reduce</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;T init);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ T </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce">reduce</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>T </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce">reduce</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce-by-key">reduce&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce-by-key">reduce&#95;by&#95;key</a></b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce-by-key">reduce&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce-by-key">reduce&#95;by&#95;key</a></b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce-by-key">reduce&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__reductions.html#function-reduce-by-key">reduce&#95;by&#95;key</a></b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove">remove</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove">remove</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-copy">remove&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-copy">remove&#95;copy</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;const T & value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-if">remove&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-if">remove&#95;if</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-copy-if">remove&#95;copy&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-copy-if">remove&#95;copy&#95;if</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-if">remove&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-if">remove&#95;if</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-copy-if">remove&#95;copy&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-remove-copy-if">remove&#95;copy&#95;if</a></b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace">replace</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & old_value,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace">replace</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & old_value,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-if">replace&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-if">replace&#95;if</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-if">replace&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-if">replace&#95;if</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-copy">replace&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;const T & old_value,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-copy">replace&#95;copy</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;const T & old_value,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-copy-if">replace&#95;copy&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-copy-if">replace&#95;copy&#95;if</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-copy-if">replace&#95;copy&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__replacing.html#function-replace-copy-if">replace&#95;copy&#95;if</a></b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename BidirectionalIterator&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-reverse">reverse</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;BidirectionalIterator first,</span>
<span>&nbsp;&nbsp;BidirectionalIterator last);</span>
<br>
<span>template &lt;typename BidirectionalIterator&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-reverse">reverse</a></b>(BidirectionalIterator first,</span>
<span>&nbsp;&nbsp;BidirectionalIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename BidirectionalIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-reverse-copy">reverse&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;BidirectionalIterator first,</span>
<span>&nbsp;&nbsp;BidirectionalIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename BidirectionalIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-reverse-copy">reverse&#95;copy</a></b>(BidirectionalIterator first,</span>
<span>&nbsp;&nbsp;BidirectionalIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-inclusive-scan">inclusive&#95;scan</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-inclusive-scan">inclusive&#95;scan</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-inclusive-scan">inclusive&#95;scan</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-inclusive-scan">inclusive&#95;scan</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-exclusive-scan">exclusive&#95;scan</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-exclusive-scan">exclusive&#95;scan</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-exclusive-scan">exclusive&#95;scan</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-exclusive-scan">exclusive&#95;scan</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-exclusive-scan">exclusive&#95;scan</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__prefixsums.html#function-exclusive-scan">exclusive&#95;scan</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key">inclusive&#95;scan&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key">inclusive&#95;scan&#95;by&#95;key</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key">inclusive&#95;scan&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key">inclusive&#95;scan&#95;by&#95;key</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key">inclusive&#95;scan&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key">inclusive&#95;scan&#95;by&#95;key</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key">exclusive&#95;scan&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key">exclusive&#95;scan&#95;by&#95;key</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key">exclusive&#95;scan&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key">exclusive&#95;scan&#95;by&#95;key</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key">exclusive&#95;scan&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key">exclusive&#95;scan&#95;by&#95;key</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key">exclusive&#95;scan&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key">exclusive&#95;scan&#95;by&#95;key</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__scattering.html#function-scatter">scatter</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;RandomAccessIterator result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__scattering.html#function-scatter">scatter</a></b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;RandomAccessIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__scattering.html#function-scatter-if">scatter&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator output);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__scattering.html#function-scatter-if">scatter&#95;if</a></b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator output);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__scattering.html#function-scatter-if">scatter&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator output,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__scattering.html#function-scatter-if">scatter&#95;if</a></b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator output,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-sequence">sequence</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename ForwardIterator&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-sequence">sequence</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-sequence">sequence</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;T init);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-sequence">sequence</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;T init);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-sequence">sequence</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;T step);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-sequence">sequence</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;T step);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-difference">set&#95;difference</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-difference">set&#95;difference</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-difference">set&#95;difference</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-difference">set&#95;difference</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-intersection">set&#95;intersection</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-intersection">set&#95;intersection</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-intersection">set&#95;intersection</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-intersection">set&#95;intersection</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-symmetric-difference">set&#95;symmetric&#95;difference</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-symmetric-difference">set&#95;symmetric&#95;difference</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-symmetric-difference">set&#95;symmetric&#95;difference</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-symmetric-difference">set&#95;symmetric&#95;difference</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-union">set&#95;union</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-union">set&#95;union</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-union">set&#95;union</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-union">set&#95;union</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-difference-by-key">set&#95;difference&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-difference-by-key">set&#95;difference&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-difference-by-key">set&#95;difference&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-difference-by-key">set&#95;difference&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-intersection-by-key">set&#95;intersection&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-intersection-by-key">set&#95;intersection&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-intersection-by-key">set&#95;intersection&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-intersection-by-key">set&#95;intersection&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-symmetric-difference-by-key">set&#95;symmetric&#95;difference&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-symmetric-difference-by-key">set&#95;symmetric&#95;difference&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-symmetric-difference-by-key">set&#95;symmetric&#95;difference&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-symmetric-difference-by-key">set&#95;symmetric&#95;difference&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-union-by-key">set&#95;union&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-union-by-key">set&#95;union&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-union-by-key">set&#95;union&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__set__operations.html#function-set-union-by-key">set&#95;union&#95;by&#95;key</a></b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomIterator,</span>
<span>&nbsp;&nbsp;typename URBG&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__shuffling.html#function-shuffle">shuffle</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomIterator first,</span>
<span>&nbsp;&nbsp;RandomIterator last,</span>
<span>&nbsp;&nbsp;URBG && g);</span>
<br>
<span>template &lt;typename RandomIterator,</span>
<span>&nbsp;&nbsp;typename URBG&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__shuffling.html#function-shuffle">shuffle</a></b>(RandomIterator first,</span>
<span>&nbsp;&nbsp;RandomIterator last,</span>
<span>&nbsp;&nbsp;URBG && g);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename URBG&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__shuffling.html#function-shuffle-copy">shuffle&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomIterator first,</span>
<span>&nbsp;&nbsp;RandomIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;URBG && g);</span>
<br>
<span>template &lt;typename RandomIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename URBG&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__shuffling.html#function-shuffle-copy">shuffle&#95;copy</a></b>(RandomIterator first,</span>
<span>&nbsp;&nbsp;RandomIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;URBG && g);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-sort">sort</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last);</span>
<br>
<span>template &lt;typename RandomAccessIterator&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-sort">sort</a></b>(RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-sort">sort</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-sort">sort</a></b>(RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-stable-sort">stable&#95;sort</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last);</span>
<br>
<span>template &lt;typename RandomAccessIterator&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-stable-sort">stable&#95;sort</a></b>(RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-stable-sort">stable&#95;sort</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-stable-sort">stable&#95;sort</a></b>(RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-sort-by-key">sort&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first);</span>
<br>
<span>template &lt;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-sort-by-key">sort&#95;by&#95;key</a></b>(RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-sort-by-key">sort&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-sort-by-key">sort&#95;by&#95;key</a></b>(RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-stable-sort-by-key">stable&#95;sort&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first);</span>
<br>
<span>template &lt;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-stable-sort-by-key">stable&#95;sort&#95;by&#95;key</a></b>(RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-stable-sort-by-key">stable&#95;sort&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__sorting.html#function-stable-sort-by-key">stable&#95;sort&#95;by&#95;key</a></b>(RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-sorted">is&#95;sorted</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename ForwardIterator&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-sorted">is&#95;sorted</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>__host__ __device__ bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-sorted">is&#95;sorted</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Compare comp);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>bool </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-sorted">is&#95;sorted</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Compare comp);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-sorted-until">is&#95;sorted&#95;until</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-sorted-until">is&#95;sorted&#95;until</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-sorted-until">is&#95;sorted&#95;until</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Compare comp);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__predicates.html#function-is-sorted-until">is&#95;sorted&#95;until</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Compare comp);</span>
<br>
<span>template &lt;typename Assignable1,</span>
<span>&nbsp;&nbsp;typename Assignable2&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__swap.html#function-swap">swap</a></b>(Assignable1 & a,</span>
<span>&nbsp;&nbsp;Assignable2 & b);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2&gt;</span>
<span>__host__ __device__ ForwardIterator2 </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-swap-ranges">swap&#95;ranges</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator1 first1,</span>
<span>&nbsp;&nbsp;ForwardIterator1 last1,</span>
<span>&nbsp;&nbsp;ForwardIterator2 first2);</span>
<br>
<span>template &lt;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2&gt;</span>
<span>ForwardIterator2 </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-swap-ranges">swap&#95;ranges</a></b>(ForwardIterator1 first1,</span>
<span>&nbsp;&nbsp;ForwardIterator1 last1,</span>
<span>&nbsp;&nbsp;ForwardIterator2 first2);</span>
<br>
<span>template &lt;typename DerivedPolicy&gt;</span>
<span>__host__ thrust::cuda::unique_eager_event </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-unique-eager-event-type">unique&#95;eager&#95;event&#95;type</a></b>(thrust::cuda::execution_policy< DerivedPolicy > const &);</span>
<br>
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename DerivedPolicy&gt;</span>
<span>__host__ thrust::cuda::unique_eager_future< T > </span><span><b><a href="{{ site.baseurl }}/api/namespaces/namespacethrust.html#function-unique-eager-future-type">unique&#95;eager&#95;future&#95;type</a></b>(thrust::cuda::execution_policy< DerivedPolicy > const &);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryOperation&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-tabulate">tabulate</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;UnaryOperation unary_op);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryOperation&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-tabulate">tabulate</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;UnaryOperation unary_op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform">transform</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform">transform</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform">transform</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction op);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform">transform</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform-if">transform&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform-if">transform&#95;if</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform-if">transform&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform-if">transform&#95;if</a></b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform-if">transform&#95;if</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformations.html#function-transform-if">transform&#95;if</a></b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename OutputType,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ OutputType </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__reductions.html#function-transform-reduce">transform&#95;reduce</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;OutputType init,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename OutputType,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>OutputType </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__reductions.html#function-transform-reduce">transform&#95;reduce</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;OutputType init,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__prefixsums.html#function-transform-inclusive-scan">transform&#95;inclusive&#95;scan</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__prefixsums.html#function-transform-inclusive-scan">transform&#95;inclusive&#95;scan</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__prefixsums.html#function-transform-exclusive-scan">transform&#95;exclusive&#95;scan</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__transformed__prefixsums.html#function-transform-exclusive-scan">transform&#95;exclusive&#95;scan</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span>
<br>
<span>template &lt;int N,</span>
<span>&nbsp;&nbsp;class HT,</span>
<span>&nbsp;&nbsp;class TT&gt;</span>
<span>__host__ __device__ access_traits< typenametuple_element< N, detail::cons< HT, TT > >::type >::non_const_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__tuple.html#function-get">get</a></b>(detail::cons< HT, TT > & t);</span>
<br>
<span>template &lt;int N,</span>
<span>&nbsp;&nbsp;class HT,</span>
<span>&nbsp;&nbsp;class TT&gt;</span>
<span>__host__ __device__ access_traits< typenametuple_element< N, detail::cons< HT, TT > >::type >::const_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__tuple.html#function-get">get</a></b>(const detail::cons< HT, TT > & t);</span>
<br>
<span>template &lt;class T0&gt;</span>
<span>__host__ __device__ detail::make_tuple_mapper< T0 >::type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__tuple.html#function-make-tuple">make&#95;tuple</a></b>(const T0 & t0);</span>
<br>
<span>template &lt;class T0,</span>
<span>&nbsp;&nbsp;class T1&gt;</span>
<span>__host__ __device__ detail::make_tuple_mapper< T0, T1 >::type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__tuple.html#function-make-tuple">make&#95;tuple</a></b>(const T0 & t0,</span>
<span>&nbsp;&nbsp;const T1 & t1);</span>
<br>
<span>template &lt;typename T0&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>< T0 & > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__tuple.html#function-tie">tie</a></b>(T0 & t0);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>< T0 &, T1 & > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__tuple.html#function-tie">tie</a></b>(T0 & t0,</span>
<span>&nbsp;&nbsp;T1 & t1);</span>
<br>
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1,</span>
<span>&nbsp;&nbsp;typename T2,</span>
<span>&nbsp;&nbsp;typename T3,</span>
<span>&nbsp;&nbsp;typename T4,</span>
<span>&nbsp;&nbsp;typename T5,</span>
<span>&nbsp;&nbsp;typename T6,</span>
<span>&nbsp;&nbsp;typename T7,</span>
<span>&nbsp;&nbsp;typename T8,</span>
<span>&nbsp;&nbsp;typename T9,</span>
<span>&nbsp;&nbsp;typename U0,</span>
<span>&nbsp;&nbsp;typename U1,</span>
<span>&nbsp;&nbsp;typename U2,</span>
<span>&nbsp;&nbsp;typename U3,</span>
<span>&nbsp;&nbsp;typename U4,</span>
<span>&nbsp;&nbsp;typename U5,</span>
<span>&nbsp;&nbsp;typename U6,</span>
<span>&nbsp;&nbsp;typename U7,</span>
<span>&nbsp;&nbsp;typename U8,</span>
<span>&nbsp;&nbsp;typename U9&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__tuple.html#function-swap">swap</a></b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9 > & x,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>< U0, U1, U2, U3, U4, U5, U6, U7, U8, U9 > & y);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-uninitialized-copy">uninitialized&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;ForwardIterator result);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-uninitialized-copy">uninitialized&#95;copy</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;ForwardIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-uninitialized-copy-n">uninitialized&#95;copy&#95;n</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;ForwardIterator result);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__copying.html#function-uninitialized-copy-n">uninitialized&#95;copy&#95;n</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;ForwardIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__filling.html#function-uninitialized-fill">uninitialized&#95;fill</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & x);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b><a href="{{ site.baseurl }}/api/groups/group__filling.html#function-uninitialized-fill">uninitialized&#95;fill</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & x);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__filling.html#function-uninitialized-fill-n">uninitialized&#95;fill&#95;n</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;const T & x);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__filling.html#function-uninitialized-fill-n">uninitialized&#95;fill&#95;n</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;const T & x);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique">unique</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique">unique</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique">unique</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>ForwardIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique">unique</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-copy">unique&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-copy">unique&#95;copy</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-copy">unique&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>OutputIterator </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-copy">unique&#95;copy</a></b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator1, ForwardIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-by-key">unique&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_first,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_last,</span>
<span>&nbsp;&nbsp;ForwardIterator2 values_first);</span>
<br>
<span>template &lt;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator1, ForwardIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-by-key">unique&#95;by&#95;key</a></b>(ForwardIterator1 keys_first,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_last,</span>
<span>&nbsp;&nbsp;ForwardIterator2 values_first);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator1, ForwardIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-by-key">unique&#95;by&#95;key</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_first,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_last,</span>
<span>&nbsp;&nbsp;ForwardIterator2 values_first,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator1, ForwardIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-by-key">unique&#95;by&#95;key</a></b>(ForwardIterator1 keys_first,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_last,</span>
<span>&nbsp;&nbsp;ForwardIterator2 values_first,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-by-key-copy">unique&#95;by&#95;key&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-by-key-copy">unique&#95;by&#95;key&#95;copy</a></b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-by-key-copy">unique&#95;by&#95;key&#95;copy</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-by-key-copy">unique&#95;by&#95;key&#95;copy</a></b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< ForwardIterator >::difference_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-count">unique&#95;count</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< ForwardIterator >::difference_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-count">unique&#95;count</a></b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< ForwardIterator >::difference_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-count">unique&#95;count</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span>
<br>
<span>template &lt;typename ForwardIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< ForwardIterator >::difference_type </span><span><b><a href="{{ site.baseurl }}/api/groups/group__stream__compaction.html#function-unique-count">unique&#95;count</a></b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span>
<br>
<span>template &lt;typename Function&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__function.html">zip_function</a>< typename std::decay< Function >::type > </span><span><b><a href="{{ site.baseurl }}/api/groups/group__function__object__adaptors.html#function-make-zip-function">make&#95;zip&#95;function</a></b>(Function && fun);</span>
<span>} /* namespace thrust */</span>
</code>

## Member Classes

<h3 id="struct-thrustallocator-delete">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1allocator__delete.html">Struct <code>thrust::allocator&#95;delete</code>
</a>
</h3>

<h3 id="struct-thrustarray-allocator-delete">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1array__allocator__delete.html">Struct <code>thrust::array&#95;allocator&#95;delete</code>
</a>
</h3>

<h3 id="class-thrustbad-optional-access">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1bad__optional__access.html">Class <code>thrust::bad&#95;optional&#95;access</code>
</a>
</h3>

**Inherits From**:
`std::exception`

<h3 id="struct-thrustbidirectional-device-iterator-tag">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1bidirectional__device__iterator__tag.html">Struct <code>thrust::bidirectional&#95;device&#95;iterator&#95;tag</code>
</a>
</h3>

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::bidirectional_iterator_tag, thrust::device_system_tag, thrust::bidirectional_traversal_tag >`

<h3 id="struct-thrustbinary-function">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1binary__function.html">Struct <code>thrust::binary&#95;function</code>
</a>
</h3>

<h3 id="struct-thrustbinary-negate">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1binary__negate.html">Struct <code>thrust::binary&#95;negate</code>
</a>
</h3>

**Inherits From**:
[`thrust::binary_function< Predicate::first_argument_type, Predicate::second_argument_type, bool >`]({{ site.baseurl }}/api/classes/structthrust_1_1binary__function.html)

<h3 id="struct-thrustbinary-traits">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1binary__traits.html">Struct <code>thrust::binary&#95;traits</code>
</a>
</h3>

<h3 id="struct-thrustbit-and">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__and.html">Struct <code>thrust::bit&#95;and</code>
</a>
</h3>

<h3 id="struct-thrustbit-and<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__and_3_01void_01_4.html">Struct <code>thrust::bit&#95;and&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustbit-or">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__or.html">Struct <code>thrust::bit&#95;or</code>
</a>
</h3>

<h3 id="struct-thrustbit-or<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__or_3_01void_01_4.html">Struct <code>thrust::bit&#95;or&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustbit-xor">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__xor.html">Struct <code>thrust::bit&#95;xor</code>
</a>
</h3>

<h3 id="struct-thrustbit-xor<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1bit__xor_3_01void_01_4.html">Struct <code>thrust::bit&#95;xor&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustcomplex">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">Struct <code>thrust::complex</code>
</a>
</h3>

<h3 id="struct-thrustconjunction-value">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1conjunction__value.html">Struct <code>thrust::conjunction&#95;value</code>
</a>
</h3>

<a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>(... && Bs)</code>. 

<h3 id="class-thrustconstant-iterator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">Class <code>thrust::constant&#95;iterator</code>
</a>
</h3>

**Inherits From**:
`detail::constant_iterator_base::type`

<h3 id="class-thrustcounting-iterator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1counting__iterator.html">Class <code>thrust::counting&#95;iterator</code>
</a>
</h3>

**Inherits From**:
`detail::counting_iterator_base::type`

<h3 id="class-thrustdevice-allocator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__allocator.html">Class <code>thrust::device&#95;allocator</code>
</a>
</h3>

An allocator which creates new elements in memory accessible by devices. 

**Inherits From**:
* `thrust::mr::stateless_resource_allocator< T, device_ptr_memory_resource< device_memory_resource > >`
* `thrust::mr::allocator< T, Upstream >`
* `thrust::mr::validator< MR >`

<h3 id="struct-thrustdevice-execution-policy">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1device__execution__policy.html">Struct <code>thrust::device&#95;execution&#95;policy</code>
</a>
</h3>

**Inherits From**:
`thrust::system::__THRUST_DEVICE_SYSTEM_NAMESPACE::execution_policy< DerivedPolicy >`

<h3 id="class-thrustdevice-malloc-allocator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__malloc__allocator.html">Class <code>thrust::device&#95;malloc&#95;allocator</code>
</a>
</h3>

<h3 id="class-thrustdevice-new-allocator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__new__allocator.html">Class <code>thrust::device&#95;new&#95;allocator</code>
</a>
</h3>

<h3 id="class-thrustdevice-ptr">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">Class <code>thrust::device&#95;ptr</code>
</a>
</h3>

<code>device&#95;ptr</code> is a pointer-like object which points to an object that resides in memory associated with the device system. 

**Inherits From**:
`thrust::pointer< T, thrust::device_system_tag, thrust::device_reference< T >, thrust::device_ptr< T > >`

<h3 id="class-thrustdevice-ptr-memory-resource">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr__memory__resource.html">Class <code>thrust::device&#95;ptr&#95;memory&#95;resource</code>
</a>
</h3>

**Inherits From**:
[`thrust::mr::memory_resource< device_ptr< void > >`]({{ site.baseurl }}/api/classes/classthrust_1_1mr_1_1memory__resource.html)

<h3 id="class-thrustdevice-reference">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">Class <code>thrust::device&#95;reference</code>
</a>
</h3>

**Inherits From**:
`thrust::reference< T, thrust::device_ptr< T >, thrust::device_reference< T > >`

<h3 id="class-thrustdevice-vector">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">Class <code>thrust::device&#95;vector</code>
</a>
</h3>

**Inherits From**:
`detail::vector_base< T, thrust::device_allocator< T > >`

<h3 id="class-thrustdiscard-iterator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1discard__iterator.html">Class <code>thrust::discard&#95;iterator</code>
</a>
</h3>

**Inherits From**:
`detail::discard_iterator_base::type`

<h3 id="struct-thrustdisjunction-value">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1disjunction__value.html">Struct <code>thrust::disjunction&#95;value</code>
</a>
</h3>

<a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>(... || Bs)</code>. 

<h3 id="struct-thrustdivides">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1divides.html">Struct <code>thrust::divides</code>
</a>
</h3>

<h3 id="struct-thrustdivides<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1divides_3_01void_01_4.html">Struct <code>thrust::divides&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustequal-to">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html">Struct <code>thrust::equal&#95;to</code>
</a>
</h3>

<h3 id="struct-thrustequal-to<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to_3_01void_01_4.html">Struct <code>thrust::equal&#95;to&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustforward-device-iterator-tag">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1forward__device__iterator__tag.html">Struct <code>thrust::forward&#95;device&#95;iterator&#95;tag</code>
</a>
</h3>

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::forward_iterator_tag, thrust::device_system_tag, thrust::forward_traversal_tag >`

<h3 id="struct-thrustgreater">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1greater.html">Struct <code>thrust::greater</code>
</a>
</h3>

<h3 id="struct-thrustgreater<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1greater_3_01void_01_4.html">Struct <code>thrust::greater&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustgreater-equal">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1greater__equal.html">Struct <code>thrust::greater&#95;equal</code>
</a>
</h3>

<h3 id="struct-thrustgreater-equal<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1greater__equal_3_01void_01_4.html">Struct <code>thrust::greater&#95;equal&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrusthost-execution-policy">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1host__execution__policy.html">Struct <code>thrust::host&#95;execution&#95;policy</code>
</a>
</h3>

**Inherits From**:
`thrust::system::__THRUST_HOST_SYSTEM_NAMESPACE::execution_policy< DerivedPolicy >`

<h3 id="class-thrusthost-vector">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">Class <code>thrust::host&#95;vector</code>
</a>
</h3>

**Inherits From**:
`detail::vector_base< T, std::allocator< T > >`

<h3 id="struct-thrustidentity">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1identity.html">Struct <code>thrust::identity</code>
</a>
</h3>

<h3 id="struct-thrustidentity<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1identity_3_01void_01_4.html">Struct <code>thrust::identity&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustin-place-t">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1in__place__t.html">Struct <code>thrust::in&#95;place&#95;t</code>
</a>
</h3>

A tag type to tell optional to construct its value in-place. 

<h3 id="struct-thrustinput-device-iterator-tag">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1input__device__iterator__tag.html">Struct <code>thrust::input&#95;device&#95;iterator&#95;tag</code>
</a>
</h3>

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::input_iterator_tag, thrust::device_system_tag, thrust::single_pass_traversal_tag >`

<h3 id="class-thrustiterator-adaptor">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1iterator__adaptor.html">Class <code>thrust::iterator&#95;adaptor</code>
</a>
</h3>

**Inherits From**:
`detail::iterator_adaptor_base::type`

<h3 id="class-thrustiterator-core-access">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1iterator__core__access.html">Class <code>thrust::iterator&#95;core&#95;access</code>
</a>
</h3>

<h3 id="struct-thrustiterator-difference">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__difference.html">Struct <code>thrust::iterator&#95;difference</code>
</a>
</h3>

<h3 id="class-thrustiterator-facade">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1iterator__facade.html">Class <code>thrust::iterator&#95;facade</code>
</a>
</h3>

<h3 id="struct-thrustiterator-pointer">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__pointer.html">Struct <code>thrust::iterator&#95;pointer</code>
</a>
</h3>

<h3 id="struct-thrustiterator-reference">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__reference.html">Struct <code>thrust::iterator&#95;reference</code>
</a>
</h3>

<h3 id="struct-thrustiterator-system">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__system.html">Struct <code>thrust::iterator&#95;system</code>
</a>
</h3>

<h3 id="struct-thrustiterator-traits">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">Struct <code>thrust::iterator&#95;traits</code>
</a>
</h3>

**Inherits From**:
`std::iterator_traits< T >`

<h3 id="struct-thrustiterator-traversal">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traversal.html">Struct <code>thrust::iterator&#95;traversal</code>
</a>
</h3>

<h3 id="struct-thrustiterator-value">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__value.html">Struct <code>thrust::iterator&#95;value</code>
</a>
</h3>

<h3 id="struct-thrustless">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1less.html">Struct <code>thrust::less</code>
</a>
</h3>

<h3 id="struct-thrustless<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1less_3_01void_01_4.html">Struct <code>thrust::less&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustless-equal">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1less__equal.html">Struct <code>thrust::less&#95;equal</code>
</a>
</h3>

<h3 id="struct-thrustless-equal<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1less__equal_3_01void_01_4.html">Struct <code>thrust::less&#95;equal&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustlogical-and">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__and.html">Struct <code>thrust::logical&#95;and</code>
</a>
</h3>

<h3 id="struct-thrustlogical-and<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__and_3_01void_01_4.html">Struct <code>thrust::logical&#95;and&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustlogical-not">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__not.html">Struct <code>thrust::logical&#95;not</code>
</a>
</h3>

<h3 id="struct-thrustlogical-not<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__not_3_01void_01_4.html">Struct <code>thrust::logical&#95;not&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustlogical-or">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__or.html">Struct <code>thrust::logical&#95;or</code>
</a>
</h3>

<h3 id="struct-thrustlogical-or<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1logical__or_3_01void_01_4.html">Struct <code>thrust::logical&#95;or&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustmaximum">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1maximum.html">Struct <code>thrust::maximum</code>
</a>
</h3>

<h3 id="struct-thrustmaximum<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1maximum_3_01void_01_4.html">Struct <code>thrust::maximum&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustminimum">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1minimum.html">Struct <code>thrust::minimum</code>
</a>
</h3>

<h3 id="struct-thrustminimum<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1minimum_3_01void_01_4.html">Struct <code>thrust::minimum&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustminus">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1minus.html">Struct <code>thrust::minus</code>
</a>
</h3>

<h3 id="struct-thrustminus<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1minus_3_01void_01_4.html">Struct <code>thrust::minus&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustmodulus">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1modulus.html">Struct <code>thrust::modulus</code>
</a>
</h3>

<h3 id="struct-thrustmodulus<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1modulus_3_01void_01_4.html">Struct <code>thrust::modulus&lt; void &gt;</code>
</a>
</h3>

<h3 id="class-thrustmonostate">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1monostate.html">Class <code>thrust::monostate</code>
</a>
</h3>

Used to represent an optional with no data; essentially a bool. 

<h3 id="struct-thrustmultiplies">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1multiplies.html">Struct <code>thrust::multiplies</code>
</a>
</h3>

<h3 id="struct-thrustmultiplies<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1multiplies_3_01void_01_4.html">Struct <code>thrust::multiplies&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustnegate">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1negate.html">Struct <code>thrust::negate</code>
</a>
</h3>

<h3 id="struct-thrustnegate<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1negate_3_01void_01_4.html">Struct <code>thrust::negate&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustnegation-value">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1negation__value.html">Struct <code>thrust::negation&#95;value</code>
</a>
</h3>

<a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>!Bs</code>. 

<h3 id="struct-thrustnew-stream-t">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1new__stream__t.html">Struct <code>thrust::new&#95;stream&#95;t</code>
</a>
</h3>

<h3 id="struct-thrustnot-equal-to">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1not__equal__to.html">Struct <code>thrust::not&#95;equal&#95;to</code>
</a>
</h3>

<h3 id="struct-thrustnot-equal-to<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1not__equal__to_3_01void_01_4.html">Struct <code>thrust::not&#95;equal&#95;to&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustnullopt-t">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">Struct <code>thrust::nullopt&#95;t</code>
</a>
</h3>

A tag type to represent an empty optional. 

<h3 id="struct-thrustnumeric-limits">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1numeric__limits.html">Struct <code>thrust::numeric&#95;limits</code>
</a>
</h3>

**Inherits From**:
`std::numeric_limits< T >`

<h3 id="class-thrustoptional">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">Class <code>thrust::optional</code>
</a>
</h3>

An optional object is an object that contains the storage for another object and manages the lifetime of this contained object, if any. 

**Inherits From**:
* `thrust::detail::optional_move_assign_base< T >`
* `thrust::detail::optional_delete_ctor_base< T >`
* `thrust::detail::optional_delete_assign_base< T >`

<h3 id="class-thrustoptional<-t-&->">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional_3_01t_01_6_01_4.html">Class <code>thrust::optional&lt; T & &gt;</code>
</a>
</h3>

Specialization for when <code>T</code> is a reference. 

<h3 id="struct-thrustoutput-device-iterator-tag">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1output__device__iterator__tag.html">Struct <code>thrust::output&#95;device&#95;iterator&#95;tag</code>
</a>
</h3>

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::output_iterator_tag, thrust::device_system_tag, thrust::single_pass_traversal_tag >`

<h3 id="struct-thrustpair">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">Struct <code>thrust::pair</code>
</a>
</h3>

<h3 id="class-thrustper-device-allocator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1per__device__allocator.html">Class <code>thrust::per&#95;device&#95;allocator</code>
</a>
</h3>

**Inherits From**:
* `thrust::mr::allocator< T, Upstream >`
* `thrust::mr::validator< MR >`

<h3 id="class-thrustpermutation-iterator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1permutation__iterator.html">Class <code>thrust::permutation&#95;iterator</code>
</a>
</h3>

**Inherits From**:
`thrust::detail::permutation_iterator_base::type`

<h3 id="struct-thrustplus">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1plus.html">Struct <code>thrust::plus</code>
</a>
</h3>

<h3 id="struct-thrustplus<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1plus_3_01void_01_4.html">Struct <code>thrust::plus&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustproclaim-contiguous-iterator">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1proclaim__contiguous__iterator.html">Struct <code>thrust::proclaim&#95;contiguous&#95;iterator</code>
</a>
</h3>

Customization point that can be customized to indicate that an iterator type <code>Iterator</code> satisfies <a href="https://en.cppreference.com/w/cpp/named_req/ContiguousIterator">ContiguousIterator</a>, aka it points to elements that are contiguous in memory. 

**Inherits From**:
`false_type`

<h3 id="struct-thrustproject1st">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">Struct <code>thrust::project1st</code>
</a>
</h3>

<h3 id="struct-thrustproject1st<-void,-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st_3_01void_00_01void_01_4.html">Struct <code>thrust::project1st&lt; void, void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustproject2nd">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1project2nd.html">Struct <code>thrust::project2nd</code>
</a>
</h3>

<h3 id="struct-thrustproject2nd<-void,-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1project2nd_3_01void_00_01void_01_4.html">Struct <code>thrust::project2nd&lt; void, void &gt;</code>
</a>
</h3>

<h3 id="struct-thrustrandom-access-device-iterator-tag">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1random__access__device__iterator__tag.html">Struct <code>thrust::random&#95;access&#95;device&#95;iterator&#95;tag</code>
</a>
</h3>

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::random_access_iterator_tag, thrust::device_system_tag, thrust::random_access_traversal_tag >`

<h3 id="struct-thrustremove-cvref">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1remove__cvref.html">Struct <code>thrust::remove&#95;cvref</code>
</a>
</h3>

<a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that removes <a href="https://en.cppreference.com/w/cpp/language/cv">const-volatile qualifiers</a> and <a href="https://en.cppreference.com/w/cpp/language/reference">references</a> from <code>T</code>. Equivalent to <code>remove&#95;cv&#95;t&lt;remove&#95;reference&#95;t&lt;T&gt;&gt;</code>. 

<h3 id="class-thrustreverse-iterator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">Class <code>thrust::reverse&#95;iterator</code>
</a>
</h3>

**Inherits From**:
`detail::reverse_iterator_base::type`

<h3 id="struct-thrustsquare">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1square.html">Struct <code>thrust::square</code>
</a>
</h3>

<h3 id="struct-thrustsquare<-void->">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1square_3_01void_01_4.html">Struct <code>thrust::square&lt; void &gt;</code>
</a>
</h3>

<h3 id="struct-thrusttagged-deleter">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1tagged__deleter.html">Struct <code>thrust::tagged&#95;deleter</code>
</a>
</h3>

**Inherits From**:
`Lambda`

<h3 id="class-thrusttransform-input-output-iterator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__input__output__iterator.html">Class <code>thrust::transform&#95;input&#95;output&#95;iterator</code>
</a>
</h3>

**Inherits From**:
`detail::transform_input_output_iterator_base::type`

<h3 id="class-thrusttransform-iterator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__iterator.html">Class <code>thrust::transform&#95;iterator</code>
</a>
</h3>

**Inherits From**:
`detail::transform_iterator_base::type`

<h3 id="class-thrusttransform-output-iterator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__output__iterator.html">Class <code>thrust::transform&#95;output&#95;iterator</code>
</a>
</h3>

**Inherits From**:
`detail::transform_output_iterator_base::type`

<h3 id="class-thrusttuple">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">Class <code>thrust::tuple</code>
</a>
</h3>

<code>tuple</code> is a class template that can be instantiated with up to ten arguments. Each template argument specifies the type of element in the <code>tuple</code>. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of <code>tuple</code> with two arguments is similar to an instantiation of <code>pair</code> with the same two arguments. Individual elements of a <code>tuple</code> may be accessed with the <code>get</code> function. 

<h3 id="struct-thrusttuple-element">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1tuple__element.html">Struct <code>thrust::tuple&#95;element</code>
</a>
</h3>

<h3 id="struct-thrusttuple-size">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1tuple__size.html">Struct <code>thrust::tuple&#95;size</code>
</a>
</h3>

<h3 id="struct-thrustunary-function">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1unary__function.html">Struct <code>thrust::unary&#95;function</code>
</a>
</h3>

<h3 id="struct-thrustunary-negate">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1unary__negate.html">Struct <code>thrust::unary&#95;negate</code>
</a>
</h3>

**Inherits From**:
[`thrust::unary_function< Predicate::argument_type, bool >`]({{ site.baseurl }}/api/classes/structthrust_1_1unary__function.html)

<h3 id="struct-thrustunary-traits">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1unary__traits.html">Struct <code>thrust::unary&#95;traits</code>
</a>
</h3>

<h3 id="struct-thrustvoider">
<a href="{{ site.baseurl }}/api/classes/structthrust_1_1voider.html">Struct <code>thrust::voider</code>
</a>
</h3>

<h3 id="class-thrustzip-function">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__function.html">Class <code>thrust::zip&#95;function</code>
</a>
</h3>

<h3 id="class-thrustzip-iterator">
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">Class <code>thrust::zip&#95;iterator</code>
</a>
</h3>

**Inherits From**:
`detail::zip_iterator_base::type`


## Types

<h3 id="using-uninitialized-allocator-delete">
Type Alias <code>thrust::uninitialized&#95;allocator&#95;delete</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator&gt;</span>
<span>using <b>uninitialized_allocator_delete</b> = allocator&#95;delete&lt; T, Allocator, true &gt;;</span></code>
<h3 id="using-uninitialized-array-allocator-delete">
Type Alias <code>thrust::uninitialized&#95;array&#95;allocator&#95;delete</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator&gt;</span>
<span>using <b>uninitialized_array_allocator_delete</b> = array&#95;allocator&#95;delete&lt; T, Allocator, true &gt;;</span></code>
<h3 id="using-unique-eager-event">
Type Alias <code>thrust::unique&#95;eager&#95;event</code>
</h3>

<code class="doxybook">
<span>template &lt;typename System&gt;</span>
<span>using <b>unique_eager_event</b> = unique&#95;eager&#95;event&#95;type&#95;detail::select&lt; System &gt;;</span></code>
<h3 id="using-event">
Type Alias <code>thrust::event</code>
</h3>

<code class="doxybook">
<span>template &lt;typename System&gt;</span>
<span>using <b>event</b> = unique&#95;eager&#95;event&lt; System &gt;;</span></code>
<h3 id="using-unique-eager-future">
Type Alias <code>thrust::unique&#95;eager&#95;future</code>
</h3>

<code class="doxybook">
<span>template &lt;typename System,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>using <b>unique_eager_future</b> = unique&#95;eager&#95;future&#95;type&#95;detail::select&lt; System, T &gt;;</span></code>
<h3 id="using-future">
Type Alias <code>thrust::future</code>
</h3>

<code class="doxybook">
<span>template &lt;typename System,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>using <b>future</b> = unique&#95;eager&#95;future&lt; System, T &gt;;</span></code>
<h3 id="using-device-unique-eager-event">
Type Alias <code>thrust::device&#95;unique&#95;eager&#95;event</code>
</h3>

<code class="doxybook">
<span>using <b>device_unique_eager_event</b> = unique&#95;eager&#95;event&#95;type&#95;detail::select&lt; thrust::system::&#95;&#95;THRUST&#95;DEVICE&#95;SYSTEM&#95;NAMESPACE::tag &gt;;</span></code>
<h3 id="using-device-event">
Type Alias <code>thrust::device&#95;event</code>
</h3>

<code class="doxybook">
<span>using <b>device_event</b> = device&#95;unique&#95;eager&#95;event;</span></code>
<h3 id="using-device-unique-eager-future">
Type Alias <code>thrust::device&#95;unique&#95;eager&#95;future</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>device_unique_eager_future</b> = unique&#95;eager&#95;future&#95;type&#95;detail::select&lt; thrust::system::&#95;&#95;THRUST&#95;DEVICE&#95;SYSTEM&#95;NAMESPACE::tag, T &gt;;</span></code>
<h3 id="using-device-future">
Type Alias <code>thrust::device&#95;future</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>device_future</b> = device&#95;unique&#95;eager&#95;future&lt; T &gt;;</span></code>
<h3 id="typedef-input-host-iterator-tag">
Typedef <code>thrust::input&#95;host&#95;iterator&#95;tag</code>
</h3>

<code class="doxybook">
<span>typedef std::input_iterator_tag<b>input_host_iterator_tag</b>;</span></code>
<code>input&#95;host&#95;iterator&#95;tag</code> is an empty class: it has no member functions, member variables, or nested types. It is used solely as a "tag": a representation of the Input Host Iterator concept within the C++ type system.

**See**:
<a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags">https://en.cppreference.com/w/cpp/iterator/iterator_tags</a><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">iterator_traits</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1input__device__iterator__tag.html">input_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1output__device__iterator__tag.html">output_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1forward__device__iterator__tag.html">forward_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1bidirectional__device__iterator__tag.html">bidirectional_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1random__access__device__iterator__tag.html">random_access_device_iterator_tag</a>, output_host_iterator_tag, forward_host_iterator_tag, bidirectional_host_iterator_tag, random_access_host_iterator_tag 

<h3 id="typedef-output-host-iterator-tag">
Typedef <code>thrust::output&#95;host&#95;iterator&#95;tag</code>
</h3>

<code class="doxybook">
<span>typedef std::output_iterator_tag<b>output_host_iterator_tag</b>;</span></code>
<code>output&#95;host&#95;iterator&#95;tag</code> is an empty class: it has no member functions, member variables, or nested types. It is used solely as a "tag": a representation of the Output Host Iterator concept within the C++ type system.

**See**:
<a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags">https://en.cppreference.com/w/cpp/iterator/iterator_tags</a><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">iterator_traits</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1input__device__iterator__tag.html">input_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1output__device__iterator__tag.html">output_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1forward__device__iterator__tag.html">forward_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1bidirectional__device__iterator__tag.html">bidirectional_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1random__access__device__iterator__tag.html">random_access_device_iterator_tag</a>, input_host_iterator_tag, forward_host_iterator_tag, bidirectional_host_iterator_tag, random_access_host_iterator_tag 

<h3 id="typedef-forward-host-iterator-tag">
Typedef <code>thrust::forward&#95;host&#95;iterator&#95;tag</code>
</h3>

<code class="doxybook">
<span>typedef std::forward_iterator_tag<b>forward_host_iterator_tag</b>;</span></code>
<code>forward&#95;host&#95;iterator&#95;tag</code> is an empty class: it has no member functions, member variables, or nested types. It is used solely as a "tag": a representation of the Forward Host Iterator concept within the C++ type system.

**See**:
<a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags">https://en.cppreference.com/w/cpp/iterator/iterator_tags</a><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">iterator_traits</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1input__device__iterator__tag.html">input_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1output__device__iterator__tag.html">output_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1forward__device__iterator__tag.html">forward_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1bidirectional__device__iterator__tag.html">bidirectional_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1random__access__device__iterator__tag.html">random_access_device_iterator_tag</a>, input_host_iterator_tag, output_host_iterator_tag, bidirectional_host_iterator_tag, random_access_host_iterator_tag 

<h3 id="typedef-bidirectional-host-iterator-tag">
Typedef <code>thrust::bidirectional&#95;host&#95;iterator&#95;tag</code>
</h3>

<code class="doxybook">
<span>typedef std::bidirectional_iterator_tag<b>bidirectional_host_iterator_tag</b>;</span></code>
<code>bidirectional&#95;host&#95;iterator&#95;tag</code> is an empty class: it has no member functions, member variables, or nested types. It is used solely as a "tag": a representation of the Forward Host Iterator concept within the C++ type system.

**See**:
<a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags">https://en.cppreference.com/w/cpp/iterator/iterator_tags</a><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">iterator_traits</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1input__device__iterator__tag.html">input_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1output__device__iterator__tag.html">output_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1forward__device__iterator__tag.html">forward_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1bidirectional__device__iterator__tag.html">bidirectional_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1random__access__device__iterator__tag.html">random_access_device_iterator_tag</a>, input_host_iterator_tag, output_host_iterator_tag, forward_host_iterator_tag, random_access_host_iterator_tag 

<h3 id="typedef-random-access-host-iterator-tag">
Typedef <code>thrust::random&#95;access&#95;host&#95;iterator&#95;tag</code>
</h3>

<code class="doxybook">
<span>typedef std::random_access_iterator_tag<b>random_access_host_iterator_tag</b>;</span></code>
<code>random&#95;access&#95;host&#95;iterator&#95;tag</code> is an empty class: it has no member functions, member variables, or nested types. It is used solely as a "tag": a representation of the Forward Host Iterator concept within the C++ type system.

**See**:
<a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags">https://en.cppreference.com/w/cpp/iterator/iterator_tags</a><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">iterator_traits</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1input__device__iterator__tag.html">input_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1output__device__iterator__tag.html">output_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1forward__device__iterator__tag.html">forward_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1bidirectional__device__iterator__tag.html">bidirectional_device_iterator_tag</a>, <a href="{{ site.baseurl }}/api/classes/structthrust_1_1random__access__device__iterator__tag.html">random_access_device_iterator_tag</a>, input_host_iterator_tag, output_host_iterator_tag, forward_host_iterator_tag, bidirectional_host_iterator_tag 

<h3 id="typedef-device-memory-resource">
Typedef <code>thrust::device&#95;memory&#95;resource</code>
</h3>

<code class="doxybook">
<span>typedef thrust::system::__THRUST_DEVICE_SYSTEM_NAMESPACE::memory_resource<b>device_memory_resource</b>;</span></code>
<h3 id="typedef-universal-memory-resource">
Typedef <code>thrust::universal&#95;memory&#95;resource</code>
</h3>

<code class="doxybook">
<span>typedef thrust::system::__THRUST_DEVICE_SYSTEM_NAMESPACE::universal_memory_resource<b>universal_memory_resource</b>;</span></code>
<h3 id="typedef-universal-host-pinned-memory-resource">
Typedef <code>thrust::universal&#95;host&#95;pinned&#95;memory&#95;resource</code>
</h3>

<code class="doxybook">
<span>typedef thrust::system::__THRUST_DEVICE_SYSTEM_NAMESPACE::universal_host_pinned_memory_resource<b>universal_host_pinned_memory_resource</b>;</span></code>
<h3 id="typedef-host-memory-resource">
Typedef <code>thrust::host&#95;memory&#95;resource</code>
</h3>

<code class="doxybook">
<span>typedef thrust::system::__THRUST_HOST_SYSTEM_NAMESPACE::memory_resource<b>host_memory_resource</b>;</span></code>
<h3 id="using-integer-sequence">
Type Alias <code>thrust::integer&#95;sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;T... Is&gt;</span>
<span>using <b>integer_sequence</b> = std::integer&#95;sequence&lt; T, Is... &gt;;</span></code>
A compile-time sequence of <a href="https://en.cppreference.com/w/cpp/language/constant_expression#Integral_constant_expression">_integral constants_</a> of type <code>T</code> with values <code>Is...</code>. 

**See**:
* <a href="https://en.cppreference.com/w/cpp/language/constant_expression#Integral_constant_expression">_integral constants_</a>
* index_sequence 
* make_integer_sequence 
* make_reversed_integer_sequence 
* make_index_sequence 
* make_reversed_index_sequence 
* integer_sequence_push_front 
* integer_sequence_push_back 
* <a href="https://en.cppreference.com/w/cpp/utility/integer_sequence"><code>std::integer&#95;sequence</code></a>

<h3 id="using-index-sequence">
Type Alias <code>thrust::index&#95;sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;std::size_t... Is&gt;</span>
<span>using <b>index_sequence</b> = std::index&#95;sequence&lt; Is... &gt;;</span></code>
A compile-time sequence of type <a href="https://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> with values <code>Is...</code>. 

**See**:
* integer_sequence 
* make_integer_sequence 
* make_reversed_integer_sequence 
* make_index_sequence 
* make_reversed_index_sequence 
* integer_sequence_push_front 
* integer_sequence_push_back 
* <a href="https://en.cppreference.com/w/cpp/utility/integer_sequence"><code>std::index&#95;sequence</code></a>

<h3 id="using-make-integer-sequence">
Type Alias <code>thrust::make&#95;integer&#95;sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;std::size_t N&gt;</span>
<span>using <b>make_integer_sequence</b> = std::make&#95;integer&#95;sequence&lt; T, N &gt;;</span></code>
Create a new <code>integer&#95;sequence</code> with elements <code>0, 1, 2, ..., N - 1</code> of type <code>T</code>. 

**See**:
* integer_sequence 
* index_sequence 
* make_reversed_integer_sequence 
* make_index_sequence 
* make_reversed_index_sequence 
* <a href="https://en.cppreference.com/w/cpp/utility/integer_sequence"><code>std::make&#95;integer&#95;sequence</code></a>

<h3 id="using-make-index-sequence">
Type Alias <code>thrust::make&#95;index&#95;sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;std::size_t N&gt;</span>
<span>using <b>make_index_sequence</b> = std::make&#95;index&#95;sequence&lt; N &gt;;</span></code>
Create a new <code>integer&#95;sequence</code> with elements <code>0, 1, 2, ..., N - 1</code> of type <a href="https://en.cppreference.com/w/cpp/types/size_t">std::size_t</a>. 

**See**:
* integer_sequence 
* index_sequence 
* make_integer_sequence 
* make_reversed_integer_sequence 
* make_reversed_index_sequence 
* <a href="https://en.cppreference.com/w/cpp/utility/integer_sequence"><code>std::make&#95;index&#95;sequence</code></a>

<h3 id="using-make-reversed-integer-sequence">
Type Alias <code>thrust::make&#95;reversed&#95;integer&#95;sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;std::size_t N&gt;</span>
<span>using <b>make_reversed_integer_sequence</b> = typename detail::make&#95;reversed&#95;integer&#95;sequence&#95;impl&lt; T, N &gt;::type;</span></code>
Create a new <code>integer&#95;sequence</code> with elements <code>N - 1, N - 2, N - 3, ..., 0</code>. 

**See**:
* integer_sequence 
* index_sequence 
* make_integer_sequence 
* make_index_sequence 
* make_reversed_index_sequence 

<h3 id="using-make-reversed-index-sequence">
Type Alias <code>thrust::make&#95;reversed&#95;index&#95;sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;std::size_t N&gt;</span>
<span>using <b>make_reversed_index_sequence</b> = &lt;a href="{{ site.baseurl }}/api/groups/group&#95;&#95;type&#95;&#95;traits.html#using-make-reversed-integer-sequence"&gt;make&#95;reversed&#95;integer&#95;sequence&lt;/a&gt;&lt; std::size&#95;t, N &gt;;</span></code>
Create a new <code>index&#95;sequence</code> with elements <code>N - 1, N - 2, N - 3, ..., 0</code>. 

**See**:
* integer_sequence 
* index_sequence 
* make_integer_sequence 
* make_reversed_integer_sequence 
* make_reversed_index_sequence 

<h3 id="using-integer-sequence-push-front">
Type Alias <code>thrust::integer&#95;sequence&#95;push&#95;front</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;T Value,</span>
<span>&nbsp;&nbsp;typename Sequence&gt;</span>
<span>using <b>integer_sequence_push_front</b> = typename detail::integer&#95;sequence&#95;push&#95;front&#95;impl&lt; T, Value, Sequence &gt;::type;</span></code>
Add a new element to the front of an <code>integer&#95;sequence</code>. 

**See**:
* integer_sequence 
* index_sequence 
* make_integer_sequence 
* make_index_sequence 

<h3 id="using-integer-sequence-push-back">
Type Alias <code>thrust::integer&#95;sequence&#95;push&#95;back</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;T Value,</span>
<span>&nbsp;&nbsp;typename Sequence&gt;</span>
<span>using <b>integer_sequence_push_back</b> = typename detail::integer&#95;sequence&#95;push&#95;back&#95;impl&lt; T, Value, Sequence &gt;::type;</span></code>
Add a new element to the back of an <code>integer&#95;sequence</code>. 

**See**:
* integer_sequence 
* index_sequence 
* make_integer_sequence 
* make_index_sequence 

<h3 id="using-is-contiguous-iterator">
Type Alias <code>thrust::is&#95;contiguous&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename Iterator&gt;</span>
<span>using <b>is_contiguous_iterator</b> = detail::is&#95;contiguous&#95;iterator&#95;impl&lt; Iterator &gt;;</span></code>
<a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>Iterator</code> satisfies <a href="https://en.cppreference.com/w/cpp/named_req/ContiguousIterator">ContiguousIterator</a>, aka it points to elements that are contiguous in memory, and <code>false&#95;type</code> otherwise. 

**See**:
* is_contiguous_iterator_v 
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1proclaim__contiguous__iterator.html">proclaim_contiguous_iterator</a>
* <a href="{{ site.baseurl }}/api/groups/group__type__traits.html#define-thrust-proclaim-contiguous-iterator">THRUST_PROCLAIM_CONTIGUOUS_ITERATOR</a>

<h3 id="using-is-execution-policy">
Type Alias <code>thrust::is&#95;execution&#95;policy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>is_execution_policy</b> = detail::is&#95;base&#95;of&lt; detail::execution&#95;policy&#95;marker, T &gt;;</span></code>
<a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is an _ExecutionPolicy_ and <code>false&#95;type</code> otherwise. 

<h3 id="using-is-operator-less-function-object">
Type Alias <code>thrust::is&#95;operator&#95;less&#95;function&#95;object</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>is_operator_less_function_object</b> = detail::is&#95;operator&#95;less&#95;function&#95;object&#95;impl&lt; T &gt;;</span></code>
<a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&lt;</code>, and <code>false&#95;type</code> otherwise. 

**See**:
* is_operator_less_function_object_v 
* is_operator_greater_function_object 
* is_operator_less_or_greater_function_object 
* is_operator_plus_function_object 

<h3 id="using-is-operator-greater-function-object">
Type Alias <code>thrust::is&#95;operator&#95;greater&#95;function&#95;object</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>is_operator_greater_function_object</b> = detail::is&#95;operator&#95;greater&#95;function&#95;object&#95;impl&lt; T &gt;;</span></code>
<a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&gt;</code>, and <code>false&#95;type</code> otherwise. 

**See**:
* is_operator_greater_function_object_v 
* is_operator_less_function_object 
* is_operator_less_or_greater_function_object 
* is_operator_plus_function_object 

<h3 id="using-is-operator-less-or-greater-function-object">
Type Alias <code>thrust::is&#95;operator&#95;less&#95;or&#95;greater&#95;function&#95;object</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>is_operator_less_or_greater_function_object</b> = integral&#95;constant&lt; bool, detail::is&#95;operator&#95;less&#95;function&#95;object&#95;impl&lt; T &gt;::value||detail::is&#95;operator&#95;greater&#95;function&#95;object&#95;impl&lt; T &gt;::value &gt;;</span></code>
<a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&lt;</code> or <code>operator&gt;</code>, and <code>false&#95;type</code> otherwise. 

**See**:
* is_operator_less_or_greater_function_object_v 
* is_operator_less_function_object 
* is_operator_greater_function_object 
* is_operator_plus_function_object 

<h3 id="using-is-operator-plus-function-object">
Type Alias <code>thrust::is&#95;operator&#95;plus&#95;function&#95;object</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>is_operator_plus_function_object</b> = detail::is&#95;operator&#95;plus&#95;function&#95;object&#95;impl&lt; T &gt;;</span></code>
<a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">_UnaryTypeTrait_</a> that returns <code>true&#95;type</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/FunctionObject">FunctionObject</a> equivalent to <code>operator+</code>, and <code>false&#95;type</code> otherwise. 

**See**:
* is_operator_plus_function_object_v 
* is_operator_less_function_object 
* is_operator_greater_function_object 
* is_operator_less_or_greater_function_object 

<h3 id="using-conjunction">
Type Alias <code>thrust::conjunction</code>
</h3>

<code class="doxybook">
<span>template &lt;typename... Ts&gt;</span>
<span>using <b>conjunction</b> = std::conjunction&lt; Ts... &gt;;</span></code>
<a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>(... && Ts::value)</code>. 

**See**:
* conjunction_v 
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1conjunction__value.html">conjunction_value</a>
* <a href="https://en.cppreference.com/w/cpp/types/conjunction"><code>std::conjunction</code></a>

<h3 id="using-disjunction">
Type Alias <code>thrust::disjunction</code>
</h3>

<code class="doxybook">
<span>template &lt;typename... Ts&gt;</span>
<span>using <b>disjunction</b> = std::disjunction&lt; Ts... &gt;;</span></code>
<a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>(... || Ts::value)</code>. 

**See**:
* disjunction_v 
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1disjunction__value.html">disjunction_value</a>
* <a href="https://en.cppreference.com/w/cpp/types/disjunction"><code>std::disjunction</code></a>

<h3 id="using-negation">
Type Alias <code>thrust::negation</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>negation</b> = std::negation&lt; T &gt;;</span></code>
<a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral&#95;constant</code></a> whose value is <code>!Ts::value</code>. 

**See**:
* negation_v 
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1negation__value.html">negation_value</a>
* <a href="https://en.cppreference.com/w/cpp/types/negation"><code>std::negation</code></a>

<h3 id="using-remove-cvref-t">
Type Alias <code>thrust::remove&#95;cvref&#95;t</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>remove_cvref_t</b> = typename &lt;a href="{{ site.baseurl }}/api/classes/structthrust&#95;1&#95;1remove&#95;&#95;cvref.html"&gt;remove&#95;cvref&lt;/a&gt;&lt; T &gt;::type;</span></code>
Type alias that removes <a href="https://en.cppreference.com/w/cpp/language/cv">const-volatile qualifiers</a> and <a href="https://en.cppreference.com/w/cpp/language/reference">references</a> from <code>T</code>. Equivalent to <code>remove&#95;cv&#95;t&lt;remove&#95;reference&#95;t&lt;T&gt;&gt;</code>. 

**See**:
* <a href="https://en.cppreference.com/w/cpp/types/remove_cvref">std::remove_cvref</a>
* <a href="https://en.cppreference.com/w/cpp/types/remove_cv">std::remove_cv</a>
* <a href="https://en.cppreference.com/w/cpp/types/remove_cv">std::remove_const</a>
* <a href="https://en.cppreference.com/w/cpp/types/remove_cv">std::remove_volatile</a>
* <a href="https://en.cppreference.com/w/cpp/types/remove_cv">std::remove_reference</a>

<h3 id="using-universal-ptr">
Type Alias <code>thrust::universal&#95;ptr</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>using <b>universal_ptr</b> = thrust::system::&#95;&#95;THRUST&#95;DEVICE&#95;SYSTEM&#95;NAMESPACE::universal&#95;pointer&lt; T &gt;;</span></code>
<code>universal&#95;ptr</code> stores a pointer to an object allocated in memory accessible to both hosts and devices.

Algorithms dispatched with this type of pointer will be dispatched to either host or device, depending on which backend you are using. Explicit policies (<code>thrust::device</code>, etc) can be used to specify where an algorithm should be run.

<code>universal&#95;ptr</code> has pointer semantics: it may be dereferenced safely from both hosts and devices and may be manipulated with pointer arithmetic.

<code>universal&#95;ptr</code> can be created with <code>universal&#95;allocator</code> or by explicitly calling its constructor with a raw pointer.

The raw pointer encapsulated by a <code>universal&#95;ptr</code> may be obtained by either its <code>get</code> method or the <code>raw&#95;pointer&#95;cast</code> free function.

**Note**:
<code>universal&#95;ptr</code> is not a smart pointer; it is the programmer's responsibility to deallocate memory pointed to by <code>universal&#95;ptr</code>.

**See**:
* host_ptr For the documentation of the complete interface which is shared by <code>universal&#95;ptr</code>. 
* raw_pointer_cast 


## Variables

<h3 id="variable-host">
Variable <code>thrust::host</code>
</h3>

<code class="doxybook">
<span>static const detail::host_t <b>host</b>;</span></code>
<code>thrust::host</code> is the default parallel execution policy associated with Thrust's host backend system configured by the <code>THRUST&#95;HOST&#95;SYSTEM</code> macro.

Instead of relying on implicit algorithm dispatch through iterator system tags, users may directly target algorithm dispatch at Thrust's host system by providing <code>thrust::host</code> as an algorithm parameter.

Explicit dispatch can be useful in avoiding the introduction of data copies into containers such as <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">thrust::host&#95;vector</a></code>.

Note that even though <code>thrust::host</code> targets the host CPU, it is a parallel execution policy. That is, the order that an algorithm invokes functors or dereferences iterators is not defined.

The type of <code>thrust::host</code> is implementation-defined.

The following code snippet demonstrates how to use <code>thrust::host</code> to explicitly dispatch an invocation of <code>thrust::for&#95;each</code> to the host backend system:



```cpp
#include <thrust/for_each.h>
#include <thrust/execution_policy.h>
#include <cstdio>

struct printf_functor
{
  __host__ __device__
  void operator()(int x)
  {
    printf("%d\n", x);
  }
};
...
int vec(3);
vec[0] = 0; vec[1] = 1; vec[2] = 2;

thrust::for_each(thrust::host, vec.begin(), vec.end(), printf_functor());

// 0 1 2 is printed to standard output in some unspecified order
```

**See**:
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1host__execution__policy.html">host_execution_policy</a>
* thrust::device 

<h3 id="variable-device">
Variable <code>thrust::device</code>
</h3>

<code class="doxybook">
<span>THRUST_INLINE_CONSTANT detail::device_t <b>device</b>;</span></code>
<code>thrust::device</code> is the default parallel execution policy associated with Thrust's device backend system configured by the <code>THRUST&#95;DEVICE&#95;SYSTEM</code> macro.

Instead of relying on implicit algorithm dispatch through iterator system tags, users may directly target algorithm dispatch at Thrust's device system by providing <code>thrust::device</code> as an algorithm parameter.

Explicit dispatch can be useful in avoiding the introduction of data copies into containers such as <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">thrust::device&#95;vector</a></code> or to avoid wrapping e.g. raw pointers allocated by the CUDA API with types such as <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">thrust::device&#95;ptr</a></code>.

The user must take care to guarantee that the iterators provided to an algorithm are compatible with the device backend system. For example, raw pointers allocated by <code>std::malloc</code> typically cannot be dereferenced by a GPU. For this reason, raw pointers allocated by host APIs should not be mixed with a <code>thrust::device</code> algorithm invocation when the device backend is CUDA.

The type of <code>thrust::device</code> is implementation-defined.

The following code snippet demonstrates how to use <code>thrust::device</code> to explicitly dispatch an invocation of <code>thrust::for&#95;each</code> to the device backend system:



```cpp
#include <thrust/for_each.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
#include <cstdio>

struct printf_functor
{
  __host__ __device__
  void operator()(int x)
  {
    printf("%d\n", x);
  }
};
...
thrust::device_vector<int> vec(3);
vec[0] = 0; vec[1] = 1; vec[2] = 2;

thrust::for_each(thrust::device, vec.begin(), vec.end(), printf_functor());

// 0 1 2 is printed to standard output in some unspecified order
```

**See**:
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1host__execution__policy.html">host_execution_policy</a>
* thrust::device 

<h3 id="variable-new-stream">
Variable <code>thrust::new&#95;stream</code>
</h3>

<code class="doxybook">
<span>THRUST_INLINE_CONSTANT new_stream_t <b>new_stream</b> {};</span></code>
<h3 id="variable-in-place">
Variable <code>thrust::in&#95;place</code>
</h3>

<code class="doxybook">
<span>static constexpr <a href="{{ site.baseurl }}/api/classes/structthrust_1_1in__place__t.html">in_place_t</a> <b>in_place</b> {};</span></code>
A tag to tell optional to construct its value in-place. 

<h3 id="variable-nullopt">
Variable <code>thrust::nullopt</code>
</h3>

<code class="doxybook">
<span>static constexpr <a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a> <b>nullopt</b> {nullopt&#95;t::do&#95;not&#95;use{},
                                   nullopt&#95;t::do&#95;not&#95;use{}};</span></code>
Represents an empty optional \synopsis static constexpr nullopt_t nullopt;. 

_Examples_: 

```cpp
thrust::optional<int> a = thrust::nullopt;
void foo (thrust::optional<int>);
foo(thrust::nullopt); //pass an empty optional
```

<h3 id="variable-is-contiguous-iterator-v">
Variable <code>thrust::is&#95;contiguous&#95;iterator&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;typename Iterator&gt;</span>
<span>constexpr bool <b>is_contiguous_iterator_v</b> = is&#95;contiguous&#95;iterator&lt;Iterator&gt;::value;</span></code>
<code>constexpr bool</code> that is <code>true</code> if <code>Iterator</code> satisfies <a href="https://en.cppreference.com/w/cpp/named_req/ContiguousIterator">ContiguousIterator</a>, aka it points to elements that are contiguous in memory, and <code>false</code> otherwise. 

**See**:
* is_contiguous_iterator 
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1proclaim__contiguous__iterator.html">proclaim_contiguous_iterator</a>
* <a href="{{ site.baseurl }}/api/groups/group__type__traits.html#define-thrust-proclaim-contiguous-iterator">THRUST_PROCLAIM_CONTIGUOUS_ITERATOR</a>

<h3 id="variable-is-execution-policy-v">
Variable <code>thrust::is&#95;execution&#95;policy&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>constexpr bool <b>is_execution_policy_v</b> = is&#95;execution&#95;policy&lt;T&gt;::value;</span></code>
<code>constexpr bool</code> that is <code>true</code> if <code>T</code> is an _ExecutionPolicy_ and <code>false</code> otherwise. 

<h3 id="variable-is-operator-less-function-object-v">
Variable <code>thrust::is&#95;operator&#95;less&#95;function&#95;object&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>constexpr bool <b>is_operator_less_function_object_v</b> = is&#95;operator&#95;less&#95;function&#95;object&lt;T&gt;::value;</span></code>
<code>constexpr bool</code> that is <code>true</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&lt;</code>, and <code>false</code> otherwise. 

**See**:
* is_operator_less_function_object 
* is_operator_greater_function_object 
* is_operator_less_or_greater_function_object 
* is_operator_plus_function_object 

<h3 id="variable-is-operator-greater-function-object-v">
Variable <code>thrust::is&#95;operator&#95;greater&#95;function&#95;object&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>constexpr bool <b>is_operator_greater_function_object_v</b> = is&#95;operator&#95;greater&#95;function&#95;object&lt;T&gt;::value;</span></code>
<code>constexpr bool</code> that is <code>true</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&gt;</code>, and <code>false</code> otherwise. 

**See**:
* is_operator_greater_function_object 
* is_operator_less_function_object 
* is_operator_less_or_greater_function_object 
* is_operator_plus_function_object 

<h3 id="variable-is-operator-less-or-greater-function-object-v">
Variable <code>thrust::is&#95;operator&#95;less&#95;or&#95;greater&#95;function&#95;object&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>constexpr bool <b>is_operator_less_or_greater_function_object_v</b> = is&#95;operator&#95;less&#95;or&#95;greater&#95;function&#95;object&lt;T&gt;::value;</span></code>
<code>constexpr bool</code> that is <code>true</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a> equivalent to <code>operator&lt;</code> or <code>operator&gt;</code>, and <code>false</code> otherwise. 

**See**:
* is_operator_less_or_greater_function_object 
* is_operator_less_function_object 
* is_operator_greater_function_object 
* is_operator_plus_function_object 

<h3 id="variable-is-operator-plus-function-object-v">
Variable <code>thrust::is&#95;operator&#95;plus&#95;function&#95;object&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>constexpr bool <b>is_operator_plus_function_object_v</b> = is&#95;operator&#95;plus&#95;function&#95;object&lt;T&gt;::value;</span></code>
<code>constexpr bool</code> that is <code>true</code> if <code>T</code> is a <a href="https://en.cppreference.com/w/cpp/named_req/FunctionObject">FunctionObject</a> equivalent to <code>operator&lt;</code>, and <code>false</code> otherwise. 

**See**:
* is_operator_plus_function_object 
* is_operator_less_function_object 
* is_operator_greater_function_object 
* is_operator_less_or_greater_function_object 

<h3 id="variable-conjunction-v">
Variable <code>thrust::conjunction&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;typename... Ts&gt;</span>
<span>constexpr bool <b>conjunction_v</b> = conjunction&lt;Ts...&gt;::value;</span></code>
<code>constexpr bool</code> whose value is <code>(... && Ts::value)</code>. 

**See**:
* conjunction 
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1conjunction__value.html">conjunction_value</a>
* <a href="https://en.cppreference.com/w/cpp/types/conjunction"><code>std::conjunction</code></a>

<h3 id="variable-disjunction-v">
Variable <code>thrust::disjunction&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;typename... Ts&gt;</span>
<span>constexpr bool <b>disjunction_v</b> = disjunction&lt;Ts...&gt;::value;</span></code>
<code>constexpr bool</code> whose value is <code>(... || Ts::value)</code>. 

**See**:
* disjunction 
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1disjunction__value.html">disjunction_value</a>
* <a href="https://en.cppreference.com/w/cpp/types/disjunction"><code>std::disjunction</code></a>

<h3 id="variable-negation-v">
Variable <code>thrust::negation&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>constexpr bool <b>negation_v</b> = negation&lt;T&gt;::value;</span></code>
<code>constexpr bool</code> whose value is <code>!Ts::value</code>. 

**See**:
* negation 
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1negation__value.html">negation_value</a>
* <a href="https://en.cppreference.com/w/cpp/types/negation"><code>std::negation</code></a>

<h3 id="variable-conjunction-value-v">
Variable <code>thrust::conjunction&#95;value&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;bool... Bs&gt;</span>
<span>constexpr bool <b>conjunction_value_v</b> = conjunction&#95;value&lt;Bs...&gt;::value;</span></code>
<code>constexpr bool</code> whose value is <code>(... && Bs)</code>. 

**See**:
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1conjunction__value.html">conjunction_value</a>
* conjunction 
* <a href="https://en.cppreference.com/w/cpp/types/conjunction"><code>std::conjunction</code></a>

<h3 id="variable-disjunction-value-v">
Variable <code>thrust::disjunction&#95;value&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;bool... Bs&gt;</span>
<span>constexpr bool <b>disjunction_value_v</b> = disjunction&#95;value&lt;Bs...&gt;::value;</span></code>
<code>constexpr bool</code> whose value is <code>(... || Bs)</code>. 

**See**:
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1disjunction__value.html">disjunction_value</a>
* disjunction 
* <a href="https://en.cppreference.com/w/cpp/types/disjunction"><code>std::disjunction</code></a>

<h3 id="variable-negation-value-v">
Variable <code>thrust::negation&#95;value&#95;v</code>
</h3>

<code class="doxybook">
<span>template &lt;bool B&gt;</span>
<span>constexpr bool <b>negation_value_v</b> = negation&#95;value&lt;B&gt;::value;</span></code>
<code>constexpr bool</code> whose value is <code>!Ts::value</code>. 

**See**:
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1negation__value.html">negation_value</a>
* negation 
* <a href="https://en.cppreference.com/w/cpp/types/negation"><code>std::negation</code></a>


## Functions

<h3 id="function-addressof">
Function <code>thrust::addressof</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T * </span><span><b>addressof</b>(T & arg);</span></code>
Obtains the actual address of the object or function arg, even in presence of overloaded operator&. 

<h3 id="function-adjacent-difference">
Function <code>thrust::adjacent&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>adjacent_difference</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>adjacent&#95;difference</code> calculates the differences of adjacent elements in the range <code>[first, last)</code>. That is, <code>&#42;first</code> is assigned to <code>&#42;result</code>, and, for each iterator <code>i</code> in the range <code>[first + 1, last)</code>, the difference of <code>&#42;i</code> and <code>&#42;(i - 1)</code> is assigned to <code>&#42;(result + (i - first))</code>.

This version of <code>adjacent&#95;difference</code> uses <code>operator-</code> to calculate differences.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>adjacent&#95;difference</code> to compute the difference between adjacent elements of a range using the <code>thrust::device</code> execution policy:



```cpp
#include <thrust/adjacent_difference.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
int h_data[8] = {1, 2, 1, 2, 1, 2, 1, 2};
thrust::device_vector<int> d_data(h_data, h_data + 8);
thrust::device_vector<int> d_result(8);

thrust::adjacent_difference(thrust::device, d_data.begin(), d_data.end(), d_result.begin());

// d_result is now [1, 1, -1, 1, -1, 1, -1, 1]
```

**Remark**:
Note that <code>result</code> is permitted to be the same iterator as <code>first</code>. This is useful for computing differences "in place".

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>x</code> and <code>y</code> are objects of <code>InputIterator's</code><code>value&#95;type</code>, then <code>x</code> - <code>is</code> defined, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>, and the return type of <code>x - y</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`result`** The beginning of the output range. 

**Returns**:
The iterator <code>result + (last - first)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_difference">https://en.cppreference.com/w/cpp/algorithm/adjacent_difference</a>
* inclusive_scan 

<h3 id="function-adjacent-difference">
Function <code>thrust::adjacent&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>adjacent_difference</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span></code>
<code>adjacent&#95;difference</code> calculates the differences of adjacent elements in the range <code>[first, last)</code>. That is, <code>&#42;first</code> is assigned to <code>&#42;result</code>, and, for each iterator <code>i</code> in the range <code>[first + 1, last)</code>, <code>binary&#95;op(&#42;i, &#42;(i - 1))</code> is assigned to <code>&#42;(result + (i - first))</code>.

This version of <code>adjacent&#95;difference</code> uses the binary function <code>binary&#95;op</code> to calculate differences.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>adjacent&#95;difference</code> to compute the sum between adjacent elements of a range using the <code>thrust::device</code> execution policy:



```cpp
#include <thrust/adjacent_difference.h>
#include <thrust/functional.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
int h_data[8] = {1, 2, 1, 2, 1, 2, 1, 2};
thrust::device_vector<int> d_data(h_data, h_data + 8);
thrust::device_vector<int> d_result(8);

thrust::adjacent_difference(thrust::device, d_data.begin(), d_data.end(), d_result.begin(), thrust::plus<int>());

// d_result is now [1, 3, 3, 3, 3, 3, 3, 3]
```

**Remark**:
Note that <code>result</code> is permitted to be the same iterator as <code>first</code>. This is useful for computing differences "in place".

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`BinaryFunction's`** <code>result&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`result`** The beginning of the output range. 
* **`binary_op`** The binary function used to compute differences. 

**Returns**:
The iterator <code>result + (last - first)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_difference">https://en.cppreference.com/w/cpp/algorithm/adjacent_difference</a>
* inclusive_scan 

<h3 id="function-adjacent-difference">
Function <code>thrust::adjacent&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>adjacent_difference</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>adjacent&#95;difference</code> calculates the differences of adjacent elements in the range <code>[first, last)</code>. That is, <code>&#42;first</code> is assigned to <code>&#42;result</code>, and, for each iterator <code>i</code> in the range <code>[first + 1, last)</code>, the difference of <code>&#42;i</code> and <code>&#42;(i - 1)</code> is assigned to <code>&#42;(result + (i - first))</code>.

This version of <code>adjacent&#95;difference</code> uses <code>operator-</code> to calculate differences.


The following code snippet demonstrates how to use <code>adjacent&#95;difference</code> to compute the difference between adjacent elements of a range.



```cpp
#include <thrust/adjacent_difference.h>
#include <thrust/device_vector.h>
...
int h_data[8] = {1, 2, 1, 2, 1, 2, 1, 2};
thrust::device_vector<int> d_data(h_data, h_data + 8);
thrust::device_vector<int> d_result(8);

thrust::adjacent_difference(d_data.begin(), d_data.end(), d_result.begin());

// d_result is now [1, 1, -1, 1, -1, 1, -1, 1]
```

**Remark**:
Note that <code>result</code> is permitted to be the same iterator as <code>first</code>. This is useful for computing differences "in place".

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>x</code> and <code>y</code> are objects of <code>InputIterator's</code><code>value&#95;type</code>, then <code>x</code> - <code>is</code> defined, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>, and the return type of <code>x - y</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`result`** The beginning of the output range. 

**Returns**:
The iterator <code>result + (last - first)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_difference">https://en.cppreference.com/w/cpp/algorithm/adjacent_difference</a>
* inclusive_scan 

<h3 id="function-adjacent-difference">
Function <code>thrust::adjacent&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>OutputIterator </span><span><b>adjacent_difference</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span></code>
<code>adjacent&#95;difference</code> calculates the differences of adjacent elements in the range <code>[first, last)</code>. That is, <code>&#42;first</code> is assigned to <code>&#42;result</code>, and, for each iterator <code>i</code> in the range <code>[first + 1, last)</code>, <code>binary&#95;op(&#42;i, &#42;(i - 1))</code> is assigned to <code>&#42;(result + (i - first))</code>.

This version of <code>adjacent&#95;difference</code> uses the binary function <code>binary&#95;op</code> to calculate differences.


The following code snippet demonstrates how to use <code>adjacent&#95;difference</code> to compute the sum between adjacent elements of a range.



```cpp
#include <thrust/adjacent_difference.h>
#include <thrust/functional.h>
#include <thrust/device_vector.h>
...
int h_data[8] = {1, 2, 1, 2, 1, 2, 1, 2};
thrust::device_vector<int> d_data(h_data, h_data + 8);
thrust::device_vector<int> d_result(8);

thrust::adjacent_difference(d_data.begin(), d_data.end(), d_result.begin(), thrust::plus<int>());

// d_result is now [1, 3, 3, 3, 3, 3, 3, 3]
```

**Remark**:
Note that <code>result</code> is permitted to be the same iterator as <code>first</code>. This is useful for computing differences "in place".

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`BinaryFunction's`** <code>result&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>.

**Function Parameters**:
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`result`** The beginning of the output range. 
* **`binary_op`** The binary function used to compute differences. 

**Returns**:
The iterator <code>result + (last - first)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_difference">https://en.cppreference.com/w/cpp/algorithm/adjacent_difference</a>
* inclusive_scan 

<h3 id="function-advance">
Function <code>thrust::advance</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Distance&gt;</span>
<span>__host__ __device__ void </span><span><b>advance</b>(InputIterator & i,</span>
<span>&nbsp;&nbsp;Distance n);</span></code>
<code>advance(i, n)</code> increments the iterator <code>i</code> by the distance <code>n</code>. If <code>n &gt; 0</code> it is equivalent to executing <code>++i</code><code>n</code> times, and if <code>n &lt; 0</code> it is equivalent to executing <code>&ndash;i</code><code>n</code> times. If <code>n == 0</code>, the call has no effect.


The following code snippet demonstrates how to use <code>advance</code> to increment an iterator a given number of times.



```cpp
#include <thrust/advance.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> vec(13);
thrust::device_vector<int>::iterator iter = vec.begin();

thrust::advance(iter, 7);

// iter - vec.begin() == 7
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`Distance`** is an integral type that is convertible to <code>InputIterator's</code> distance type.

**Function Parameters**:
* **`i`** The iterator to be advanced. 
* **`n`** The distance by which to advance the iterator.

**Preconditions**:
<code>n</code> shall be negative only for bidirectional and random access iterators.

**See**:
<a href="https://en.cppreference.com/w/cpp/iterator/advance">https://en.cppreference.com/w/cpp/iterator/advance</a>

<h3 id="function-make-tagged-deleter">
Function <code>thrust::make&#95;tagged&#95;deleter</code>
</h3>

<code class="doxybook">
<span>template &lt;typename Pointer,</span>
<span>&nbsp;&nbsp;typename Lambda&gt;</span>
<span>__host__ __device__ tagged_deleter< Pointer, Lambda > </span><span><b>make_tagged_deleter</b>(Lambda && l);</span></code>
<h3 id="function-allocate-unique">
Function <code>thrust::allocate&#95;unique</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator,</span>
<span>&nbsp;&nbsp;typename... Args&gt;</span>
<span>__host__ std::unique_ptr< T, allocator_delete< T, typename detail::allocator_traits< typename std::remove_cv< typename std::remove_reference< Allocator >::type >::type >::template rebind_traits< T >::allocator_type > > </span><span><b>allocate_unique</b>(Allocator const & alloc,</span>
<span>&nbsp;&nbsp;Args &&... args);</span></code>
<h3 id="function-uninitialized-allocate-unique">
Function <code>thrust::uninitialized&#95;allocate&#95;unique</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator&gt;</span>
<span>__host__ std::unique_ptr< T, uninitialized_allocator_delete< T, typename detail::allocator_traits< typename std::remove_cv< typename std::remove_reference< Allocator >::type >::type >::template rebind_traits< T >::allocator_type > > </span><span><b>uninitialized_allocate_unique</b>(Allocator const & alloc);</span></code>
<h3 id="function-allocate-unique-n">
Function <code>thrust::allocate&#95;unique&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename... Args&gt;</span>
<span>__host__ std::unique_ptr< T[], array_allocator_delete< T, typename detail::allocator_traits< typename std::remove_cv< typename std::remove_reference< Allocator >::type >::type >::template rebind_traits< T >::allocator_type > > </span><span><b>allocate_unique_n</b>(Allocator const & alloc,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;Args &&... args);</span></code>
<h3 id="function-uninitialized-allocate-unique-n">
Function <code>thrust::uninitialized&#95;allocate&#95;unique&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Allocator,</span>
<span>&nbsp;&nbsp;typename Size&gt;</span>
<span>__host__ std::unique_ptr< T[], uninitialized_array_allocator_delete< T, typename detail::allocator_traits< typename std::remove_cv< typename std::remove_reference< Allocator >::type >::type >::template rebind_traits< T >::allocator_type > > </span><span><b>uninitialized_allocate_unique_n</b>(Allocator const & alloc,</span>
<span>&nbsp;&nbsp;Size n);</span></code>
<h3 id="function-lower-bound">
Function <code>thrust::lower&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename LessThanComparable&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>lower_bound</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span></code>
<code>lower&#95;bound</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. Specifically, it returns the first position where value could be inserted without violating the ordering. This version of <code>lower&#95;bound</code> uses <code>operator&lt;</code> for comparison and returns the furthermost iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, i)</code>, <code>&#42;j &lt; value</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>lower&#95;bound</code> to search for values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::lower_bound(thrust::device, input.begin(), input.end(), 0); // returns input.begin()
thrust::lower_bound(thrust::device, input.begin(), input.end(), 1); // returns input.begin() + 1
thrust::lower_bound(thrust::device, input.begin(), input.end(), 2); // returns input.begin() + 1
thrust::lower_bound(thrust::device, input.begin(), input.end(), 3); // returns input.begin() + 2
thrust::lower_bound(thrust::device, input.begin(), input.end(), 8); // returns input.begin() + 4
thrust::lower_bound(thrust::device, input.begin(), input.end(), 9); // returns input.end()
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`LessThanComparable`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 

**Returns**:
The furthermost iterator <code>i</code>, such that <code>&#42;i &lt; value</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-lower-bound">
Function <code>thrust::lower&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class LessThanComparable&gt;</span>
<span>ForwardIterator </span><span><b>lower_bound</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span></code>
<code>lower&#95;bound</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. Specifically, it returns the first position where value could be inserted without violating the ordering. This version of <code>lower&#95;bound</code> uses <code>operator&lt;</code> for comparison and returns the furthermost iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, i)</code>, <code>&#42;j &lt; value</code>.


The following code snippet demonstrates how to use <code>lower&#95;bound</code> to search for values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::lower_bound(input.begin(), input.end(), 0); // returns input.begin()
thrust::lower_bound(input.begin(), input.end(), 1); // returns input.begin() + 1
thrust::lower_bound(input.begin(), input.end(), 2); // returns input.begin() + 1
thrust::lower_bound(input.begin(), input.end(), 3); // returns input.begin() + 2
thrust::lower_bound(input.begin(), input.end(), 8); // returns input.begin() + 4
thrust::lower_bound(input.begin(), input.end(), 9); // returns input.end()
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`LessThanComparable`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 

**Returns**:
The furthermost iterator <code>i</code>, such that <code>&#42;i &lt; value</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-lower-bound">
Function <code>thrust::lower&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>lower_bound</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>lower&#95;bound</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. Specifically, it returns the first position where value could be inserted without violating the ordering. This version of <code>lower&#95;bound</code> uses function object <code>comp</code> for comparison and returns the furthermost iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, i)</code>, <code>comp(&#42;j, value)</code> is <code>true</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>lower&#95;bound</code> to search for values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::lower_bound(input.begin(), input.end(), 0, thrust::less<int>()); // returns input.begin()
thrust::lower_bound(input.begin(), input.end(), 1, thrust::less<int>()); // returns input.begin() + 1
thrust::lower_bound(input.begin(), input.end(), 2, thrust::less<int>()); // returns input.begin() + 1
thrust::lower_bound(input.begin(), input.end(), 3, thrust::less<int>()); // returns input.begin() + 2
thrust::lower_bound(input.begin(), input.end(), 8, thrust::less<int>()); // returns input.begin() + 4
thrust::lower_bound(input.begin(), input.end(), 9, thrust::less<int>()); // returns input.end()
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`T`** is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 
* **`comp`** The comparison operator. 

**Returns**:
The furthermost iterator <code>i</code>, such that <code>comp(&#42;i, value)</code> is <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-lower-bound">
Function <code>thrust::lower&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class T,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>ForwardIterator </span><span><b>lower_bound</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>lower&#95;bound</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. Specifically, it returns the first position where value could be inserted without violating the ordering. This version of <code>lower&#95;bound</code> uses function object <code>comp</code> for comparison and returns the furthermost iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, i)</code>, <code>comp(&#42;j, value)</code> is <code>true</code>.


The following code snippet demonstrates how to use <code>lower&#95;bound</code> to search for values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::lower_bound(input.begin(), input.end(), 0, thrust::less<int>()); // returns input.begin()
thrust::lower_bound(input.begin(), input.end(), 1, thrust::less<int>()); // returns input.begin() + 1
thrust::lower_bound(input.begin(), input.end(), 2, thrust::less<int>()); // returns input.begin() + 1
thrust::lower_bound(input.begin(), input.end(), 3, thrust::less<int>()); // returns input.begin() + 2
thrust::lower_bound(input.begin(), input.end(), 8, thrust::less<int>()); // returns input.begin() + 4
thrust::lower_bound(input.begin(), input.end(), 9, thrust::less<int>()); // returns input.end()
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`T`** is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 
* **`comp`** The comparison operator. 

**Returns**:
The furthermost iterator <code>i</code>, such that <code>comp(&#42;i, value)</code> is <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-upper-bound">
Function <code>thrust::upper&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename LessThanComparable&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>upper_bound</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span></code>
<code>upper&#95;bound</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. Specifically, it returns the last position where value could be inserted without violating the ordering. This version of <code>upper&#95;bound</code> uses <code>operator&lt;</code> for comparison and returns the furthermost iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, i)</code>, <code>value &lt; &#42;j</code> is <code>false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>upper&#95;bound</code> to search for values in a ordered range using the <code>thrust::device</code> execution policy for parallelism:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::upper_bound(thrust::device, input.begin(), input.end(), 0); // returns input.begin() + 1
thrust::upper_bound(thrust::device, input.begin(), input.end(), 1); // returns input.begin() + 1
thrust::upper_bound(thrust::device, input.begin(), input.end(), 2); // returns input.begin() + 2
thrust::upper_bound(thrust::device, input.begin(), input.end(), 3); // returns input.begin() + 2
thrust::upper_bound(thrust::device, input.begin(), input.end(), 8); // returns input.end()
thrust::upper_bound(thrust::device, input.begin(), input.end(), 9); // returns input.end()
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`LessThanComparable`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 

**Returns**:
The furthermost iterator <code>i</code>, such that <code>value &lt; &#42;i</code> is <code>false</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound</a>
* <code>lower&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-upper-bound">
Function <code>thrust::upper&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class LessThanComparable&gt;</span>
<span>ForwardIterator </span><span><b>upper_bound</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span></code>
<code>upper&#95;bound</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. Specifically, it returns the last position where value could be inserted without violating the ordering. This version of <code>upper&#95;bound</code> uses <code>operator&lt;</code> for comparison and returns the furthermost iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, i)</code>, <code>value &lt; &#42;j</code> is <code>false</code>.


The following code snippet demonstrates how to use <code>upper&#95;bound</code> to search for values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::upper_bound(input.begin(), input.end(), 0); // returns input.begin() + 1
thrust::upper_bound(input.begin(), input.end(), 1); // returns input.begin() + 1
thrust::upper_bound(input.begin(), input.end(), 2); // returns input.begin() + 2
thrust::upper_bound(input.begin(), input.end(), 3); // returns input.begin() + 2
thrust::upper_bound(input.begin(), input.end(), 8); // returns input.end()
thrust::upper_bound(input.begin(), input.end(), 9); // returns input.end()
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`LessThanComparable`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 

**Returns**:
The furthermost iterator <code>i</code>, such that <code>value &lt; &#42;i</code> is <code>false</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound</a>
* <code>lower&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-upper-bound">
Function <code>thrust::upper&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>upper_bound</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>upper&#95;bound</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. Specifically, it returns the last position where value could be inserted without violating the ordering. This version of <code>upper&#95;bound</code> uses function object <code>comp</code> for comparison and returns the furthermost iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, i)</code>, <code>comp(value, &#42;j)</code> is <code>false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>upper&#95;bound</code> to search for values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::upper_bound(thrust::device, input.begin(), input.end(), 0, thrust::less<int>()); // returns input.begin() + 1
thrust::upper_bound(thrust::device, input.begin(), input.end(), 1, thrust::less<int>()); // returns input.begin() + 1
thrust::upper_bound(thrust::device, input.begin(), input.end(), 2, thrust::less<int>()); // returns input.begin() + 2
thrust::upper_bound(thrust::device, input.begin(), input.end(), 3, thrust::less<int>()); // returns input.begin() + 2
thrust::upper_bound(thrust::device, input.begin(), input.end(), 8, thrust::less<int>()); // returns input.end()
thrust::upper_bound(thrust::device, input.begin(), input.end(), 9, thrust::less<int>()); // returns input.end()
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`T`** is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 
* **`comp`** The comparison operator. 

**Returns**:
The furthermost iterator <code>i</code>, such that <code>comp(value, &#42;i)</code> is <code>false</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound</a>
* <code>lower&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-upper-bound">
Function <code>thrust::upper&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class T,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>ForwardIterator </span><span><b>upper_bound</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>upper&#95;bound</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. Specifically, it returns the last position where value could be inserted without violating the ordering. This version of <code>upper&#95;bound</code> uses function object <code>comp</code> for comparison and returns the furthermost iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, i)</code>, <code>comp(value, &#42;j)</code> is <code>false</code>.


The following code snippet demonstrates how to use <code>upper&#95;bound</code> to search for values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::upper_bound(input.begin(), input.end(), 0, thrust::less<int>()); // returns input.begin() + 1
thrust::upper_bound(input.begin(), input.end(), 1, thrust::less<int>()); // returns input.begin() + 1
thrust::upper_bound(input.begin(), input.end(), 2, thrust::less<int>()); // returns input.begin() + 2
thrust::upper_bound(input.begin(), input.end(), 3, thrust::less<int>()); // returns input.begin() + 2
thrust::upper_bound(input.begin(), input.end(), 8, thrust::less<int>()); // returns input.end()
thrust::upper_bound(input.begin(), input.end(), 9, thrust::less<int>()); // returns input.end()
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`T`** is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 
* **`comp`** The comparison operator. 

**Returns**:
The furthermost iterator <code>i</code>, such that <code>comp(value, &#42;i)</code> is <code>false</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound</a>
* <code>lower&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-binary-search">
Function <code>thrust::binary&#95;search</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename LessThanComparable&gt;</span>
<span>__host__ __device__ bool </span><span><b>binary_search</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span></code>
<code>binary&#95;search</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. It returns <code>true</code> if an element that is equivalent to <code>value</code> is present in <code>[first, last)</code> and <code>false</code> if no such element exists. Specifically, this version returns <code>true</code> if and only if there exists an iterator <code>i</code> in <code>[first, last)</code> such that <code>&#42;i &lt; value</code> and <code>value &lt; &#42;i</code> are both <code>false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>binary&#95;search</code> to search for values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::binary_search(thrust::device, input.begin(), input.end(), 0); // returns true
thrust::binary_search(thrust::device, input.begin(), input.end(), 1); // returns false
thrust::binary_search(thrust::device, input.begin(), input.end(), 2); // returns true
thrust::binary_search(thrust::device, input.begin(), input.end(), 3); // returns false
thrust::binary_search(thrust::device, input.begin(), input.end(), 8); // returns true
thrust::binary_search(thrust::device, input.begin(), input.end(), 9); // returns false
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`LessThanComparable`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 

**Returns**:
<code>true</code> if an equivalent element exists in <code>[first, last)</code>, otherwise <code>false</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>

<h3 id="function-binary-search">
Function <code>thrust::binary&#95;search</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class LessThanComparable&gt;</span>
<span>bool </span><span><b>binary_search</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span></code>
<code>binary&#95;search</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. It returns <code>true</code> if an element that is equivalent to <code>value</code> is present in <code>[first, last)</code> and <code>false</code> if no such element exists. Specifically, this version returns <code>true</code> if and only if there exists an iterator <code>i</code> in <code>[first, last)</code> such that <code>&#42;i &lt; value</code> and <code>value &lt; &#42;i</code> are both <code>false</code>.


The following code snippet demonstrates how to use <code>binary&#95;search</code> to search for values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::binary_search(input.begin(), input.end(), 0); // returns true
thrust::binary_search(input.begin(), input.end(), 1); // returns false
thrust::binary_search(input.begin(), input.end(), 2); // returns true
thrust::binary_search(input.begin(), input.end(), 3); // returns false
thrust::binary_search(input.begin(), input.end(), 8); // returns true
thrust::binary_search(input.begin(), input.end(), 9); // returns false
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`LessThanComparable`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 

**Returns**:
<code>true</code> if an equivalent element exists in <code>[first, last)</code>, otherwise <code>false</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>

<h3 id="function-binary-search">
Function <code>thrust::binary&#95;search</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ bool </span><span><b>binary_search</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>binary&#95;search</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. It returns <code>true</code> if an element that is equivalent to <code>value</code> is present in <code>[first, last)</code> and <code>false</code> if no such element exists. Specifically, this version returns <code>true</code> if and only if there exists an iterator <code>i</code> in <code>[first, last)</code> such that <code>comp(&#42;i, value)</code> and <code>comp(value, &#42;i)</code> are both <code>false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>binary&#95;search</code> to search for values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::binary_search(thrust::device, input.begin(), input.end(), 0, thrust::less<int>()); // returns true
thrust::binary_search(thrust::device, input.begin(), input.end(), 1, thrust::less<int>()); // returns false
thrust::binary_search(thrust::device, input.begin(), input.end(), 2, thrust::less<int>()); // returns true
thrust::binary_search(thrust::device, input.begin(), input.end(), 3, thrust::less<int>()); // returns false
thrust::binary_search(thrust::device, input.begin(), input.end(), 8, thrust::less<int>()); // returns true
thrust::binary_search(thrust::device, input.begin(), input.end(), 9, thrust::less<int>()); // returns false
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`T`** is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 
* **`comp`** The comparison operator. 

**Returns**:
<code>true</code> if an equivalent element exists in <code>[first, last)</code>, otherwise <code>false</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>

<h3 id="function-binary-search">
Function <code>thrust::binary&#95;search</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class T,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>bool </span><span><b>binary_search</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>binary&#95;search</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. It returns <code>true</code> if an element that is equivalent to <code>value</code> is present in <code>[first, last)</code> and <code>false</code> if no such element exists. Specifically, this version returns <code>true</code> if and only if there exists an iterator <code>i</code> in <code>[first, last)</code> such that <code>comp(&#42;i, value)</code> and <code>comp(value, &#42;i)</code> are both <code>false</code>.


The following code snippet demonstrates how to use <code>binary&#95;search</code> to search for values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::binary_search(input.begin(), input.end(), 0, thrust::less<int>()); // returns true
thrust::binary_search(input.begin(), input.end(), 1, thrust::less<int>()); // returns false
thrust::binary_search(input.begin(), input.end(), 2, thrust::less<int>()); // returns true
thrust::binary_search(input.begin(), input.end(), 3, thrust::less<int>()); // returns false
thrust::binary_search(input.begin(), input.end(), 8, thrust::less<int>()); // returns true
thrust::binary_search(input.begin(), input.end(), 9, thrust::less<int>()); // returns false
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`T`** is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 
* **`comp`** The comparison operator. 

**Returns**:
<code>true</code> if an equivalent element exists in <code>[first, last)</code>, otherwise <code>false</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>

<h3 id="function-equal-range">
Function <code>thrust::equal&#95;range</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename LessThanComparable&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b>equal_range</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span></code>
<code>equal&#95;range</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. The value returned by <code>equal&#95;range</code> is essentially a combination of the values returned by <code>lower&#95;bound</code> and <code>upper&#95;bound:</code> it returns a <code>pair</code> of iterators <code>i</code> and <code>j</code> such that <code>i</code> is the first position where value could be inserted without violating the ordering and <code>j</code> is the last position where value could be inserted without violating the ordering. It follows that every element in the range <code>[i, j)</code> is equivalent to value, and that <code>[i, j)</code> is the largest subrange of <code>[first, last)</code> that has this property.

This version of <code>equal&#95;range</code> returns a <code>pair</code> of iterators <code>[i, j)</code>, where <code>i</code> is the furthermost iterator in <code>[first, last)</code> such that, for every iterator <code>k</code> in <code>[first, i)</code>, <code>&#42;k &lt; value</code>. <code>j</code> is the furthermost iterator in <code>[first, last)</code> such that, for every iterator <code>k</code> in <code>[first, j)</code>, <code>value &lt; &#42;k</code> is <code>false</code>. For every iterator <code>k</code> in <code>[i, j)</code>, neither <code>value &lt; &#42;k</code> nor <code>&#42;k &lt; value</code> is <code>true</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>equal&#95;range</code> to search for values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::equal_range(thrust::device, input.begin(), input.end(), 0); // returns [input.begin(), input.begin() + 1)
thrust::equal_range(thrust::device, input.begin(), input.end(), 1); // returns [input.begin() + 1, input.begin() + 1)
thrust::equal_range(thrust::device, input.begin(), input.end(), 2); // returns [input.begin() + 1, input.begin() + 2)
thrust::equal_range(thrust::device, input.begin(), input.end(), 3); // returns [input.begin() + 2, input.begin() + 2)
thrust::equal_range(thrust::device, input.begin(), input.end(), 8); // returns [input.begin() + 4, input.end)
thrust::equal_range(thrust::device, input.begin(), input.end(), 9); // returns [input.end(), input.end)
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`LessThanComparable`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 

**Returns**:
A <code>pair</code> of iterators <code>[i, j)</code> that define the range of equivalent elements.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">https://en.cppreference.com/w/cpp/algorithm/equal_range</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-equal-range">
Function <code>thrust::equal&#95;range</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class LessThanComparable&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b>equal_range</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const LessThanComparable & value);</span></code>
<code>equal&#95;range</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. The value returned by <code>equal&#95;range</code> is essentially a combination of the values returned by <code>lower&#95;bound</code> and <code>upper&#95;bound:</code> it returns a <code>pair</code> of iterators <code>i</code> and <code>j</code> such that <code>i</code> is the first position where value could be inserted without violating the ordering and <code>j</code> is the last position where value could be inserted without violating the ordering. It follows that every element in the range <code>[i, j)</code> is equivalent to value, and that <code>[i, j)</code> is the largest subrange of <code>[first, last)</code> that has this property.

This version of <code>equal&#95;range</code> returns a <code>pair</code> of iterators <code>[i, j)</code>, where <code>i</code> is the furthermost iterator in <code>[first, last)</code> such that, for every iterator <code>k</code> in <code>[first, i)</code>, <code>&#42;k &lt; value</code>. <code>j</code> is the furthermost iterator in <code>[first, last)</code> such that, for every iterator <code>k</code> in <code>[first, j)</code>, <code>value &lt; &#42;k</code> is <code>false</code>. For every iterator <code>k</code> in <code>[i, j)</code>, neither <code>value &lt; &#42;k</code> nor <code>&#42;k &lt; value</code> is <code>true</code>.


The following code snippet demonstrates how to use <code>equal&#95;range</code> to search for values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::equal_range(input.begin(), input.end(), 0); // returns [input.begin(), input.begin() + 1)
thrust::equal_range(input.begin(), input.end(), 1); // returns [input.begin() + 1, input.begin() + 1)
thrust::equal_range(input.begin(), input.end(), 2); // returns [input.begin() + 1, input.begin() + 2)
thrust::equal_range(input.begin(), input.end(), 3); // returns [input.begin() + 2, input.begin() + 2)
thrust::equal_range(input.begin(), input.end(), 8); // returns [input.begin() + 4, input.end)
thrust::equal_range(input.begin(), input.end(), 9); // returns [input.end(), input.end)
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`LessThanComparable`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 

**Returns**:
A <code>pair</code> of iterators <code>[i, j)</code> that define the range of equivalent elements.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">https://en.cppreference.com/w/cpp/algorithm/equal_range</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-equal-range">
Function <code>thrust::equal&#95;range</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b>equal_range</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>equal&#95;range</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. The value returned by <code>equal&#95;range</code> is essentially a combination of the values returned by <code>lower&#95;bound</code> and <code>upper&#95;bound:</code> it returns a <code>pair</code> of iterators <code>i</code> and <code>j</code> such that <code>i</code> is the first position where value could be inserted without violating the ordering and <code>j</code> is the last position where value could be inserted without violating the ordering. It follows that every element in the range <code>[i, j)</code> is equivalent to value, and that <code>[i, j)</code> is the largest subrange of <code>[first, last)</code> that has this property.

This version of <code>equal&#95;range</code> returns a <code>pair</code> of iterators <code>[i, j)</code>. <code>i</code> is the furthermost iterator in <code>[first, last)</code> such that, for every iterator <code>k</code> in <code>[first, i)</code>, <code>comp(&#42;k, value)</code> is <code>true</code>. <code>j</code> is the furthermost iterator in <code>[first, last)</code> such that, for every iterator <code>k</code> in <code>[first, last)</code>, <code>comp(value, &#42;k)</code> is <code>false</code>. For every iterator <code>k</code> in <code>[i, j)</code>, neither <code>comp(value, &#42;k)</code> nor <code>comp(&#42;k, value)</code> is <code>true</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>equal&#95;range</code> to search for values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::equal_range(thrust::device, input.begin(), input.end(), 0, thrust::less<int>()); // returns [input.begin(), input.begin() + 1)
thrust::equal_range(thrust::device, input.begin(), input.end(), 1, thrust::less<int>()); // returns [input.begin() + 1, input.begin() + 1)
thrust::equal_range(thrust::device, input.begin(), input.end(), 2, thrust::less<int>()); // returns [input.begin() + 1, input.begin() + 2)
thrust::equal_range(thrust::device, input.begin(), input.end(), 3, thrust::less<int>()); // returns [input.begin() + 2, input.begin() + 2)
thrust::equal_range(thrust::device, input.begin(), input.end(), 8, thrust::less<int>()); // returns [input.begin() + 4, input.end)
thrust::equal_range(thrust::device, input.begin(), input.end(), 9, thrust::less<int>()); // returns [input.end(), input.end)
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`T`** is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 
* **`comp`** The comparison operator. 

**Returns**:
A <code>pair</code> of iterators <code>[i, j)</code> that define the range of equivalent elements.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">https://en.cppreference.com/w/cpp/algorithm/equal_range</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-equal-range">
Function <code>thrust::equal&#95;range</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class T,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b>equal_range</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>equal&#95;range</code> is a version of binary search: it attempts to find the element value in an ordered range <code>[first, last)</code>. The value returned by <code>equal&#95;range</code> is essentially a combination of the values returned by <code>lower&#95;bound</code> and <code>upper&#95;bound:</code> it returns a <code>pair</code> of iterators <code>i</code> and <code>j</code> such that <code>i</code> is the first position where value could be inserted without violating the ordering and <code>j</code> is the last position where value could be inserted without violating the ordering. It follows that every element in the range <code>[i, j)</code> is equivalent to value, and that <code>[i, j)</code> is the largest subrange of <code>[first, last)</code> that has this property.

This version of <code>equal&#95;range</code> returns a <code>pair</code> of iterators <code>[i, j)</code>. <code>i</code> is the furthermost iterator in <code>[first, last)</code> such that, for every iterator <code>k</code> in <code>[first, i)</code>, <code>comp(&#42;k, value)</code> is <code>true</code>. <code>j</code> is the furthermost iterator in <code>[first, last)</code> such that, for every iterator <code>k</code> in <code>[first, last)</code>, <code>comp(value, &#42;k)</code> is <code>false</code>. For every iterator <code>k</code> in <code>[i, j)</code>, neither <code>comp(value, &#42;k)</code> nor <code>comp(&#42;k, value)</code> is <code>true</code>.


The following code snippet demonstrates how to use <code>equal&#95;range</code> to search for values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::equal_range(input.begin(), input.end(), 0, thrust::less<int>()); // returns [input.begin(), input.begin() + 1)
thrust::equal_range(input.begin(), input.end(), 1, thrust::less<int>()); // returns [input.begin() + 1, input.begin() + 1)
thrust::equal_range(input.begin(), input.end(), 2, thrust::less<int>()); // returns [input.begin() + 1, input.begin() + 2)
thrust::equal_range(input.begin(), input.end(), 3, thrust::less<int>()); // returns [input.begin() + 2, input.begin() + 2)
thrust::equal_range(input.begin(), input.end(), 8, thrust::less<int>()); // returns [input.begin() + 4, input.end)
thrust::equal_range(input.begin(), input.end(), 9, thrust::less<int>()); // returns [input.end(), input.end)
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`T`** is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`value`** The value to be searched. 
* **`comp`** The comparison operator. 

**Returns**:
A <code>pair</code> of iterators <code>[i, j)</code> that define the range of equivalent elements.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/equal_range">https://en.cppreference.com/w/cpp/algorithm/equal_range</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-lower-bound">
Function <code>thrust::lower&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>lower_bound</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>lower&#95;bound</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. Specifically, it returns the index of first position where value could be inserted without violating the ordering.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>lower&#95;bound</code> to search for multiple values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<unsigned int> output(6);

thrust::lower_bound(thrust::device,
                    input.begin(), input.end(),
                    values.begin(), values.end(),
                    output.begin());

// output is now [0, 1, 1, 2, 4, 5]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and <code>ForwardIterator's</code> difference_type is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-lower-bound">
Function <code>thrust::lower&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>lower_bound</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>lower&#95;bound</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. Specifically, it returns the index of first position where value could be inserted without violating the ordering.


The following code snippet demonstrates how to use <code>lower&#95;bound</code> to search for multiple values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<unsigned int> output(6);

thrust::lower_bound(input.begin(), input.end(),
                    values.begin(), values.end(),
                    output.begin());

// output is now [0, 1, 1, 2, 4, 5]
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and <code>ForwardIterator's</code> difference_type is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-lower-bound">
Function <code>thrust::lower&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>lower_bound</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>lower&#95;bound</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. Specifically, it returns the index of first position where value could be inserted without violating the ordering. This version of <code>lower&#95;bound</code> uses function object <code>comp</code> for comparison.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>lower&#95;bound</code> to search for multiple values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<unsigned int> output(6);

thrust::lower_bound(input.begin(), input.end(),
                    values.begin(), values.end(), 
                    output.begin(),
                    thrust::less<int>());

// output is now [0, 1, 1, 2, 4, 5]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and <code>ForwardIterator's</code> difference_type is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence. 
* **`comp`** The comparison operator.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-lower-bound">
Function <code>thrust::lower&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>OutputIterator </span><span><b>lower_bound</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>lower&#95;bound</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. Specifically, it returns the index of first position where value could be inserted without violating the ordering. This version of <code>lower&#95;bound</code> uses function object <code>comp</code> for comparison.


The following code snippet demonstrates how to use <code>lower&#95;bound</code> to search for multiple values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<unsigned int> output(6);

thrust::lower_bound(input.begin(), input.end(),
                    values.begin(), values.end(), 
                    output.begin(),
                    thrust::less<int>());

// output is now [0, 1, 1, 2, 4, 5]
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and <code>ForwardIterator's</code> difference_type is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence. 
* **`comp`** The comparison operator.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-upper-bound">
Function <code>thrust::upper&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>upper_bound</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>upper&#95;bound</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. Specifically, it returns the index of last position where value could be inserted without violating the ordering.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>upper&#95;bound</code> to search for multiple values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<unsigned int> output(6);

thrust::upper_bound(thrust::device,
                    input.begin(), input.end(),
                    values.begin(), values.end(),
                    output.begin());

// output is now [1, 1, 2, 2, 5, 5]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and <code>ForwardIterator's</code> difference_type is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-upper-bound">
Function <code>thrust::upper&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>upper_bound</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>upper&#95;bound</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. Specifically, it returns the index of last position where value could be inserted without violating the ordering.


The following code snippet demonstrates how to use <code>upper&#95;bound</code> to search for multiple values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<unsigned int> output(6);

thrust::upper_bound(input.begin(), input.end(),
                    values.begin(), values.end(),
                    output.begin());

// output is now [1, 1, 2, 2, 5, 5]
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and <code>ForwardIterator's</code> difference_type is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound</a>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-upper-bound">
Function <code>thrust::upper&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>upper_bound</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>upper&#95;bound</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. Specifically, it returns the index of first position where value could be inserted without violating the ordering. This version of <code>upper&#95;bound</code> uses function object <code>comp</code> for comparison.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>upper&#95;bound</code> to search for multiple values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<unsigned int> output(6);

thrust::upper_bound(thrust::device,
                    input.begin(), input.end(),
                    values.begin(), values.end(), 
                    output.begin(),
                    thrust::less<int>());

// output is now [1, 1, 2, 2, 5, 5]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and <code>ForwardIterator's</code> difference_type is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence. 
* **`comp`** The comparison operator.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound</a>
* <code>lower&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-upper-bound">
Function <code>thrust::upper&#95;bound</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>OutputIterator </span><span><b>upper_bound</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>upper&#95;bound</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. Specifically, it returns the index of first position where value could be inserted without violating the ordering. This version of <code>upper&#95;bound</code> uses function object <code>comp</code> for comparison.


The following code snippet demonstrates how to use <code>upper&#95;bound</code> to search for multiple values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<unsigned int> output(6);

thrust::upper_bound(input.begin(), input.end(),
                    values.begin(), values.end(), 
                    output.begin(),
                    thrust::less<int>());

// output is now [1, 1, 2, 2, 5, 5]
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is comparable to <code>ForwardIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and <code>ForwardIterator's</code> difference_type is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence. 
* **`comp`** The comparison operator.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">https://en.cppreference.com/w/cpp/algorithm/upper_bound</a>
* <code>lower&#95;bound</code>
* <code>equal&#95;range</code>
* <code><a href="{{ site.baseurl }}/api/groups/group__binary__search.html">Binary Search</a></code>

<h3 id="function-binary-search">
Function <code>thrust::binary&#95;search</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>binary_search</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>binary&#95;search</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. It returns <code>true</code> if an element that is equivalent to <code>value</code> is present in <code>[first, last)</code> and <code>false</code> if no such element exists.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>binary&#95;search</code> to search for multiple values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<bool> output(6);

thrust::binary_search(thrust::device,
                      input.begin(), input.end(),
                      values.begin(), values.end(),
                      output.begin());

// output is now [true, false, true, false, true, false]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and bool is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>

<h3 id="function-binary-search">
Function <code>thrust::binary&#95;search</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>binary_search</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>binary&#95;search</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. It returns <code>true</code> if an element that is equivalent to <code>value</code> is present in <code>[first, last)</code> and <code>false</code> if no such element exists.


The following code snippet demonstrates how to use <code>binary&#95;search</code> to search for multiple values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<bool> output(6);

thrust::binary_search(input.begin(), input.end(),
                      values.begin(), values.end(),
                      output.begin());

// output is now [true, false, true, false, true, false]
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and bool is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>

<h3 id="function-binary-search">
Function <code>thrust::binary&#95;search</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>binary_search</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>binary&#95;search</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. It returns <code>true</code> if an element that is equivalent to <code>value</code> is present in <code>[first, last)</code> and <code>false</code> if no such element exists. This version of <code>binary&#95;search</code> uses function object <code>comp</code> for comparison.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>binary&#95;search</code> to search for multiple values in a ordered range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<bool> output(6);

thrust::binary_search(thrust::device,
                      input.begin(), input.end(),
                      values.begin(), values.end(),
                      output.begin(),
                      thrust::less<T>());

// output is now [true, false, true, false, true, false]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and bool is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence. 
* **`comp`** The comparison operator.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>

<h3 id="function-binary-search">
Function <code>thrust::binary&#95;search</code>
</h3>

<code class="doxybook">
<span>template &lt;class ForwardIterator,</span>
<span>&nbsp;&nbsp;class InputIterator,</span>
<span>&nbsp;&nbsp;class OutputIterator,</span>
<span>&nbsp;&nbsp;class StrictWeakOrdering&gt;</span>
<span>OutputIterator </span><span><b>binary_search</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator values_first,</span>
<span>&nbsp;&nbsp;InputIterator values_last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>binary&#95;search</code> is a vectorized version of binary search: for each iterator <code>v</code> in <code>[values&#95;first, values&#95;last)</code> it attempts to find the value <code>&#42;v</code> in an ordered range <code>[first, last)</code>. It returns <code>true</code> if an element that is equivalent to <code>value</code> is present in <code>[first, last)</code> and <code>false</code> if no such element exists. This version of <code>binary&#95;search</code> uses function object <code>comp</code> for comparison.


The following code snippet demonstrates how to use <code>binary&#95;search</code> to search for multiple values in a ordered range.



```cpp
#include <thrust/binary_search.h>
#include <thrust/device_vector.h>
#include <thrust/functional.h>
...
thrust::device_vector<int> input(5);

input[0] = 0;
input[1] = 2;
input[2] = 5;
input[3] = 7;
input[4] = 8;

thrust::device_vector<int> values(6);
values[0] = 0; 
values[1] = 1;
values[2] = 2;
values[3] = 3;
values[4] = 8;
values[5] = 9;

thrust::device_vector<bool> output(6);

thrust::binary_search(input.begin(), input.end(),
                      values.begin(), values.end(),
                      output.begin(),
                      thrust::less<T>());

// output is now [true, false, true, false, true, false]
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator's</code><code>value&#95;type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThanComparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. and bool is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the ordered sequence. 
* **`last`** The end of the ordered sequence. 
* **`values_first`** The beginning of the search values sequence. 
* **`values_last`** The end of the search values sequence. 
* **`result`** The beginning of the output sequence. 
* **`comp`** The comparison operator.

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">https://en.cppreference.com/w/cpp/algorithm/binary_search</a>
* <code>lower&#95;bound</code>
* <code>upper&#95;bound</code>
* <code>equal&#95;range</code>

<h3 id="function-abs">
Function <code>thrust::abs</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T </span><span><b>abs</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the magnitude (also known as absolute value) of a <code>complex</code>.

**Function Parameters**:
**`z`**: The <code>complex</code> from which to calculate the absolute value. 

<h3 id="function-arg">
Function <code>thrust::arg</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T </span><span><b>arg</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the phase angle (also known as argument) in radians of a <code>complex</code>.

**Function Parameters**:
**`z`**: The <code>complex</code> from which to calculate the phase angle. 

<h3 id="function-norm">
Function <code>thrust::norm</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T </span><span><b>norm</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the square of the magnitude of a <code>complex</code>.

**Function Parameters**:
**`z`**: The <code>complex</code> from which to calculate the norm. 

<h3 id="function-conj">
Function <code>thrust::conj</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>conj</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex conjugate of a <code>complex</code>.

**Function Parameters**:
**`z`**: The <code>complex</code> from which to calculate the complex conjugate. 

<h3 id="function-polar">
Function <code>thrust::polar</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>polar</b>(const T0 & m,</span>
<span>&nbsp;&nbsp;const T1 & theta = T1());</span></code>
Returns a <code>complex</code> with the specified magnitude and phase.

**Function Parameters**:
* **`m`** The magnitude of the returned <code>complex</code>. 
* **`theta`** The phase of the returned <code>complex</code> in radians. 

<h3 id="function-proj">
Function <code>thrust::proj</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>proj</b>(const T & z);</span></code>
Returns the projection of a <code>complex</code> on the Riemann sphere. For all finite <code>complex</code> it returns the argument. For <code>complexs</code> with a non finite part returns (INFINITY,+/-0) where the sign of the zero matches the sign of the imaginary part of the argument.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-operator+">
Function <code>thrust::operator+</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator+</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Adds two <code>complex</code> numbers.

The value types of the two <code>complex</code> types should be compatible and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The first <code>complex</code>. 
* **`y`** The second <code>complex</code>. 

<h3 id="function-operator+">
Function <code>thrust::operator+</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator+</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span></code>
Adds a scalar to a <code>complex</code> number.

The value type of the <code>complex</code> should be compatible with the scalar and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The <code>complex</code>. 
* **`y`** The scalar. 

<h3 id="function-operator+">
Function <code>thrust::operator+</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator+</b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Adds a <code>complex</code> number to a scalar.

The value type of the <code>complex</code> should be compatible with the scalar and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The scalar. 
* **`y`** The <code>complex</code>. 

<h3 id="function-operator-">
Function <code>thrust::operator-</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator-</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Subtracts two <code>complex</code> numbers.

The value types of the two <code>complex</code> types should be compatible and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The first <code>complex</code> (minuend). 
* **`y`** The second <code>complex</code> (subtrahend). 

<h3 id="function-operator-">
Function <code>thrust::operator-</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator-</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span></code>
Subtracts a scalar from a <code>complex</code> number.

The value type of the <code>complex</code> should be compatible with the scalar and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The <code>complex</code> (minuend). 
* **`y`** The scalar (subtrahend). 

<h3 id="function-operator-">
Function <code>thrust::operator-</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator-</b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Subtracts a <code>complex</code> number from a scalar.

The value type of the <code>complex</code> should be compatible with the scalar and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The scalar (minuend). 
* **`y`** The <code>complex</code> (subtrahend). 

<h3 id="function-operator*">
Function <code>thrust::operator&#42;</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator*</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Multiplies two <code>complex</code> numbers.

The value types of the two <code>complex</code> types should be compatible and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The first <code>complex</code>. 
* **`y`** The second <code>complex</code>. 

<h3 id="function-operator*">
Function <code>thrust::operator&#42;</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator*</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span></code>
Multiplies a <code>complex</code> number by a scalar.

**Function Parameters**:
* **`x`** The <code>complex</code>. 
* **`y`** The scalar. 

<h3 id="function-operator*">
Function <code>thrust::operator&#42;</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator*</b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Multiplies a scalar by a <code>complex</code> number.

The value type of the <code>complex</code> should be compatible with the scalar and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The scalar. 
* **`y`** The <code>complex</code>. 

<h3 id="function-operator/">
Function <code>thrust::operator/</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator/</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Divides two <code>complex</code> numbers.

The value types of the two <code>complex</code> types should be compatible and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The numerator (dividend). 
* **`y`** The denomimator (divisor). 

<h3 id="function-operator/">
Function <code>thrust::operator/</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator/</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span></code>
Divides a <code>complex</code> number by a scalar.

The value type of the <code>complex</code> should be compatible with the scalar and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The complex numerator (dividend). 
* **`y`** The scalar denomimator (divisor). 

<h3 id="function-operator/">
Function <code>thrust::operator/</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>operator/</b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Divides a scalar by a <code>complex</code> number.

The value type of the <code>complex</code> should be compatible with the scalar and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The scalar numerator (dividend). 
* **`y`** The complex denomimator (divisor). 

<h3 id="function-operator+">
Function <code>thrust::operator+</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>operator+</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & y);</span></code>
Unary plus, returns its <code>complex</code> argument.

**Function Parameters**:
**`y`**: The <code>complex</code> argument. 

<h3 id="function-operator-">
Function <code>thrust::operator-</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>operator-</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & y);</span></code>
Unary minus, returns the additive inverse (negation) of its <code>complex</code> argument.

**Function Parameters**:
**`y`**: The <code>complex</code> argument. 

<h3 id="function-exp">
Function <code>thrust::exp</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>exp</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex exponential of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-log">
Function <code>thrust::log</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>log</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex natural logarithm of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-log10">
Function <code>thrust::log10</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>log10</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex base 10 logarithm of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-pow">
Function <code>thrust::pow</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>pow</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Returns a <code>complex</code> number raised to another.

The value types of the two <code>complex</code> types should be compatible and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The base. 
* **`y`** The exponent. 

<h3 id="function-pow">
Function <code>thrust::pow</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>pow</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span></code>
Returns a <code>complex</code> number raised to a scalar.

The value type of the <code>complex</code> should be compatible with the scalar and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The base. 
* **`y`** The exponent. 

<h3 id="function-pow">
Function <code>thrust::pow</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< typename detail::promoted_numerical_type< T0, T1 >::type > </span><span><b>pow</b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Returns a scalar raised to a <code>complex</code> number.

The value type of the <code>complex</code> should be compatible with the scalar and the type of the returned <code>complex</code> is the promoted type of the two arguments.

**Function Parameters**:
* **`x`** The base. 
* **`y`** The exponent. 

<h3 id="function-sqrt">
Function <code>thrust::sqrt</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>sqrt</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex square root of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-cos">
Function <code>thrust::cos</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>cos</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex cosine of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-sin">
Function <code>thrust::sin</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>sin</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex sine of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-tan">
Function <code>thrust::tan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>tan</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex tangent of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-cosh">
Function <code>thrust::cosh</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>cosh</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex hyperbolic cosine of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-sinh">
Function <code>thrust::sinh</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>sinh</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex hyperbolic sine of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-tanh">
Function <code>thrust::tanh</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>tanh</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex hyperbolic tangent of a <code>complex</code> number.

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-acos">
Function <code>thrust::acos</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>acos</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex arc cosine of a <code>complex</code> number.

The range of the real part of the result is [0, Pi] and the range of the imaginary part is [-inf, +inf]

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-asin">
Function <code>thrust::asin</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>asin</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex arc sine of a <code>complex</code> number.

The range of the real part of the result is [-Pi/2, Pi/2] and the range of the imaginary part is [-inf, +inf]

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-atan">
Function <code>thrust::atan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>atan</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex arc tangent of a <code>complex</code> number.

The range of the real part of the result is [-Pi/2, Pi/2] and the range of the imaginary part is [-inf, +inf]

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-acosh">
Function <code>thrust::acosh</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>acosh</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex inverse hyperbolic cosine of a <code>complex</code> number.

The range of the real part of the result is [0, +inf] and the range of the imaginary part is [-Pi, Pi]

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-asinh">
Function <code>thrust::asinh</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>asinh</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex inverse hyperbolic sine of a <code>complex</code> number.

The range of the real part of the result is [-inf, +inf] and the range of the imaginary part is [-Pi/2, Pi/2]

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-atanh">
Function <code>thrust::atanh</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > </span><span><b>atanh</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Returns the complex inverse hyperbolic tangent of a <code>complex</code> number.

The range of the real part of the result is [-inf, +inf] and the range of the imaginary part is [-Pi/2, Pi/2]

**Function Parameters**:
**`z`**: The <code>complex</code> argument. 

<h3 id="function-operator<<">
Function <code>thrust::operator&lt;&lt;</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename CharT,</span>
<span>&nbsp;&nbsp;typename Traits&gt;</span>
<span>std::basic_ostream< CharT, Traits > & </span><span><b>operator<<</b>(std::basic_ostream< CharT, Traits > & os,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Writes to an output stream a <code>complex</code> number in the form (real, imaginary).

**Function Parameters**:
* **`os`** The output stream. 
* **`z`** The <code>complex</code> number to output. 

<h3 id="function-operator>>">
Function <code>thrust::operator&gt;&gt;</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename CharT,</span>
<span>&nbsp;&nbsp;typename Traits&gt;</span>
<span>__host__ std::basic_istream< CharT, Traits > & </span><span><b>operator>></b>(std::basic_istream< CharT, Traits > & is,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T > & z);</span></code>
Reads a <code>complex</code> number from an input stream.

The recognized formats are:

* real
* (real)
* (real, imaginary)
The values read must be convertible to the <code>complex's</code><code>value&#95;type</code>

**Function Parameters**:
* **`is`** The input stream. 
* **`z`** The <code>complex</code> number to set. 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator==</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Returns true if two <code>complex</code> numbers are equal and false otherwise.

**Function Parameters**:
* **`x`** The first <code>complex</code>. 
* **`y`** The second <code>complex</code>. 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator==</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const std::complex< T1 > & y);</span></code>
Returns true if two <code>complex</code> numbers are equal and false otherwise.

**Function Parameters**:
* **`x`** The first <code>complex</code>. 
* **`y`** The second <code>complex</code>. 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator==</b>(const std::complex< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Returns true if two <code>complex</code> numbers are equal and false otherwise.

**Function Parameters**:
* **`x`** The first <code>complex</code>. 
* **`y`** The second <code>complex</code>. 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator==</b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Returns true if the imaginary part of the <code>complex</code> number is zero and the real part is equal to the scalar. Returns false otherwise.

**Function Parameters**:
* **`x`** The scalar. 
* **`y`** The <code>complex</code>. 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator==</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span></code>
Returns true if the imaginary part of the <code>complex</code> number is zero and the real part is equal to the scalar. Returns false otherwise.

**Function Parameters**:
* **`x`** The <code>complex</code>. 
* **`y`** The scalar. 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator!=</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Returns true if two <code>complex</code> numbers are different and false otherwise.

**Function Parameters**:
* **`x`** The first <code>complex</code>. 
* **`y`** The second <code>complex</code>. 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator!=</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const std::complex< T1 > & y);</span></code>
Returns true if two <code>complex</code> numbers are different and false otherwise.

**Function Parameters**:
* **`x`** The first <code>complex</code>. 
* **`y`** The second <code>complex</code>. 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator!=</b>(const std::complex< T0 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Returns true if two <code>complex</code> numbers are different and false otherwise.

**Function Parameters**:
* **`x`** The first <code>complex</code>. 
* **`y`** The second <code>complex</code>. 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator!=</b>(const T0 & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T1 > & y);</span></code>
Returns true if the imaginary part of the <code>complex</code> number is not zero or the real part is different from the scalar. Returns false otherwise.

**Function Parameters**:
* **`x`** The scalar. 
* **`y`** The <code>complex</code>. 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator!=</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1complex.html">complex</a>< T0 > & x,</span>
<span>&nbsp;&nbsp;const T1 & y);</span></code>
Returns true if the imaginary part of the <code>complex</code> number is not zero or the real part is different from the scalar. Returns false otherwise.

**Function Parameters**:
* **`x`** The <code>complex</code>. 
* **`y`** The scalar. 

<h3 id="function-copy">
Function <code>thrust::copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>copy</code> copies elements from the range [<code>first</code>, <code>last</code>) to the range [<code>result</code>, <code>result</code> + (<code>last</code> - <code>first</code>)). That is, it performs the assignments *<code>result</code> = *<code>first</code>, *(<code>result</code> + <code>1</code>) = *(<code>first</code> + <code>1</code>), and so on. Generally, for every integer <code>n</code> from <code>0</code> to <code>last</code> - <code>first</code>, <code>copy</code> performs the assignment *(<code>result</code> + <code>n</code>) = *(<code>first</code> + <code>n</code>). Unlike <code>std::copy</code>, <code>copy</code> offers no guarantee on order of operation. As a result, calling <code>copy</code> with overlapping source and destination ranges has undefined behavior.

The return value is <code>result</code> + (<code>last</code> - <code>first</code>).

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>copy</code> to copy from one range to another using the <code>thrust::device</code> parallelization policy:



```cpp
#include <thrust/copy.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...

thrust::device_vector<int> vec0(100);
thrust::device_vector<int> vec1(100);
...

thrust::copy(thrust::device, vec0.begin(), vec0.end(), vec1.begin());

// vec1 is now a copy of vec0
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to copy. 
* **`last`** The end of the sequence to copy. 
* **`result`** The destination sequence. 

**Preconditions**:
<code>result</code> may be equal to <code>first</code>, but <code>result</code> shall not be in the range <code>[first, last)</code> otherwise.

**Returns**:
The end of the destination sequence. 

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/copy">https://en.cppreference.com/w/cpp/algorithm/copy</a>

<h3 id="function-copy-n">
Function <code>thrust::copy&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>copy_n</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>copy&#95;n</code> copies elements from the range <code>[first, first + n)</code> to the range <code>[result, result + n)</code>. That is, it performs the assignments <code>&#42;result = &#42;first, &#42;(result + 1) = &#42;(first + 1)</code>, and so on. Generally, for every integer <code>i</code> from <code>0</code> to <code>n</code>, <code>copy</code> performs the assignment *(<code>result</code> + <code>i</code>) = *(<code>first</code> + <code>i</code>). Unlike <code>std::copy&#95;n</code>, <code>copy&#95;n</code> offers no guarantee on order of operation. As a result, calling <code>copy&#95;n</code> with overlapping source and destination ranges has undefined behavior.

The return value is <code>result</code> + <code>n</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>copy</code> to copy from one range to another using the <code>thrust::device</code> parallelization policy:



```cpp
#include <thrust/copy.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
size_t n = 100;
thrust::device_vector<int> vec0(n);
thrust::device_vector<int> vec1(n);
...
thrust::copy_n(thrust::device, vec0.begin(), n, vec1.begin());

// vec1 is now a copy of vec0
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`Size`** is an integral type. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range to copy. 
* **`n`** The number of elements to copy. 
* **`result`** The beginning destination range. 

**Preconditions**:
<code>result</code> may be equal to <code>first</code>, but <code>result</code> shall not be in the range <code>[first, first + n)</code> otherwise.

**Returns**:
The end of the destination range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/copy_n">https://en.cppreference.com/w/cpp/algorithm/copy_n</a>
* thrust::copy 

<h3 id="function-copy">
Function <code>thrust::copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>copy</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>copy</code> copies elements from the range [<code>first</code>, <code>last</code>) to the range [<code>result</code>, <code>result</code> + (<code>last</code> - <code>first</code>)). That is, it performs the assignments *<code>result</code> = *<code>first</code>, *(<code>result</code> + <code>1</code>) = *(<code>first</code> + <code>1</code>), and so on. Generally, for every integer <code>n</code> from <code>0</code> to <code>last</code> - <code>first</code>, <code>copy</code> performs the assignment *(<code>result</code> + <code>n</code>) = *(<code>first</code> + <code>n</code>). Unlike <code>std::copy</code>, <code>copy</code> offers no guarantee on order of operation. As a result, calling <code>copy</code> with overlapping source and destination ranges has undefined behavior.

The return value is <code>result</code> + (<code>last</code> - <code>first</code>).


The following code snippet demonstrates how to use <code>copy</code> to copy from one range to another.



```cpp
#include <thrust/copy.h>
#include <thrust/device_vector.h>
...

thrust::device_vector<int> vec0(100);
thrust::device_vector<int> vec1(100);
...

thrust::copy(vec0.begin(), vec0.end(),
             vec1.begin());

// vec1 is now a copy of vec0
```

**Template Parameters**:
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence to copy. 
* **`last`** The end of the sequence to copy. 
* **`result`** The destination sequence. 

**Preconditions**:
<code>result</code> may be equal to <code>first</code>, but <code>result</code> shall not be in the range <code>[first, last)</code> otherwise.

**Returns**:
The end of the destination sequence. 

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/copy">https://en.cppreference.com/w/cpp/algorithm/copy</a>

<h3 id="function-copy-n">
Function <code>thrust::copy&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>copy_n</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>copy&#95;n</code> copies elements from the range <code>[first, first + n)</code> to the range <code>[result, result + n)</code>. That is, it performs the assignments <code>&#42;result = &#42;first, &#42;(result + 1) = &#42;(first + 1)</code>, and so on. Generally, for every integer <code>i</code> from <code>0</code> to <code>n</code>, <code>copy</code> performs the assignment *(<code>result</code> + <code>i</code>) = *(<code>first</code> + <code>i</code>). Unlike <code>std::copy&#95;n</code>, <code>copy&#95;n</code> offers no guarantee on order of operation. As a result, calling <code>copy&#95;n</code> with overlapping source and destination ranges has undefined behavior.

The return value is <code>result</code> + <code>n</code>.


The following code snippet demonstrates how to use <code>copy</code> to copy from one range to another.



```cpp
#include <thrust/copy.h>
#include <thrust/device_vector.h>
...
size_t n = 100;
thrust::device_vector<int> vec0(n);
thrust::device_vector<int> vec1(n);
...
thrust::copy_n(vec0.begin(), n, vec1.begin());

// vec1 is now a copy of vec0
```

**Template Parameters**:
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`Size`** is an integral type. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first`** The beginning of the range to copy. 
* **`n`** The number of elements to copy. 
* **`result`** The beginning destination range. 

**Preconditions**:
<code>result</code> may be equal to <code>first</code>, but <code>result</code> shall not be in the range <code>[first, first + n)</code> otherwise.

**Returns**:
The end of the destination range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/copy_n">https://en.cppreference.com/w/cpp/algorithm/copy_n</a>
* thrust::copy 

<h3 id="function-copy-if">
Function <code>thrust::copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>copy_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>copy&#95;if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that any element which causes <code>pred</code> to be <code>false</code> is not copied. <code>copy&#95;if</code> is stable, meaning that the relative order of elements that are copied is unchanged.

More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>copy&#95;if</code> performs the assignment <code>&#42;result = &#42;(first+n)</code> and <code>result</code> is advanced one position if <code>pred(&#42;(first+n))</code>. Otherwise, no assignment occurs and <code>result</code> is not advanced.

The algorithm's execution is parallelized as determined by <code>system</code>.


The following code snippet demonstrates how to use <code>copy&#95;if</code> to perform stream compaction to copy even numbers to an output range using the <code>thrust::host</code> parallelization policy:



```cpp
#include <thrust/copy.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...
const int N = 6;
int V[N] = {-2, 0, -1, 0, 1, 2};
int result[4];

thrust::copy_if(thrust::host, V, V + N, result, is_even());

// V remains {-2, 0, -1, 0, 1, 2}
// result is now {-2, 0, 0, 2}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence from which to copy. 
* **`last`** The end of the sequence from which to copy. 
* **`result`** The beginning of the sequence into which to copy. 
* **`pred`** The predicate to test on every value of the range <code>[first, last)</code>. 

**Preconditions**:
The ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**Returns**:
<code>result + n</code>, where <code>n</code> is equal to the number of times <code>pred</code> evaluated to <code>true</code> in the range <code>[first, last)</code>.

**See**:
<code>remove&#95;copy&#95;if</code>

<h3 id="function-copy-if">
Function <code>thrust::copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b>copy_if</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>copy&#95;if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that any element which causes <code>pred</code> to <code>false</code> is not copied. <code>copy&#95;if</code> is stable, meaning that the relative order of elements that are copied is unchanged.

More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>copy&#95;if</code> performs the assignment <code>&#42;result = &#42;(first+n)</code> and <code>result</code> is advanced one position if <code>pred(&#42;(first+n))</code>. Otherwise, no assignment occurs and <code>result</code> is not advanced.


The following code snippet demonstrates how to use <code>copy&#95;if</code> to perform stream compaction to copy even numbers to an output range.



```cpp
#include <thrust/copy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...
const int N = 6;
int V[N] = {-2, 0, -1, 0, 1, 2};
int result[4];

thrust::copy_if(V, V + N, result, is_even());

// V remains {-2, 0, -1, 0, 1, 2}
// result is now {-2, 0, 0, 2}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence from which to copy. 
* **`last`** The end of the sequence from which to copy. 
* **`result`** The beginning of the sequence into which to copy. 
* **`pred`** The predicate to test on every value of the range <code>[first, last)</code>. 

**Preconditions**:
The ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap.

**Returns**:
<code>result + n</code>, where <code>n</code> is equal to the number of times <code>pred</code> evaluated to <code>true</code> in the range <code>[first, last)</code>.

**See**:
<code>remove&#95;copy&#95;if</code>

<h3 id="function-copy-if">
Function <code>thrust::copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>copy_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>copy&#95;if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that any element whose corresponding stencil element causes <code>pred</code> to be <code>false</code> is not copied. <code>copy&#95;if</code> is stable, meaning that the relative order of elements that are copied is unchanged.

More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>copy&#95;if</code> performs the assignment <code>&#42;result = &#42;(first+n)</code> and <code>result</code> is advanced one position if <code>pred(&#42;(stencil+n))</code>. Otherwise, no assignment occurs and <code>result</code> is not advanced.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>copy&#95;if</code> to perform stream compaction to copy numbers to an output range when corresponding stencil elements are even using the <code>thrust::host</code> execution policy:



```cpp
#include <thrust/copy.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...
int N = 6;
int data[N]    = { 0, 1,  2, 3, 4, 5};
int stencil[N] = {-2, 0, -1, 0, 1, 2};
int result[4];

thrust::copy_if(thrust::host, data, data + N, stencil, result, is_even());

// data remains    = { 0, 1,  2, 3, 4, 5};
// stencil remains = {-2, 0, -1, 0, 1, 2};
// result is now     { 0, 1,  3, 5}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/OutputIterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence from which to copy. 
* **`last`** The end of the sequence from which to copy. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The beginning of the sequence into which to copy. 
* **`pred`** The predicate to test on every value of the range <code>[stencil, stencil + (last-first))</code>. 

**Preconditions**:
* The ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap. 
* The ranges <code>[stencil, stencil + (last - first))</code> and <code>[result, result + (last - first))</code> shall not overlap.

**Returns**:
<code>result + n</code>, where <code>n</code> is equal to the number of times <code>pred</code> evaluated to <code>true</code> in the range <code>[stencil, stencil + (last-first))</code>.

**See**:
<code>remove&#95;copy&#95;if</code>

<h3 id="function-copy-if">
Function <code>thrust::copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b>copy_if</b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>copy&#95;if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that any element whose corresponding stencil element causes <code>pred</code> to be <code>false</code> is not copied. <code>copy&#95;if</code> is stable, meaning that the relative order of elements that are copied is unchanged.

More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>copy&#95;if</code> performs the assignment <code>&#42;result = &#42;(first+n)</code> and <code>result</code> is advanced one position if <code>pred(&#42;(stencil+n))</code>. Otherwise, no assignment occurs and <code>result</code> is not advanced.


The following code snippet demonstrates how to use <code>copy&#95;if</code> to perform stream compaction to copy numbers to an output range when corresponding stencil elements are even:



```cpp
#include <thrust/copy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...
int N = 6;
int data[N]    = { 0, 1,  2, 3, 4, 5};
int stencil[N] = {-2, 0, -1, 0, 1, 2};
int result[4];

thrust::copy_if(data, data + N, stencil, result, is_even());

// data remains    = { 0, 1,  2, 3, 4, 5};
// stencil remains = {-2, 0, -1, 0, 1, 2};
// result is now     { 0, 1,  3, 5}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/OutputIterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence from which to copy. 
* **`last`** The end of the sequence from which to copy. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The beginning of the sequence into which to copy. 
* **`pred`** The predicate to test on every value of the range <code>[stencil, stencil + (last-first))</code>. 

**Preconditions**:
* The ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap. 
* The ranges <code>[stencil, stencil + (last - first))</code> and <code>[result, result + (last - first))</code> shall not overlap.

**Returns**:
<code>result + n</code>, where <code>n</code> is equal to the number of times <code>pred</code> evaluated to <code>true</code> in the range <code>[stencil, stencil + (last-first))</code>.

**See**:
<code>remove&#95;copy&#95;if</code>

<h3 id="function-count">
Function <code>thrust::count</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename EqualityComparable&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b>count</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;const EqualityComparable & value);</span></code>
<code>count</code> finds the number of elements in <code>[first,last)</code> that are equal to <code>value</code>. More precisely, <code>count</code> returns the number of iterators <code>i</code> in <code>[first, last)</code> such that <code>&#42;i == value</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>count</code> to count the number of instances in a range of a value of interest using the <code>thrust::device</code> execution policy:



```cpp
#include <thrust/count.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
// put 3 1s in a device_vector
thrust::device_vector<int> vec(5,0);
vec[1] = 1;
vec[3] = 1;
vec[4] = 1;

// count the 1s
int result = thrust::count(thrust::device, vec.begin(), vec.end(), 1);
// result == 3
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be a model of must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`EqualityComparable`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a> and can be compared for equality with <code>InputIterator's</code><code>value&#95;type</code>

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`value`** The value to be counted. 

**Returns**:
The number of elements equal to <code>value</code>.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a>

<h3 id="function-count">
Function <code>thrust::count</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename EqualityComparable&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b>count</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;const EqualityComparable & value);</span></code>
<code>count</code> finds the number of elements in <code>[first,last)</code> that are equal to <code>value</code>. More precisely, <code>count</code> returns the number of iterators <code>i</code> in <code>[first, last)</code> such that <code>&#42;i == value</code>.


The following code snippet demonstrates how to use <code>count</code> to count the number of instances in a range of a value of interest. 

```cpp
#include <thrust/count.h>
#include <thrust/device_vector.h>
...
// put 3 1s in a device_vector
thrust::device_vector<int> vec(5,0);
vec[1] = 1;
vec[3] = 1;
vec[4] = 1;

// count the 1s
int result = thrust::count(vec.begin(), vec.end(), 1);
// result == 3
```

**Template Parameters**:
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be a model of must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`EqualityComparable`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a> and can be compared for equality with <code>InputIterator's</code><code>value&#95;type</code>

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`value`** The value to be counted. 

**Returns**:
The number of elements equal to <code>value</code>.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a>

<h3 id="function-count-if">
Function <code>thrust::count&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b>count_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>count&#95;if</code> finds the number of elements in <code>[first,last)</code> for which a predicate is <code>true</code>. More precisely, <code>count&#95;if</code> returns the number of iterators <code>i</code> in <code>[first, last)</code> such that <code>pred(&#42;i) == true</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>count</code> to count the number of odd numbers in a range using the <code>thrust::device</code> execution policy:



```cpp
#include <thrust/count.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
struct is_odd
{
  __host__ __device__
  bool operator()(int &x)
  {
    return x & 1;
  }
};
...
// fill a device_vector with even & odd numbers
thrust::device_vector<int> vec(5);
vec[0] = 0;
vec[1] = 1;
vec[2] = 2;
vec[3] = 3;
vec[4] = 4;

// count the odd elements in vec
int result = thrust::count_if(thrust::device, vec.begin(), vec.end(), is_odd());
// result == 2
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`pred`** The predicate. 

**Returns**:
The number of elements where <code>pred</code> is <code>true</code>.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a>

<h3 id="function-count-if">
Function <code>thrust::count&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b>count_if</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>count&#95;if</code> finds the number of elements in <code>[first,last)</code> for which a predicate is <code>true</code>. More precisely, <code>count&#95;if</code> returns the number of iterators <code>i</code> in <code>[first, last)</code> such that <code>pred(&#42;i) == true</code>.


The following code snippet demonstrates how to use <code>count</code> to count the number of odd numbers in a range. 

```cpp
#include <thrust/count.h>
#include <thrust/device_vector.h>
...
struct is_odd
{
  __host__ __device__
  bool operator()(int &x)
  {
    return x & 1;
  }
};
...
// fill a device_vector with even & odd numbers
thrust::device_vector<int> vec(5);
vec[0] = 0;
vec[1] = 1;
vec[2] = 2;
vec[3] = 3;
vec[4] = 4;

// count the odd elements in vec
int result = thrust::count_if(vec.begin(), vec.end(), is_odd());
// result == 2
```

**Template Parameters**:
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`pred`** The predicate. 

**Returns**:
The number of elements where <code>pred</code> is <code>true</code>.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/count">https://en.cppreference.com/w/cpp/algorithm/count</a>

<h3 id="function-device-delete">
Function <code>thrust::device&#95;delete</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>void </span><span><b>device_delete</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">thrust::device_ptr</a>< T > ptr,</span>
<span>&nbsp;&nbsp;const size_t n = 1);</span></code>
<code>device&#95;delete</code> deletes a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> allocated with <code>device&#95;new</code>.

**Function Parameters**:
* **`ptr`** The <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> to delete, assumed to have been allocated with <code>device&#95;new</code>. 
* **`n`** The number of objects to destroy at <code>ptr</code>. Defaults to <code>1</code> similar to <code>device&#95;new</code>.

**See**:
* <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>
* device_new 

<h3 id="function-device-free">
Function <code>thrust::device&#95;free</code>
</h3>

<code class="doxybook">
<span>void </span><span><b>device_free</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">thrust::device_ptr</a>< void > ptr);</span></code>
<code>device&#95;free</code> deallocates memory allocated by the function <code>device&#95;malloc</code>.


The following code snippet demonstrates how to use <code>device&#95;free</code> to deallocate memory allocated by <code>device&#95;malloc</code>.



```cpp
#include <thrust/device_malloc.h>
#include <thrust/device_free.h>
...
// allocate some integers with device_malloc
const int N = 100;
thrust::device_ptr<int> int_array = thrust::device_malloc<int>(N);

// manipulate integers
...

// deallocate with device_free
thrust::device_free(int_array);
```

**Function Parameters**:
**`ptr`**: A <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> pointing to memory to be deallocated.

**See**:
* <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>
* device_malloc 

<h3 id="function-device-make-unique">
Function <code>thrust::device&#95;make&#95;unique</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename... Args&gt;</span>
<span>__host__ auto </span><span><b>device_make_unique</b>(Args &&... args);</span></code>
<h3 id="function-device-malloc">
Function <code>thrust::device&#95;malloc</code>
</h3>

<code class="doxybook">
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">thrust::device_ptr</a>< void > </span><span><b>device_malloc</b>(const std::size_t n);</span></code>
This version of <code>device&#95;malloc</code> allocates sequential device storage for bytes.


The following code snippet demonstrates how to use <code>device&#95;malloc</code> to allocate a range of device memory.



```cpp
#include <thrust/device_malloc.h>
#include <thrust/device_free.h>
...
// allocate some memory with device_malloc
const int N = 100;
thrust::device_ptr<void> void_ptr = thrust::device_malloc(N);

// manipulate memory
...

// deallocate with device_free
thrust::device_free(void_ptr);
```

**Function Parameters**:
**`n`**: The number of bytes to allocate sequentially in device memory. 

**Returns**:
A <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> to the newly allocated memory.

**See**:
* <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>
* device_free 

<h3 id="function-device-malloc">
Function <code>thrust::device&#95;malloc</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">thrust::device_ptr</a>< T > </span><span><b>device_malloc</b>(const std::size_t n);</span></code>
This version of <code>device&#95;malloc</code> allocates sequential device storage for new objects of the given type.


The following code snippet demonstrates how to use <code>device&#95;malloc</code> to allocate a range of device memory.



```cpp
#include <thrust/device_malloc.h>
#include <thrust/device_free.h>
...
// allocate some integers with device_malloc
const int N = 100;
thrust::device_ptr<int> int_array = thrust::device_malloc<int>(N);

// manipulate integers
...

// deallocate with device_free
thrust::device_free(int_array);
```

**Function Parameters**:
**`n`**: The number of objects of type T to allocate sequentially in device memory. 

**Returns**:
A <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> to the newly allocated memory.

**See**:
* <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>
* device_free 

<h3 id="function-device-malloc">
Function <code>thrust::device&#95;malloc</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b>device_malloc</b>(const std::size_t n);</span></code>
<h3 id="function-device-new">
Function <code>thrust::device&#95;new</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b>device_new</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< void > p,</span>
<span>&nbsp;&nbsp;const size_t n = 1);</span></code>
<code>device&#95;new</code> implements the placement <code>new</code> operator for types resident in device memory. <code>device&#95;new</code> calls <code>T</code>'s null constructor on a array of objects in device memory. No memory is allocated by this function.

**Function Parameters**:
* **`p`** A <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> to a region of device memory into which to construct one or many <code>T</code>s. 
* **`n`** The number of objects to construct at <code>p</code>. 

**Returns**:
p, casted to <code>T</code>'s type.

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>

<h3 id="function-device-new">
Function <code>thrust::device&#95;new</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b>device_new</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< void > p,</span>
<span>&nbsp;&nbsp;const T & exemplar,</span>
<span>&nbsp;&nbsp;const size_t n = 1);</span></code>
<code>device&#95;new</code> implements the placement new operator for types resident in device memory. <code>device&#95;new</code> calls <code>T</code>'s copy constructor on a array of objects in device memory. No memory is allocated by this function.

**Function Parameters**:
* **`p`** A <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> to a region of device memory into which to construct one or many <code>T</code>s. 
* **`exemplar`** The value from which to copy. 
* **`n`** The number of objects to construct at <code>p</code>. 

**Returns**:
p, casted to <code>T</code>'s type.

**See**:
* <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>
* fill 

<h3 id="function-device-new">
Function <code>thrust::device&#95;new</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b>device_new</b>(const size_t n = 1);</span></code>
<code>device&#95;new</code> implements the new operator for types resident in device memory. It allocates device memory large enough to hold <code>n</code> new objects of type <code>T</code>.

**Function Parameters**:
**`n`**: The number of objects to allocate. Defaults to <code>1</code>. 

**Returns**:
A <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> to the newly allocated region of device memory. 

<h3 id="function-operator<<">
Function <code>thrust::operator&lt;&lt;</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename CharT,</span>
<span>&nbsp;&nbsp;typename Traits&gt;</span>
<span>__host__ std::basic_ostream< CharT, Traits > & </span><span><b>operator<<</b>(std::basic_ostream< CharT, Traits > & os,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > const & dp);</span></code>
Write the address that a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> points to to an output stream.

**Function Parameters**:
* **`os`** The output stream. 
* **`dp`** The <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> to output.

**Returns**:
<code>os</code>. 

<h3 id="function-device-pointer-cast">
Function <code>thrust::device&#95;pointer&#95;cast</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b>device_pointer_cast</b>(T * ptr);</span></code>
Create a <code>device&#95;ptr</code> from a raw pointer. 

**Template Parameters**:
**`T`**: Any type. 

**Function Parameters**:
**`ptr`**: A raw pointer to a <code>T</code> in device memory.

**Preconditions**:
<code>ptr</code> points to a location in device memory.

**Returns**:
A <code>device&#95;ptr&lt;T&gt;</code> pointing to <code>ptr</code>. 

<h3 id="function-device-pointer-cast">
Function <code>thrust::device&#95;pointer&#95;cast</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > </span><span><b>device_pointer_cast</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device_ptr</a>< T > const & dptr);</span></code>
Create a <code>device&#95;ptr</code> from another <code>device&#95;ptr</code>. 

**Template Parameters**:
**`T`**: Any type. 

**Function Parameters**:
**`dptr`**: A <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__ptr.html">device&#95;ptr</a></code> to a <code>T</code>. 

<h3 id="function-swap">
Function <code>thrust::swap</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b>swap</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device_reference</a>< T > & x,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device_reference</a>< T > & y);</span></code>
swaps the value of one <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device&#95;reference</a></code> with another. <code>x</code> The first <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device&#95;reference</a></code> of interest. <code>y</code> The second <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device&#95;reference</a></code> of interest. 

<h3 id="function-operator<<">
Function <code>thrust::operator&lt;&lt;</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename charT,</span>
<span>&nbsp;&nbsp;typename traits&gt;</span>
<span>std::basic_ostream< charT, traits > & </span><span><b>operator<<</b>(std::basic_ostream< charT, traits > & os,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device_reference</a>< T > & y);</span></code>
Writes to an output stream the value of a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device&#95;reference</a></code>.

**Function Parameters**:
* **`os`** The output stream. 
* **`y`** The <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__reference.html">device&#95;reference</a></code> to output. 

**Returns**:
os. 

<h3 id="function-swap">
Function <code>thrust::swap</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Alloc&gt;</span>
<span>void </span><span><b>swap</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device_vector</a>< T, Alloc > & a,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device_vector</a>< T, Alloc > & b);</span></code>
Exchanges the values of two vectors. <code>x</code> The first <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> of interest. <code>y</code> The second <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> of interest. 

<h3 id="function-distance">
Function <code>thrust::distance</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::difference_type </span><span><b>distance</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last);</span></code>
<code>distance</code> finds the distance between <code>first</code> and <code>last</code>, i.e. the number of times that <code>first</code> must be incremented until it is equal to <code>last</code>.


The following code snippet demonstrates how to use <code>distance</code> to compute the distance to one iterator from another.



```cpp
#include <thrust/distance.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> vec(13);
thrust::device_vector<int>::iterator iter1 = vec.begin();
thrust::device_vector<int>::iterator iter2 = iter1 + 7;

int d = thrust::distance(iter1, iter2);

// d is 7
```

**Template Parameters**:
**`InputIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>.

**Function Parameters**:
* **`first`** The beginning of an input range of interest. 
* **`last`** The end of an input range of interest. 

**Preconditions**:
If <code>InputIterator</code> meets the requirements of random access iterator, <code>last</code> shall be reachable from <code>first</code> or <code>first</code> shall be reachable from <code>last</code>; otherwise, <code>last</code> shall be reachable from <code>first</code>.

**Returns**:
The distance between the beginning and end of the input range.

**See**:
<a href="https://en.cppreference.com/w/cpp/iterator/distance">https://en.cppreference.com/w/cpp/iterator/distance</a>

<h3 id="function-equal">
Function <code>thrust::equal</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2&gt;</span>
<span>__host__ __device__ bool </span><span><b>equal</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2);</span></code>
<code>equal</code> returns <code>true</code> if the two ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code> are identical when compared element-by-element, and otherwise returns <code>false</code>.

This version of <code>equal</code> returns <code>true</code> if and only if for every iterator <code>i</code> in <code>[first1, last1)</code>, <code>&#42;i == &#42;(first2 + (i - first1))</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>equal</code> to test two ranges for equality using the <code>thrust::host</code> execution policy:



```cpp
#include <thrust/equal.h>
#include <thrust/execution_policy.h>
...
int A1[7] = {3, 1, 4, 1, 5, 9, 3};
int A2[7] = {3, 1, 4, 2, 8, 5, 7};
...
bool result = thrust::equal(thrust::host, A1, A1 + 7, A2);

// result == false
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, and <code>InputIterator1's</code><code>value&#95;type</code> can be compared for equality with <code>InputIterator2's</code><code>value&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, and <code>InputIterator2's</code><code>value&#95;type</code> can be compared for equality with <code>InputIterator1's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 

**Returns**:
<code>true</code>, if the sequences are equal; <code>false</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/equal">https://en.cppreference.com/w/cpp/algorithm/equal</a>

<h3 id="function-equal">
Function <code>thrust::equal</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2&gt;</span>
<span>bool </span><span><b>equal</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2);</span></code>
<code>equal</code> returns <code>true</code> if the two ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code> are identical when compared element-by-element, and otherwise returns <code>false</code>.

This version of <code>equal</code> returns <code>true</code> if and only if for every iterator <code>i</code> in <code>[first1, last1)</code>, <code>&#42;i == &#42;(first2 + (i - first1))</code>.


The following code snippet demonstrates how to use <code>equal</code> to test two ranges for equality.



```cpp
#include <thrust/equal.h>
...
int A1[7] = {3, 1, 4, 1, 5, 9, 3};
int A2[7] = {3, 1, 4, 2, 8, 5, 7};
...
bool result = thrust::equal(A1, A1 + 7, A2);

// result == false
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, and <code>InputIterator1's</code><code>value&#95;type</code> can be compared for equality with <code>InputIterator2's</code><code>value&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, and <code>InputIterator2's</code><code>value&#95;type</code> can be compared for equality with <code>InputIterator1's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 

**Returns**:
<code>true</code>, if the sequences are equal; <code>false</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/equal">https://en.cppreference.com/w/cpp/algorithm/equal</a>

<h3 id="function-equal">
Function <code>thrust::equal</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ bool </span><span><b>equal</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>equal</code> returns <code>true</code> if the two ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code> are identical when compared element-by-element, and otherwise returns <code>false</code>.

This version of <code>equal</code> returns <code>true</code> if and only if for every iterator <code>i</code> in <code>[first1, last1)</code>, <code>binary&#95;pred(&#42;i, &#42;(first2 + (i - first1)))</code> is <code>true</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>equal</code> to compare the elements in two ranges modulo 2 using the <code>thrust::host</code> execution policy.



```cpp
#include <thrust/equal.h>
#include <thrust/execution_policy.h>
...

struct compare_modulo_two
{
  __host__ __device__
  bool operator()(int x, int y) const
  {
    return (x % 2) == (y % 2);
  }
};
...
int x[6] = {0, 2, 4, 6, 8, 10};
int y[6] = {1, 3, 5, 7, 9, 11};

bool result = thrust::equal(x, x + 6, y, compare_modulo_two());

// result is false
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>first&#95;argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 
* **`binary_pred`** Binary predicate used to test element equality. 

**Returns**:
<code>true</code>, if the sequences are equal; <code>false</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/equal">https://en.cppreference.com/w/cpp/algorithm/equal</a>

<h3 id="function-equal">
Function <code>thrust::equal</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>bool </span><span><b>equal</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>equal</code> returns <code>true</code> if the two ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code> are identical when compared element-by-element, and otherwise returns <code>false</code>.

This version of <code>equal</code> returns <code>true</code> if and only if for every iterator <code>i</code> in <code>[first1, last1)</code>, <code>binary&#95;pred(&#42;i, &#42;(first2 + (i - first1)))</code> is <code>true</code>.


The following code snippet demonstrates how to use <code>equal</code> to compare the elements in two ranges modulo 2.



```cpp
#include <thrust/equal.h>

struct compare_modulo_two
{
  __host__ __device__
  bool operator()(int x, int y) const
  {
    return (x % 2) == (y % 2);
  }
};
...
int x[6] = {0, 2, 4, 6, 8, 10};
int y[6] = {1, 3, 5, 7, 9, 11};

bool result = thrust::equal(x, x + 5, y, compare_modulo_two());

// result is true
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>first&#95;argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 
* **`binary_pred`** Binary predicate used to test element equality. 

**Returns**:
<code>true</code>, if the sequences are equal; <code>false</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/equal">https://en.cppreference.com/w/cpp/algorithm/equal</a>

<h3 id="function-thrust-prevent-macro-substitution">
Function <code>thrust::THRUST&#95;PREVENT&#95;MACRO&#95;SUBSTITUTION</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ T min </span><span><b>THRUST_PREVENT_MACRO_SUBSTITUTION</b>(const T & lhs,</span>
<span>&nbsp;&nbsp;const T & rhs,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span></code>
This version of <code>min</code> returns the smaller of two values, given a comparison operation. 
The following code snippet demonstrates how to use <code>min</code> to compute the smaller of two key-value objects.



```cpp
#include <thrust/extrema.h>
...
struct key_value
{
  int key;
  int value;
};

struct compare_key_value
{
  __host__ __device__
  bool operator()(key_value lhs, key_value rhs)
  {
    return lhs.key < rhs.key;
  }
};

...
key_value a = {13, 0};
key_value b = { 7, 1);

key_value smaller = thrust::min(a, b, compare_key_value());

// smaller is {7, 1}
```

**Note**:
Returns the first argument when the arguments are equivalent. 

**Template Parameters**:
* **`T`** is convertible to <code>BinaryPredicate's</code> first argument type and to its second argument type. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a>.

**Function Parameters**:
* **`lhs`** The first value to compare. 
* **`rhs`** The second value to compare. 
* **`comp`** A comparison operation. 

**Returns**:
The smaller element.

**See**:
max 

<h3 id="function-thrust-prevent-macro-substitution">
Function <code>thrust::THRUST&#95;PREVENT&#95;MACRO&#95;SUBSTITUTION</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T min </span><span><b>THRUST_PREVENT_MACRO_SUBSTITUTION</b>(const T & lhs,</span>
<span>&nbsp;&nbsp;const T & rhs);</span></code>
This version of <code>min</code> returns the smaller of two values. 
The following code snippet demonstrates how to use <code>min</code> to compute the smaller of two integers.



```cpp
#include <thrust/extrema.h>
...
int a = 13;
int b = 7;

int smaller = thrust::min(a, b);

// smaller is 7
```

**Note**:
Returns the first argument when the arguments are equivalent. 

**Template Parameters**:
**`T`**: is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`lhs`** The first value to compare. 
* **`rhs`** The second value to compare. 

**Returns**:
The smaller element.

**See**:
max 

<h3 id="function-thrust-prevent-macro-substitution">
Function <code>thrust::THRUST&#95;PREVENT&#95;MACRO&#95;SUBSTITUTION</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ T max </span><span><b>THRUST_PREVENT_MACRO_SUBSTITUTION</b>(const T & lhs,</span>
<span>&nbsp;&nbsp;const T & rhs,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span></code>
This version of <code>max</code> returns the larger of two values, given a comparison operation. 
The following code snippet demonstrates how to use <code>max</code> to compute the larger of two key-value objects.



```cpp
#include <thrust/extrema.h>
...
struct key_value
{
  int key;
  int value;
};

struct compare_key_value
{
  __host__ __device__
  bool operator()(key_value lhs, key_value rhs)
  {
    return lhs.key < rhs.key;
  }
};

...
key_value a = {13, 0};
key_value b = { 7, 1);

key_value larger = thrust::max(a, b, compare_key_value());

// larger is {13, 0}
```

**Note**:
Returns the first argument when the arguments are equivalent. 

**Template Parameters**:
* **`T`** is convertible to <code>BinaryPredicate's</code> first argument type and to its second argument type. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">BinaryPredicate</a>.

**Function Parameters**:
* **`lhs`** The first value to compare. 
* **`rhs`** The second value to compare. 
* **`comp`** A comparison operation. 

**Returns**:
The larger element.

**See**:
min 

<h3 id="function-thrust-prevent-macro-substitution">
Function <code>thrust::THRUST&#95;PREVENT&#95;MACRO&#95;SUBSTITUTION</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ T max </span><span><b>THRUST_PREVENT_MACRO_SUBSTITUTION</b>(const T & lhs,</span>
<span>&nbsp;&nbsp;const T & rhs);</span></code>
This version of <code>max</code> returns the larger of two values. 
The following code snippet demonstrates how to use <code>max</code> to compute the larger of two integers.



```cpp
#include <thrust/extrema.h>
...
int a = 13;
int b = 7;

int larger = thrust::min(a, b);

// larger is 13
```

**Note**:
Returns the first argument when the arguments are equivalent. 

**Template Parameters**:
**`T`**: is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`lhs`** The first value to compare. 
* **`rhs`** The second value to compare. 

**Returns**:
The larger element.

**See**:
min 

<h3 id="function-min-element">
Function <code>thrust::min&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>min_element</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>min&#95;element</code> finds the smallest element in the range <code>[first, last)</code>. It returns the first iterator <code>i</code> in <code>[first, last)</code> such that no other iterator in <code>[first, last)</code> points to a value smaller than <code>&#42;i</code>. The return value is <code>last</code> if and only if <code>[first, last)</code> is an empty range.

The two versions of <code>min&#95;element</code> differ in how they define whether one element is less than another. This version compares objects using <code>operator&lt;</code>. Specifically, this version of <code>min&#95;element</code> returns the first iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, last)</code>, <code>&#42;j &lt; &#42;i</code> is <code>false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/extrema.h>
#include <thrust/execution_policy.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int *result = thrust::min_element(thrust::host, data, data + 6);

// result is data + 1
// *result is 0
```

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
An iterator pointing to the smallest element of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/min_element">https://en.cppreference.com/w/cpp/algorithm/min_element</a>

<h3 id="function-min-element">
Function <code>thrust::min&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b>min_element</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>min&#95;element</code> finds the smallest element in the range <code>[first, last)</code>. It returns the first iterator <code>i</code> in <code>[first, last)</code> such that no other iterator in <code>[first, last)</code> points to a value smaller than <code>&#42;i</code>. The return value is <code>last</code> if and only if <code>[first, last)</code> is an empty range.

The two versions of <code>min&#95;element</code> differ in how they define whether one element is less than another. This version compares objects using <code>operator&lt;</code>. Specifically, this version of <code>min&#95;element</code> returns the first iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, last)</code>, <code>&#42;j &lt; &#42;i</code> is <code>false</code>.



```cpp
#include <thrust/extrema.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int *result = thrust::min_element(data, data + 6);

// result is data + 1
// *result is 0
```

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
An iterator pointing to the smallest element of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/min_element">https://en.cppreference.com/w/cpp/algorithm/min_element</a>

<h3 id="function-min-element">
Function <code>thrust::min&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>min_element</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span></code>
<code>min&#95;element</code> finds the smallest element in the range <code>[first, last)</code>. It returns the first iterator <code>i</code> in <code>[first, last)</code> such that no other iterator in <code>[first, last)</code> points to a value smaller than <code>&#42;i</code>. The return value is <code>last</code> if and only if <code>[first, last)</code> is an empty range.

The two versions of <code>min&#95;element</code> differ in how they define whether one element is less than another. This version compares objects using a function object <code>comp</code>. Specifically, this version of <code>min&#95;element</code> returns the first iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, last)</code>, <code>comp(&#42;j, &#42;i)</code> is <code>false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>min&#95;element</code> to find the smallest element of a collection of key-value pairs using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/extrema.h>
#include <thrust/execution_policy.h>
...

struct key_value
{
  int key;
  int value;
};

struct compare_key_value
{
  __host__ __device__
  bool operator()(key_value lhs, key_value rhs)
  {
    return lhs.key < rhs.key;
  }
};

...
key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

key_value *smallest = thrust::min_element(thrust::host, data, data + 4, compare_key_value());

// smallest == data + 1
// *smallest == {0,7}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to both <code>comp's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** A binary predicate used for comparison. 

**Returns**:
An iterator pointing to the smallest element of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/min_element">https://en.cppreference.com/w/cpp/algorithm/min_element</a>

<h3 id="function-min-element">
Function <code>thrust::min&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>ForwardIterator </span><span><b>min_element</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span></code>
<code>min&#95;element</code> finds the smallest element in the range <code>[first, last)</code>. It returns the first iterator <code>i</code> in <code>[first, last)</code> such that no other iterator in <code>[first, last)</code> points to a value smaller than <code>&#42;i</code>. The return value is <code>last</code> if and only if <code>[first, last)</code> is an empty range.

The two versions of <code>min&#95;element</code> differ in how they define whether one element is less than another. This version compares objects using a function object <code>comp</code>. Specifically, this version of <code>min&#95;element</code> returns the first iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, last)</code>, <code>comp(&#42;j, &#42;i)</code> is <code>false</code>.


The following code snippet demonstrates how to use <code>min&#95;element</code> to find the smallest element of a collection of key-value pairs.



```cpp
#include <thrust/extrema.h>

struct key_value
{
  int key;
  int value;
};

struct compare_key_value
{
  __host__ __device__
  bool operator()(key_value lhs, key_value rhs)
  {
    return lhs.key < rhs.key;
  }
};

...
key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

key_value *smallest = thrust::min_element(data, data + 4, compare_key_value());

// smallest == data + 1
// *smallest == {0,7}
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to both <code>comp's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** A binary predicate used for comparison. 

**Returns**:
An iterator pointing to the smallest element of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/min_element">https://en.cppreference.com/w/cpp/algorithm/min_element</a>

<h3 id="function-max-element">
Function <code>thrust::max&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>max_element</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>max&#95;element</code> finds the largest element in the range <code>[first, last)</code>. It returns the first iterator <code>i</code> in <code>[first, last)</code> such that no other iterator in <code>[first, last)</code> points to a value larger than <code>&#42;i</code>. The return value is <code>last</code> if and only if <code>[first, last)</code> is an empty range.

The two versions of <code>max&#95;element</code> differ in how they define whether one element is greater than another. This version compares objects using <code>operator&lt;</code>. Specifically, this version of <code>max&#95;element</code> returns the first iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, last)</code>, <code>&#42;i &lt; &#42;j</code> is <code>false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/extrema.h>
#include <thrust/execution_policy.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int *result = thrust::max_element(thrust::host, data, data + 6);

// *result == 3
```

**Template Parameters**:
* **`A`** Thrust backend system. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
An iterator pointing to the largest element of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/max_element">https://en.cppreference.com/w/cpp/algorithm/max_element</a>

<h3 id="function-max-element">
Function <code>thrust::max&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b>max_element</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>max&#95;element</code> finds the largest element in the range <code>[first, last)</code>. It returns the first iterator <code>i</code> in <code>[first, last)</code> such that no other iterator in <code>[first, last)</code> points to a value larger than <code>&#42;i</code>. The return value is <code>last</code> if and only if <code>[first, last)</code> is an empty range.

The two versions of <code>max&#95;element</code> differ in how they define whether one element is greater than another. This version compares objects using <code>operator&lt;</code>. Specifically, this version of <code>max&#95;element</code> returns the first iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, last)</code>, <code>&#42;i &lt; &#42;j</code> is <code>false</code>.



```cpp
#include <thrust/extrema.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int *result = thrust::max_element(data, data + 6);

// *result == 3
```

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
An iterator pointing to the largest element of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/max_element">https://en.cppreference.com/w/cpp/algorithm/max_element</a>

<h3 id="function-max-element">
Function <code>thrust::max&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>max_element</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span></code>
<code>max&#95;element</code> finds the largest element in the range <code>[first, last)</code>. It returns the first iterator <code>i</code> in <code>[first, last)</code> such that no other iterator in <code>[first, last)</code> points to a value larger than <code>&#42;i</code>. The return value is <code>last</code> if and only if <code>[first, last)</code> is an empty range.

The two versions of <code>max&#95;element</code> differ in how they define whether one element is less than another. This version compares objects using a function object <code>comp</code>. Specifically, this version of <code>max&#95;element</code> returns the first iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, last)</code>, <code>comp(&#42;i, &#42;j)</code> is <code>false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>max&#95;element</code> to find the largest element of a collection of key-value pairs using the <code>thrust::host</code> execution policy for parallelization.



```cpp
#include <thrust/extrema.h>
#include <thrust/execution_policy.h>
...

struct key_value
{
  int key;
  int value;
};

struct compare_key_value
{
  __host__ __device__
  bool operator()(key_value lhs, key_value rhs)
  {
    return lhs.key < rhs.key;
  }
};

...
key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

key_value *largest = thrust::max_element(thrust::host, data, data + 4, compare_key_value());

// largest == data + 3
// *largest == {6,1}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to both <code>comp's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** A binary predicate used for comparison. 

**Returns**:
An iterator pointing to the largest element of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/max_element">https://en.cppreference.com/w/cpp/algorithm/max_element</a>

<h3 id="function-max-element">
Function <code>thrust::max&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>ForwardIterator </span><span><b>max_element</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span></code>
<code>max&#95;element</code> finds the largest element in the range <code>[first, last)</code>. It returns the first iterator <code>i</code> in <code>[first, last)</code> such that no other iterator in <code>[first, last)</code> points to a value larger than <code>&#42;i</code>. The return value is <code>last</code> if and only if <code>[first, last)</code> is an empty range.

The two versions of <code>max&#95;element</code> differ in how they define whether one element is less than another. This version compares objects using a function object <code>comp</code>. Specifically, this version of <code>max&#95;element</code> returns the first iterator <code>i</code> in <code>[first, last)</code> such that, for every iterator <code>j</code> in <code>[first, last)</code>, <code>comp(&#42;i, &#42;j)</code> is <code>false</code>.


The following code snippet demonstrates how to use <code>max&#95;element</code> to find the largest element of a collection of key-value pairs.



```cpp
#include <thrust/extrema.h>

struct key_value
{
  int key;
  int value;
};

struct compare_key_value
{
  __host__ __device__
  bool operator()(key_value lhs, key_value rhs)
  {
    return lhs.key < rhs.key;
  }
};

...
key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

key_value *largest = thrust::max_element(data, data + 4, compare_key_value());

// largest == data + 3
// *largest == {6,1}
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to both <code>comp's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** A binary predicate used for comparison. 

**Returns**:
An iterator pointing to the largest element of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/max_element">https://en.cppreference.com/w/cpp/algorithm/max_element</a>

<h3 id="function-minmax-element">
Function <code>thrust::minmax&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b>minmax_element</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>minmax&#95;element</code> finds the smallest and largest elements in the range <code>[first, last)</code>. It returns a pair of iterators <code>(imin, imax)</code> where <code>imin</code> is the same iterator returned by <code>min&#95;element</code> and <code>imax</code> is the same iterator returned by <code>max&#95;element</code>. This function is potentially more efficient than separate calls to <code>min&#95;element</code> and <code>max&#95;element</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/extrema.h>
#include <thrust/execution_policy.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
thrust::pair<int *, int *> result = thrust::minmax_element(thrust::host, data, data + 6);

// result.first is data + 1
// result.second is data + 5
// *result.first is 0
// *result.second is 3
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
A pair of iterator pointing to the smallest and largest elements of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
* min_element 
* max_element 
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf</a>

<h3 id="function-minmax-element">
Function <code>thrust::minmax&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b>minmax_element</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>minmax&#95;element</code> finds the smallest and largest elements in the range <code>[first, last)</code>. It returns a pair of iterators <code>(imin, imax)</code> where <code>imin</code> is the same iterator returned by <code>min&#95;element</code> and <code>imax</code> is the same iterator returned by <code>max&#95;element</code>. This function is potentially more efficient than separate calls to <code>min&#95;element</code> and <code>max&#95;element</code>.



```cpp
#include <thrust/extrema.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
thrust::pair<int *, int *> result = thrust::minmax_element(data, data + 6);

// result.first is data + 1
// result.second is data + 5
// *result.first is 0
// *result.second is 3
```

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
A pair of iterator pointing to the smallest and largest elements of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
* min_element 
* max_element 
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf</a>

<h3 id="function-minmax-element">
Function <code>thrust::minmax&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b>minmax_element</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span></code>
<code>minmax&#95;element</code> finds the smallest and largest elements in the range <code>[first, last)</code>. It returns a pair of iterators <code>(imin, imax)</code> where <code>imin</code> is the same iterator returned by <code>min&#95;element</code> and <code>imax</code> is the same iterator returned by <code>max&#95;element</code>. This function is potentially more efficient than separate calls to <code>min&#95;element</code> and <code>max&#95;element</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>minmax&#95;element</code> to find the smallest and largest elements of a collection of key-value pairs using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/extrema.h>
#include <thrust/pair.h>
#include <thrust/execution_policy.h>
...

struct key_value
{
  int key;
  int value;
};

struct compare_key_value
{
  __host__ __device__
  bool operator()(key_value lhs, key_value rhs)
  {
    return lhs.key < rhs.key;
  }
};

...
key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

thrust::pair<key_value*,key_value*> extrema = thrust::minmax_element(thrust::host, data, data + 4, compare_key_value());

// extrema.first   == data + 1
// *extrema.first  == {0,7}
// extrema.second  == data + 3
// *extrema.second == {6,1}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to both <code>comp's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** A binary predicate used for comparison. 

**Returns**:
A pair of iterator pointing to the smallest and largest elements of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
* min_element 
* max_element 
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf</a>

<h3 id="function-minmax-element">
Function <code>thrust::minmax&#95;element</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator, ForwardIterator > </span><span><b>minmax_element</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate comp);</span></code>
<code>minmax&#95;element</code> finds the smallest and largest elements in the range <code>[first, last)</code>. It returns a pair of iterators <code>(imin, imax)</code> where <code>imin</code> is the same iterator returned by <code>min&#95;element</code> and <code>imax</code> is the same iterator returned by <code>max&#95;element</code>. This function is potentially more efficient than separate calls to <code>min&#95;element</code> and <code>max&#95;element</code>.


The following code snippet demonstrates how to use <code>minmax&#95;element</code> to find the smallest and largest elements of a collection of key-value pairs.



```cpp
#include <thrust/extrema.h>
#include <thrust/pair.h>

struct key_value
{
  int key;
  int value;
};

struct compare_key_value
{
  __host__ __device__
  bool operator()(key_value lhs, key_value rhs)
  {
    return lhs.key < rhs.key;
  }
};

...
key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

thrust::pair<key_value*,key_value*> extrema = thrust::minmax_element(data, data + 4, compare_key_value());

// extrema.first   == data + 1
// *extrema.first  == {0,7}
// extrema.second  == data + 3
// *extrema.second == {6,1}
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to both <code>comp's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** A binary predicate used for comparison. 

**Returns**:
A pair of iterator pointing to the smallest and largest elements of the range <code>[first, last)</code>, if it is not an empty range; <code>last</code>, otherwise.

**See**:
* min_element 
* max_element 
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf</a>

<h3 id="function-fill">
Function <code>thrust::fill</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b>fill</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>fill</code> assigns the value <code>value</code> to every element in the range <code>[first, last)</code>. That is, for every iterator <code>i</code> in <code>[first, last)</code>, it performs the assignment <code>&#42;i = value</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>fill</code> to set a <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">thrust::device_vector</a>'s elements to a given value using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/fill.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> v(4);
thrust::fill(thrust::device, v.begin(), v.end(), 137);

// v[0] == 137, v[1] == 137, v[2] == 137, v[3] == 137
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T's</code><code>value&#95;type</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`value`** The value to be copied.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/fill">https://en.cppreference.com/w/cpp/algorithm/fill</a>
* <code>fill&#95;n</code>
* <code>uninitialized&#95;fill</code>

<h3 id="function-fill">
Function <code>thrust::fill</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b>fill</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>fill</code> assigns the value <code>value</code> to every element in the range <code>[first, last)</code>. That is, for every iterator <code>i</code> in <code>[first, last)</code>, it performs the assignment <code>&#42;i = value</code>.


The following code snippet demonstrates how to use <code>fill</code> to set a <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">thrust::device_vector</a>'s elements to a given value.



```cpp
#include <thrust/fill.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> v(4);
thrust::fill(v.begin(), v.end(), 137);

// v[0] == 137, v[1] == 137, v[2] == 137, v[3] == 137
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T's</code><code>value&#95;type</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`value`** The value to be copied.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/fill">https://en.cppreference.com/w/cpp/algorithm/fill</a>
* <code>fill&#95;n</code>
* <code>uninitialized&#95;fill</code>

<h3 id="function-fill-n">
Function <code>thrust::fill&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>fill_n</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;OutputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>fill&#95;n</code> assigns the value <code>value</code> to every element in the range <code>[first, first+n)</code>. That is, for every iterator <code>i</code> in <code>[first, first+n)</code>, it performs the assignment <code>&#42;i = value</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>fill</code> to set a <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">thrust::device_vector</a>'s elements to a given value using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/fill.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> v(4);
thrust::fill_n(thrust::device, v.begin(), v.size(), 137);

// v[0] == 137, v[1] == 137, v[2] == 137, v[3] == 137
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`n`** The size of the sequence. 
* **`value`** The value to be copied. 

**Returns**:
<code>first + n</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/fill_n">https://en.cppreference.com/w/cpp/algorithm/fill_n</a>
* <code>fill</code>
* <code>uninitialized&#95;fill&#95;n</code>

<h3 id="function-fill-n">
Function <code>thrust::fill&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>fill_n</b>(OutputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>fill&#95;n</code> assigns the value <code>value</code> to every element in the range <code>[first, first+n)</code>. That is, for every iterator <code>i</code> in <code>[first, first+n)</code>, it performs the assignment <code>&#42;i = value</code>.


The following code snippet demonstrates how to use <code>fill</code> to set a <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">thrust::device_vector</a>'s elements to a given value.



```cpp
#include <thrust/fill.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> v(4);
thrust::fill_n(v.begin(), v.size(), 137);

// v[0] == 137, v[1] == 137, v[2] == 137, v[3] == 137
```

**Template Parameters**:
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`n`** The size of the sequence. 
* **`value`** The value to be copied. 

**Returns**:
<code>first + n</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/fill_n">https://en.cppreference.com/w/cpp/algorithm/fill_n</a>
* <code>fill</code>
* <code>uninitialized&#95;fill&#95;n</code>

<h3 id="function-find">
Function <code>thrust::find</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b>find</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>find</code> returns the first iterator <code>i</code> in the range <code>[first, last)</code> such that <code>&#42;i == value</code> or <code>last</code> if no such iterator exists.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/find.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> input(4);

input[0] = 0;
input[1] = 5;
input[2] = 3;
input[3] = 7;

thrust::device_vector<int>::iterator iter;

iter = thrust::find(thrust::device, input.begin(), input.end(), 3); // returns input.first() + 2
iter = thrust::find(thrust::device, input.begin(), input.end(), 5); // returns input.first() + 1
iter = thrust::find(thrust::device, input.begin(), input.end(), 9); // returns input.end()
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is equality comparable to type <code>T</code>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">EqualityComparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** Beginning of the sequence to search. 
* **`last`** End of the sequence to search. 
* **`value`** The value to find. 

**Returns**:
The first iterator <code>i</code> such that <code>&#42;i == value</code> or <code>last</code>.

**See**:
* find_if 
* mismatch 

<h3 id="function-find">
Function <code>thrust::find</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>InputIterator </span><span><b>find</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>find</code> returns the first iterator <code>i</code> in the range <code>[first, last)</code> such that <code>&#42;i == value</code> or <code>last</code> if no such iterator exists.



```cpp
#include <thrust/find.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> input(4);

input[0] = 0;
input[1] = 5;
input[2] = 3;
input[3] = 7;

thrust::device_vector<int>::iterator iter;

iter = thrust::find(input.begin(), input.end(), 3); // returns input.first() + 2
iter = thrust::find(input.begin(), input.end(), 5); // returns input.first() + 1
iter = thrust::find(input.begin(), input.end(), 9); // returns input.end()
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is equality comparable to type <code>T</code>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">EqualityComparable</a>.

**Function Parameters**:
* **`first`** Beginning of the sequence to search. 
* **`last`** End of the sequence to search. 
* **`value`** The value to find. 

**Returns**:
The first iterator <code>i</code> such that <code>&#42;i == value</code> or <code>last</code>.

**See**:
* find_if 
* mismatch 

<h3 id="function-find-if">
Function <code>thrust::find&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b>find_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>find&#95;if</code> returns the first iterator <code>i</code> in the range <code>[first, last)</code> such that <code>pred(&#42;i)</code> is <code>true</code> or <code>last</code> if no such iterator exists.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/find.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...

struct greater_than_four
{
  __host__ __device__
  bool operator()(int x)
  {
    return x > 4;
  }
};

struct greater_than_ten
{
  __host__ __device__
  bool operator()(int x)
  {
    return x > 10;
  }
};

...
thrust::device_vector<int> input(4);

input[0] = 0;
input[1] = 5;
input[2] = 3;
input[3] = 7;

thrust::device_vector<int>::iterator iter;

iter = thrust::find_if(thrust::device, input.begin(), input.end(), greater_than_four()); // returns input.first() + 1

iter = thrust::find_if(thrust::device, input.begin(), input.end(), greater_than_ten());  // returns input.end()
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** Beginning of the sequence to search. 
* **`last`** End of the sequence to search. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
The first iterator <code>i</code> such that <code>pred(&#42;i)</code> is <code>true</code>, or <code>last</code>.

**See**:
* find 
* find_if_not 
* mismatch 

<h3 id="function-find-if">
Function <code>thrust::find&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>InputIterator </span><span><b>find_if</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>find&#95;if</code> returns the first iterator <code>i</code> in the range <code>[first, last)</code> such that <code>pred(&#42;i)</code> is <code>true</code> or <code>last</code> if no such iterator exists.



```cpp
#include <thrust/find.h>
#include <thrust/device_vector.h>

struct greater_than_four
{
  __host__ __device__
  bool operator()(int x)
  {
    return x > 4;
  }
};

struct greater_than_ten
{
  __host__ __device__
  bool operator()(int x)
  {
    return x > 10;
  }
};

...
thrust::device_vector<int> input(4);

input[0] = 0;
input[1] = 5;
input[2] = 3;
input[3] = 7;

thrust::device_vector<int>::iterator iter;

iter = thrust::find_if(input.begin(), input.end(), greater_than_four()); // returns input.first() + 1

iter = thrust::find_if(input.begin(), input.end(), greater_than_ten());  // returns input.end()
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** Beginning of the sequence to search. 
* **`last`** End of the sequence to search. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
The first iterator <code>i</code> such that <code>pred(&#42;i)</code> is <code>true</code>, or <code>last</code>.

**See**:
* find 
* find_if_not 
* mismatch 

<h3 id="function-find-if-not">
Function <code>thrust::find&#95;if&#95;not</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b>find_if_not</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>find&#95;if&#95;not</code> returns the first iterator <code>i</code> in the range <code>[first, last)</code> such that <code>pred(&#42;i)</code> is <code>false</code> or <code>last</code> if no such iterator exists.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/find.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...

struct greater_than_four
{
  __host__ __device__
  bool operator()(int x)
  {
    return x > 4;
  }
};

struct greater_than_ten
{
  __host__ __device__
  bool operator()(int x)
  {
    return x > 10;
  }
};

...
thrust::device_vector<int> input(4);

input[0] = 0;
input[1] = 5;
input[2] = 3;
input[3] = 7;

thrust::device_vector<int>::iterator iter;

iter = thrust::find_if_not(thrust::device, input.begin(), input.end(), greater_than_four()); // returns input.first()

iter = thrust::find_if_not(thrust::device, input.begin(), input.end(), greater_than_ten());  // returns input.first()
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** Beginning of the sequence to search. 
* **`last`** End of the sequence to search. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
The first iterator <code>i</code> such that <code>pred(&#42;i)</code> is <code>false</code>, or <code>last</code>.

**See**:
* find 
* find_if 
* mismatch 

<h3 id="function-find-if-not">
Function <code>thrust::find&#95;if&#95;not</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>InputIterator </span><span><b>find_if_not</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>find&#95;if&#95;not</code> returns the first iterator <code>i</code> in the range <code>[first, last)</code> such that <code>pred(&#42;i)</code> is <code>false</code> or <code>last</code> if no such iterator exists.



```cpp
#include <thrust/find.h>
#include <thrust/device_vector.h>

struct greater_than_four
{
  __host__ __device__
  bool operator()(int x)
  {
    return x > 4;
  }
};

struct greater_than_ten
{
  __host__ __device__
  bool operator()(int x)
  {
    return x > 10;
  }
};

...
thrust::device_vector<int> input(4);

input[0] = 0;
input[1] = 5;
input[2] = 3;
input[3] = 7;

thrust::device_vector<int>::iterator iter;

iter = thrust::find_if_not(input.begin(), input.end(), greater_than_four()); // returns input.first()

iter = thrust::find_if_not(input.begin(), input.end(), greater_than_ten());  // returns input.first()
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** Beginning of the sequence to search. 
* **`last`** End of the sequence to search. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
The first iterator <code>i</code> such that <code>pred(&#42;i)</code> is <code>false</code>, or <code>last</code>.

**See**:
* find 
* find_if 
* mismatch 

<h3 id="function-for-each">
Function <code>thrust::for&#95;each</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b>for_each</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;UnaryFunction f);</span></code>
<code>for&#95;each</code> applies the function object <code>f</code> to each element in the range <code>[first, last)</code>; <code>f's</code> return value, if any, is ignored. Unlike the C++ Standard Template Library function <code>std::for&#95;each</code>, this version offers no guarantee on order of execution. For this reason, this version of <code>for&#95;each</code> does not return a copy of the function object.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>for&#95;each</code> to print the elements of a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">thrust::device&#95;vector</a></code> using the <code>thrust::device</code> parallelization policy:



```cpp
#include <thrust/for_each.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
#include <cstdio>
...

struct printf_functor
{
  __host__ __device__
  void operator()(int x)
  {
    // note that using printf in a __device__ function requires
    // code compiled for a GPU with compute capability 2.0 or
    // higher (nvcc --arch=sm_20)
    printf("%d\n", x);
  }
};
...
thrust::device_vector<int> d_vec(3);
d_vec[0] = 0; d_vec[1] = 1; d_vec[2] = 2;

thrust::for_each(thrust::device, d_vec.begin(), d_vec.end(), printf_functor());

// 0 1 2 is printed to standard output in some unspecified order
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a>, and <code>UnaryFunction</code> does not apply any non-constant operation through its argument.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`f`** The function object to apply to the range <code>[first, last)</code>. 

**Returns**:
last

**See**:
* for_each_n 
* <a href="https://en.cppreference.com/w/cpp/algorithm/for_each">https://en.cppreference.com/w/cpp/algorithm/for_each</a>

<h3 id="function-for-each-n">
Function <code>thrust::for&#95;each&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>__host__ __device__ InputIterator </span><span><b>for_each_n</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;UnaryFunction f);</span></code>
<code>for&#95;each&#95;n</code> applies the function object <code>f</code> to each element in the range <code>[first, first + n)</code>; <code>f's</code> return value, if any, is ignored. Unlike the C++ Standard Template Library function <code>std::for&#95;each</code>, this version offers no guarantee on order of execution.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>for&#95;each&#95;n</code> to print the elements of a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> using the <code>thrust::device</code> parallelization policy.



```cpp
#include <thrust/for_each.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
#include <cstdio>

struct printf_functor
{
  __host__ __device__
  void operator()(int x)
  {
    // note that using printf in a __device__ function requires
    // code compiled for a GPU with compute capability 2.0 or
    // higher (nvcc --arch=sm_20)
    printf("%d\n", x);
  }
};
...
thrust::device_vector<int> d_vec(3);
d_vec[0] = 0; d_vec[1] = 1; d_vec[2] = 2;

thrust::for_each_n(thrust::device, d_vec.begin(), d_vec.size(), printf_functor());

// 0 1 2 is printed to standard output in some unspecified order
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`Size`** is an integral type. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a>, and <code>UnaryFunction</code> does not apply any non-constant operation through its argument.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`n`** The size of the input sequence. 
* **`f`** The function object to apply to the range <code>[first, first + n)</code>. 

**Returns**:
<code>first + n</code>

**See**:
* for_each 
* <a href="https://en.cppreference.com/w/cpp/algorithm/for_each">https://en.cppreference.com/w/cpp/algorithm/for_each</a>

<h3 id="function-for-each">
Function <code>thrust::for&#95;each</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>InputIterator </span><span><b>for_each</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;UnaryFunction f);</span></code>
<code>for&#95;each</code> applies the function object <code>f</code> to each element in the range <code>[first, last)</code>; <code>f's</code> return value, if any, is ignored. Unlike the C++ Standard Template Library function <code>std::for&#95;each</code>, this version offers no guarantee on order of execution. For this reason, this version of <code>for&#95;each</code> does not return a copy of the function object.


The following code snippet demonstrates how to use <code>for&#95;each</code> to print the elements of a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code>.



```cpp
#include <thrust/for_each.h>
#include <thrust/device_vector.h>
#include <stdio.h>

struct printf_functor
{
  __host__ __device__
  void operator()(int x)
  {
    // note that using printf in a __device__ function requires
    // code compiled for a GPU with compute capability 2.0 or
    // higher (nvcc --arch=sm_20)
    printf("%d\n", x);
  }
};
...
thrust::device_vector<int> d_vec(3);
d_vec[0] = 0; d_vec[1] = 1; d_vec[2] = 2;

thrust::for_each(d_vec.begin(), d_vec.end(), printf_functor());

// 0 1 2 is printed to standard output in some unspecified order
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a>, and <code>UnaryFunction</code> does not apply any non-constant operation through its argument.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`f`** The function object to apply to the range <code>[first, last)</code>. 

**Returns**:
last

**See**:
* for_each_n 
* <a href="https://en.cppreference.com/w/cpp/algorithm/for_each">https://en.cppreference.com/w/cpp/algorithm/for_each</a>

<h3 id="function-for-each-n">
Function <code>thrust::for&#95;each&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>InputIterator </span><span><b>for_each_n</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;UnaryFunction f);</span></code>
<code>for&#95;each&#95;n</code> applies the function object <code>f</code> to each element in the range <code>[first, first + n)</code>; <code>f's</code> return value, if any, is ignored. Unlike the C++ Standard Template Library function <code>std::for&#95;each</code>, this version offers no guarantee on order of execution.


The following code snippet demonstrates how to use <code>for&#95;each&#95;n</code> to print the elements of a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code>.



```cpp
#include <thrust/for_each.h>
#include <thrust/device_vector.h>
#include <stdio.h>

struct printf_functor
{
  __host__ __device__
  void operator()(int x)
  {
    // note that using printf in a __device__ function requires
    // code compiled for a GPU with compute capability 2.0 or
    // higher (nvcc --arch=sm_20)
    printf("%d\n", x);
  }
};
...
thrust::device_vector<int> d_vec(3);
d_vec[0] = 0; d_vec[1] = 1; d_vec[2] = 2;

thrust::for_each_n(d_vec.begin(), d_vec.size(), printf_functor());

// 0 1 2 is printed to standard output in some unspecified order
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`Size`** is an integral type. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a>, and <code>UnaryFunction</code> does not apply any non-constant operation through its argument.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`n`** The size of the input sequence. 
* **`f`** The function object to apply to the range <code>[first, first + n)</code>. 

**Returns**:
<code>first + n</code>

**See**:
* for_each 
* <a href="https://en.cppreference.com/w/cpp/algorithm/for_each">https://en.cppreference.com/w/cpp/algorithm/for_each</a>

<h3 id="function-not1">
Function <code>thrust::not1</code>
</h3>

<code class="doxybook">
<span>template &lt;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1unary__negate.html">unary_negate</a>< Predicate > </span><span><b>not1</b>(const Predicate & pred);</span></code>
<code>not1</code> is a helper function to simplify the creation of Adaptable Predicates: it takes an Adaptable Predicate <code>pred</code> as an argument and returns a new Adaptable Predicate that represents the negation of <code>pred</code>. That is: if <code>pred</code> is an object of a type which models Adaptable Predicate, then the the type of the result <code>npred</code> of <code>not1(pred)</code> is also a model of Adaptable Predicate and <code>npred(x)</code> always returns the same value as <code>!pred(x)</code>.

**Template Parameters**:
**`Predicate`**: is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_negate">Adaptable Predicate</a>.

**Function Parameters**:
**`pred`**: The Adaptable Predicate to negate. 

**Returns**:
A new object, <code>npred</code> such that <code>npred(x)</code> always returns the same value as <code>!pred(x)</code>.

**See**:
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1unary__negate.html">unary_negate</a>
* not2 

<h3 id="function-not2">
Function <code>thrust::not2</code>
</h3>

<code class="doxybook">
<span>template &lt;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1binary__negate.html">binary_negate</a>< BinaryPredicate > </span><span><b>not2</b>(const BinaryPredicate & pred);</span></code>
<code>not2</code> is a helper function to simplify the creation of Adaptable Binary Predicates: it takes an Adaptable Binary Predicate <code>pred</code> as an argument and returns a new Adaptable Binary Predicate that represents the negation of <code>pred</code>. That is: if <code>pred</code> is an object of a type which models Adaptable Binary Predicate, then the the type of the result <code>npred</code> of <code>not2(pred)</code> is also a model of Adaptable Binary Predicate and <code>npred(x,y)</code> always returns the same value as <code>!pred(x,y)</code>.

**Template Parameters**:
**`Binary`**: Predicate is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/AdaptableBinaryPredicate">Adaptable Binary Predicate</a>.

**Function Parameters**:
**`pred`**: The Adaptable Binary Predicate to negate. 

**Returns**:
A new object, <code>npred</code> such that <code>npred(x,y)</code> always returns the same value as <code>!pred(x,y)</code>.

**See**:
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1binary__negate.html">binary_negate</a>
* not1 

<h3 id="function-gather">
Function <code>thrust::gather</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>gather</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator map_first,</span>
<span>&nbsp;&nbsp;InputIterator map_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>gather</code> copies elements from a source array into a destination range according to a map. For each input iterator <code>i</code> in the range <code>[map&#95;first, map&#95;last)</code>, the value <code>input&#95;first[&#42;i]</code> is assigned to <code>&#42;(result + (i - map&#95;first))</code>. <code>RandomAccessIterator</code> must permit random access.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>gather</code> to reorder a range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/gather.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
// mark even indices with a 1; odd indices with a 0
int values[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
thrust::device_vector<int> d_values(values, values + 10);

// gather all even indices into the first half of the range
// and odd indices to the last half of the range
int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
thrust::device_vector<int> d_map(map, map + 10);

thrust::device_vector<int> d_output(10);
thrust::gather(thrust::device,
               d_map.begin(), d_map.end(),
               d_values.begin(),
               d_output.begin());
// d_output is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
```

**Remark**:
<code>gather</code> is the inverse of thrust::scatter.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a> and <code>RandomAccessIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`map_first`** Beginning of the range of gather locations. 
* **`map_last`** End of the range of gather locations. 
* **`input_first`** Beginning of the source range. 
* **`result`** Beginning of the destination range.

**Preconditions**:
* The range <code>[map&#95;first, map&#95;last)</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The input data shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>.

<h3 id="function-gather">
Function <code>thrust::gather</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>gather</b>(InputIterator map_first,</span>
<span>&nbsp;&nbsp;InputIterator map_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>gather</code> copies elements from a source array into a destination range according to a map. For each input iterator <code>i</code> in the range <code>[map&#95;first, map&#95;last)</code>, the value <code>input&#95;first[&#42;i]</code> is assigned to <code>&#42;(result + (i - map&#95;first))</code>. <code>RandomAccessIterator</code> must permit random access.


The following code snippet demonstrates how to use <code>gather</code> to reorder a range.



```cpp
#include <thrust/gather.h>
#include <thrust/device_vector.h>
...
// mark even indices with a 1; odd indices with a 0
int values[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
thrust::device_vector<int> d_values(values, values + 10);

// gather all even indices into the first half of the range
// and odd indices to the last half of the range
int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
thrust::device_vector<int> d_map(map, map + 10);

thrust::device_vector<int> d_output(10);
thrust::gather(d_map.begin(), d_map.end(),
               d_values.begin(),
               d_output.begin());
// d_output is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
```

**Remark**:
<code>gather</code> is the inverse of thrust::scatter.

**Template Parameters**:
* **`InputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a> and <code>RandomAccessIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`map_first`** Beginning of the range of gather locations. 
* **`map_last`** End of the range of gather locations. 
* **`input_first`** Beginning of the source range. 
* **`result`** Beginning of the destination range.

**Preconditions**:
* The range <code>[map&#95;first, map&#95;last)</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The input data shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>.

<h3 id="function-gather-if">
Function <code>thrust::gather&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>gather_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 map_first,</span>
<span>&nbsp;&nbsp;InputIterator1 map_last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>gather&#95;if</code> conditionally copies elements from a source array into a destination range according to a map. For each input iterator <code>i</code> in the range <code>[map&#95;first, map&#95;last)</code>, such that the value of <code>&#42;(stencil + (i - map&#95;first))</code> is <code>true</code>, the value <code>input&#95;first[&#42;i]</code> is assigned to <code>&#42;(result + (i - map&#95;first))</code>. <code>RandomAccessIterator</code> must permit random access.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>gather&#95;if</code> to gather selected values from an input range using the <code>thrust::device</code> execution policy:



```cpp
#include <thrust/gather.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...

int values[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
thrust::device_vector<int> d_values(values, values + 10);

// select elements at even-indexed locations
int stencil[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
thrust::device_vector<int> d_stencil(stencil, stencil + 10);

// map all even indices into the first half of the range
// and odd indices to the last half of the range
int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
thrust::device_vector<int> d_map(map, map + 10);

thrust::device_vector<int> d_output(10, 7);
thrust::gather_if(thrust::device,
                  d_map.begin(), d_map.end(),
                  d_stencil.begin(),
                  d_values.begin(),
                  d_output.begin());
// d_output is now {0, 7, 4, 7, 8, 7, 3, 7, 7, 7}
```

**Remark**:
<code>gather&#95;if</code> is the inverse of <code>scatter&#95;if</code>.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>bool</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a> and <code>RandomAccessIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`map_first`** Beginning of the range of gather locations. 
* **`map_last`** End of the range of gather locations. 
* **`stencil`** Beginning of the range of predicate values. 
* **`input_first`** Beginning of the source range. 
* **`result`** Beginning of the destination range.

**Preconditions**:
* The range <code>[map&#95;first, map&#95;last)</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The range <code>[stencil, stencil + (map&#95;last - map&#95;first))</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The input data shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>.

<h3 id="function-gather-if">
Function <code>thrust::gather&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>gather_if</b>(InputIterator1 map_first,</span>
<span>&nbsp;&nbsp;InputIterator1 map_last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>gather&#95;if</code> conditionally copies elements from a source array into a destination range according to a map. For each input iterator <code>i</code> in the range <code>[map&#95;first, map&#95;last)</code>, such that the value of <code>&#42;(stencil + (i - map&#95;first))</code> is <code>true</code>, the value <code>input&#95;first[&#42;i]</code> is assigned to <code>&#42;(result + (i - map&#95;first))</code>. <code>RandomAccessIterator</code> must permit random access.


The following code snippet demonstrates how to use <code>gather&#95;if</code> to gather selected values from an input range.



```cpp
#include <thrust/gather.h>
#include <thrust/device_vector.h>
...

int values[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
thrust::device_vector<int> d_values(values, values + 10);

// select elements at even-indexed locations
int stencil[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
thrust::device_vector<int> d_stencil(stencil, stencil + 10);

// map all even indices into the first half of the range
// and odd indices to the last half of the range
int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
thrust::device_vector<int> d_map(map, map + 10);

thrust::device_vector<int> d_output(10, 7);
thrust::gather_if(d_map.begin(), d_map.end(),
                  d_stencil.begin(),
                  d_values.begin(),
                  d_output.begin());
// d_output is now {0, 7, 4, 7, 8, 7, 3, 7, 7, 7}
```

**Remark**:
<code>gather&#95;if</code> is the inverse of <code>scatter&#95;if</code>.

**Template Parameters**:
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>bool</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a> and <code>RandomAccessIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`map_first`** Beginning of the range of gather locations. 
* **`map_last`** End of the range of gather locations. 
* **`stencil`** Beginning of the range of predicate values. 
* **`input_first`** Beginning of the source range. 
* **`result`** Beginning of the destination range.

**Preconditions**:
* The range <code>[map&#95;first, map&#95;last)</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The range <code>[stencil, stencil + (map&#95;last - map&#95;first))</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The input data shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>.

<h3 id="function-gather-if">
Function <code>thrust::gather&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>gather_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 map_first,</span>
<span>&nbsp;&nbsp;InputIterator1 map_last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>gather&#95;if</code> conditionally copies elements from a source array into a destination range according to a map. For each input iterator <code>i</code> in the range <code>[map&#95;first, map&#95;last)</code> such that the value of <code>pred(&#42;(stencil + (i - map&#95;first)))</code> is <code>true</code>, the value <code>input&#95;first[&#42;i]</code> is assigned to <code>&#42;(result + (i - map&#95;first))</code>. <code>RandomAccessIterator</code> must permit random access.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>gather&#95;if</code> to gather selected values from an input range based on an arbitrary selection function using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/gather.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>

struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...

int values[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
thrust::device_vector<int> d_values(values, values + 10);

// we will select an element when our stencil is even
int stencil[10] = {0, 3, 4, 1, 4, 1, 2, 7, 8, 9};
thrust::device_vector<int> d_stencil(stencil, stencil + 10);

// map all even indices into the first half of the range
// and odd indices to the last half of the range
int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
thrust::device_vector<int> d_map(map, map + 10);

thrust::device_vector<int> d_output(10, 7);
thrust::gather_if(thrust::device,
                  d_map.begin(), d_map.end(),
                  d_stencil.begin(),
                  d_values.begin(),
                  d_output.begin(),
                  is_even());
// d_output is now {0, 7, 4, 7, 8, 7, 3, 7, 7, 7}
```

**Remark**:
<code>gather&#95;if</code> is the inverse of <code>scatter&#95;if</code>.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a> and <code>RandomAccessIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`map_first`** Beginning of the range of gather locations. 
* **`map_last`** End of the range of gather locations. 
* **`stencil`** Beginning of the range of predicate values. 
* **`input_first`** Beginning of the source range. 
* **`result`** Beginning of the destination range. 
* **`pred`** Predicate to apply to the stencil values.

**Preconditions**:
* The range <code>[map&#95;first, map&#95;last)</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The range <code>[stencil, stencil + (map&#95;last - map&#95;first))</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The input data shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>.

<h3 id="function-gather-if">
Function <code>thrust::gather&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b>gather_if</b>(InputIterator1 map_first,</span>
<span>&nbsp;&nbsp;InputIterator1 map_last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator input_first,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>gather&#95;if</code> conditionally copies elements from a source array into a destination range according to a map. For each input iterator <code>i</code> in the range <code>[map&#95;first, map&#95;last)</code> such that the value of <code>pred(&#42;(stencil + (i - map&#95;first)))</code> is <code>true</code>, the value <code>input&#95;first[&#42;i]</code> is assigned to <code>&#42;(result + (i - map&#95;first))</code>. <code>RandomAccessIterator</code> must permit random access.


The following code snippet demonstrates how to use <code>gather&#95;if</code> to gather selected values from an input range based on an arbitrary selection function.



```cpp
#include <thrust/gather.h>
#include <thrust/device_vector.h>

struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...

int values[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
thrust::device_vector<int> d_values(values, values + 10);

// we will select an element when our stencil is even
int stencil[10] = {0, 3, 4, 1, 4, 1, 2, 7, 8, 9};
thrust::device_vector<int> d_stencil(stencil, stencil + 10);

// map all even indices into the first half of the range
// and odd indices to the last half of the range
int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
thrust::device_vector<int> d_map(map, map + 10);

thrust::device_vector<int> d_output(10, 7);
thrust::gather_if(d_map.begin(), d_map.end(),
                  d_stencil.begin(),
                  d_values.begin(),
                  d_output.begin(),
                  is_even());
// d_output is now {0, 7, 4, 7, 8, 7, 3, 7, 7, 7}
```

**Remark**:
<code>gather&#95;if</code> is the inverse of <code>scatter&#95;if</code>.

**Template Parameters**:
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a> and <code>RandomAccessIterator's</code><code>value&#95;type</code> must be convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`map_first`** Beginning of the range of gather locations. 
* **`map_last`** End of the range of gather locations. 
* **`stencil`** Beginning of the range of predicate values. 
* **`input_first`** Beginning of the source range. 
* **`result`** Beginning of the destination range. 
* **`pred`** Predicate to apply to the stencil values.

**Preconditions**:
* The range <code>[map&#95;first, map&#95;last)</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The range <code>[stencil, stencil + (map&#95;last - map&#95;first))</code> shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>. 
* The input data shall not overlap the range <code>[result, result + (map&#95;last - map&#95;first))</code>.

<h3 id="function-generate">
Function <code>thrust::generate</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Generator&gt;</span>
<span>__host__ __device__ void </span><span><b>generate</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Generator gen);</span></code>
<code>generate</code> assigns the result of invoking <code>gen</code>, a function object that takes no arguments, to each element in the range <code>[first,last)</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to fill a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host&#95;vector</a></code> with random numbers, using the standard C library function <code>rand</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/generate.h>
#include <thrust/host_vector.h>
#include <thrust/execution_policy.h>
#include <cstdlib>
...
thrust::host_vector<int> v(10);
srand(13);
thrust::generate(thrust::host, v.begin(), v.end(), rand);

// the elements of v are now pseudo-random numbers
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`Generator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional">Generator</a>, and <code>Generator's</code><code>result&#95;type</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element in the range of interest. 
* **`last`** The last element in the range of interest. 
* **`gen`** A function argument, taking no parameters, used to generate values to assign to elements in the range <code>[first,last)</code>.

**See**:
* generate_n 
* <a href="https://en.cppreference.com/w/cpp/algorithm/generate">https://en.cppreference.com/w/cpp/algorithm/generate</a>

<h3 id="function-generate">
Function <code>thrust::generate</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Generator&gt;</span>
<span>void </span><span><b>generate</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Generator gen);</span></code>
<code>generate</code> assigns the result of invoking <code>gen</code>, a function object that takes no arguments, to each element in the range <code>[first,last)</code>.


The following code snippet demonstrates how to fill a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host&#95;vector</a></code> with random numbers, using the standard C library function <code>rand</code>.



```cpp
#include <thrust/generate.h>
#include <thrust/host_vector.h>
#include <thrust/execution_policy.h>
#include <cstdlib>
...
thrust::host_vector<int> v(10);
srand(13);
thrust::generate(v.begin(), v.end(), rand);

// the elements of v are now pseudo-random numbers
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`Generator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional">Generator</a>, and <code>Generator's</code><code>result&#95;type</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The first element in the range of interest. 
* **`last`** The last element in the range of interest. 
* **`gen`** A function argument, taking no parameters, used to generate values to assign to elements in the range <code>[first,last)</code>.

**See**:
* generate_n 
* <a href="https://en.cppreference.com/w/cpp/algorithm/generate">https://en.cppreference.com/w/cpp/algorithm/generate</a>

<h3 id="function-generate-n">
Function <code>thrust::generate&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename Generator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>generate_n</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;OutputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;Generator gen);</span></code>
<code>generate&#95;n</code> assigns the result of invoking <code>gen</code>, a function object that takes no arguments, to each element in the range <code>[first,first + n)</code>. The return value is <code>first + n</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to fill a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host&#95;vector</a></code> with random numbers, using the standard C library function <code>rand</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/generate.h>
#include <thrust/host_vector.h>
#include <thrust/execution_policy.h>
#include <cstdlib>
...
thrust::host_vector<int> v(10);
srand(13);
thrust::generate_n(thrust::host, v.begin(), 10, rand);

// the elements of v are now pseudo-random numbers
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Size`** is an integral type (either signed or unsigned). 
* **`Generator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional">Generator</a>, and <code>Generator's</code><code>result&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element in the range of interest. 
* **`n`** The size of the range of interest. 
* **`gen`** A function argument, taking no parameters, used to generate values to assign to elements in the range <code>[first,first + n)</code>.

**See**:
* generate 
* <a href="https://en.cppreference.com/w/cpp/algorithm/generate">https://en.cppreference.com/w/cpp/algorithm/generate</a>

<h3 id="function-generate-n">
Function <code>thrust::generate&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename Generator&gt;</span>
<span>OutputIterator </span><span><b>generate_n</b>(OutputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;Generator gen);</span></code>
<code>generate&#95;n</code> assigns the result of invoking <code>gen</code>, a function object that takes no arguments, to each element in the range <code>[first,first + n)</code>. The return value is <code>first + n</code>.


The following code snippet demonstrates how to fill a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host&#95;vector</a></code> with random numbers, using the standard C library function <code>rand</code>.



```cpp
#include <thrust/generate.h>
#include <thrust/host_vector.h>
#include <stdlib.h>
...
thrust::host_vector<int> v(10);
srand(13);
thrust::generate_n(v.begin(), 10, rand);

// the elements of v are now pseudo-random numbers
```

**Template Parameters**:
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Size`** is an integral type (either signed or unsigned). 
* **`Generator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional">Generator</a>, and <code>Generator's</code><code>result&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>.

**Function Parameters**:
* **`first`** The first element in the range of interest. 
* **`n`** The size of the range of interest. 
* **`gen`** A function argument, taking no parameters, used to generate values to assign to elements in the range <code>[first,first + n)</code>.

**See**:
* generate 
* <a href="https://en.cppreference.com/w/cpp/algorithm/generate">https://en.cppreference.com/w/cpp/algorithm/generate</a>

<h3 id="function-swap">
Function <code>thrust::swap</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename Alloc&gt;</span>
<span>void </span><span><b>swap</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host_vector</a>< T, Alloc > & a,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host_vector</a>< T, Alloc > & b);</span></code>
Exchanges the values of two vectors. <code>x</code> The first <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host&#95;vector</a></code> of interest. <code>y</code> The second <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1host__vector.html">host&#95;vector</a></code> of interest. 

<h3 id="function-inner-product">
Function <code>thrust::inner&#95;product</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputType&gt;</span>
<span>__host__ __device__ OutputType </span><span><b>inner_product</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputType init);</span></code>
<code>inner&#95;product</code> calculates an inner product of the ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code>.

Specifically, this version of <code>inner&#95;product</code> computes the sum <code>init + (&#42;first1 &#42; &#42;first2) + (&#42;(first1+1) &#42; &#42;(first2+1)) + ... </code>

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code demonstrates how to use <code>inner&#95;product</code> to compute the dot product of two vectors using the <code>thrust::host</code> execution policy for parallelization.



```cpp
#include <thrust/inner_product.h>
#include <thrust/execution_policy.h>
...
float vec1[3] = {1.0f, 2.0f, 5.0f};
float vec2[3] = {4.0f, 1.0f, 5.0f};

float result = thrust::inner_product(thrust::host, vec1, vec1 + 3, vec2, 0.0f);

// result == 31.0f
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputType`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and if <code>x</code> is an object of type <code>OutputType</code>, and <code>y</code> is an object of <code>InputIterator1's</code><code>value&#95;type</code>, and <code>z</code> is an object of <code>InputIterator2's</code><code>value&#95;type</code>, then <code>x + y &#42; z</code> is defined and is convertible to <code>OutputType</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 
* **`init`** Initial value of the result. 

**Returns**:
The inner product of sequences <code>[first1, last1)</code> and <code>[first2, last2)</code> plus <code>init</code>.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/inner_product">https://en.cppreference.com/w/cpp/algorithm/inner_product</a>

<h3 id="function-inner-product">
Function <code>thrust::inner&#95;product</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputType&gt;</span>
<span>OutputType </span><span><b>inner_product</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputType init);</span></code>
<code>inner&#95;product</code> calculates an inner product of the ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code>.

Specifically, this version of <code>inner&#95;product</code> computes the sum <code>init + (&#42;first1 &#42; &#42;first2) + (&#42;(first1+1) &#42; &#42;(first2+1)) + ... </code>

Unlike the C++ Standard Template Library function <code>std::inner&#95;product</code>, this version offers no guarantee on order of execution.


The following code demonstrates how to use <code>inner&#95;product</code> to compute the dot product of two vectors.



```cpp
#include <thrust/inner_product.h>
...
float vec1[3] = {1.0f, 2.0f, 5.0f};
float vec2[3] = {4.0f, 1.0f, 5.0f};

float result = thrust::inner_product(vec1, vec1 + 3, vec2, 0.0f);

// result == 31.0f
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputType`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and if <code>x</code> is an object of type <code>OutputType</code>, and <code>y</code> is an object of <code>InputIterator1's</code><code>value&#95;type</code>, and <code>z</code> is an object of <code>InputIterator2's</code><code>value&#95;type</code>, then <code>x + y &#42; z</code> is defined and is convertible to <code>OutputType</code>.

**Function Parameters**:
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 
* **`init`** Initial value of the result. 

**Returns**:
The inner product of sequences <code>[first1, last1)</code> and <code>[first2, last2)</code> plus <code>init</code>.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/inner_product">https://en.cppreference.com/w/cpp/algorithm/inner_product</a>

<h3 id="function-inner-product">
Function <code>thrust::inner&#95;product</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputType,</span>
<span>&nbsp;&nbsp;typename BinaryFunction1,</span>
<span>&nbsp;&nbsp;typename BinaryFunction2&gt;</span>
<span>__host__ __device__ OutputType </span><span><b>inner_product</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputType init,</span>
<span>&nbsp;&nbsp;BinaryFunction1 binary_op1,</span>
<span>&nbsp;&nbsp;BinaryFunction2 binary_op2);</span></code>
<code>inner&#95;product</code> calculates an inner product of the ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code>.

This version of <code>inner&#95;product</code> is identical to the first, except that is uses two user-supplied function objects instead of <code>operator+</code> and <code>operator&#42;</code>.

Specifically, this version of <code>inner&#95;product</code> computes the sum <code>binary&#95;op1( init, binary&#95;op2(&#42;first1, &#42;first2) ), ... </code>

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/inner_product.h>
#include <thrust/execution_policy.h>
...
float vec1[3] = {1.0f, 2.0f, 5.0f};
float vec2[3] = {4.0f, 1.0f, 5.0f};

float init = 0.0f;
thrust::plus<float>       binary_op1;
thrust::multiplies<float> binary_op2;

float result = thrust::inner_product(thrust::host, vec1, vec1 + 3, vec2, init, binary_op1, binary_op2);

// result == 31.0f
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction2's</code><code>first&#95;argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction2's</code><code>second&#95;argument&#95;type</code>. 
* **`OutputType`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>OutputType</code> is convertible to <code>BinaryFunction1's</code><code>first&#95;argument&#95;type</code>. 
* **`BinaryFunction1`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a>, and <code>BinaryFunction1's</code><code>return&#95;type</code> is convertible to <code>OutputType</code>. 
* **`BinaryFunction2`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a>, and <code>BinaryFunction2's</code><code>return&#95;type</code> is convertible to <code>BinaryFunction1's</code><code>second&#95;argument&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 
* **`init`** Initial value of the result. 
* **`binary_op1`** Generalized addition operation. 
* **`binary_op2`** Generalized multiplication operation. 

**Returns**:
The inner product of sequences <code>[first1, last1)</code> and <code>[first2, last2)</code>.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/inner_product">https://en.cppreference.com/w/cpp/algorithm/inner_product</a>

<h3 id="function-inner-product">
Function <code>thrust::inner&#95;product</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputType,</span>
<span>&nbsp;&nbsp;typename BinaryFunction1,</span>
<span>&nbsp;&nbsp;typename BinaryFunction2&gt;</span>
<span>OutputType </span><span><b>inner_product</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputType init,</span>
<span>&nbsp;&nbsp;BinaryFunction1 binary_op1,</span>
<span>&nbsp;&nbsp;BinaryFunction2 binary_op2);</span></code>
<code>inner&#95;product</code> calculates an inner product of the ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code>.

This version of <code>inner&#95;product</code> is identical to the first, except that is uses two user-supplied function objects instead of <code>operator+</code> and <code>operator&#42;</code>.

Specifically, this version of <code>inner&#95;product</code> computes the sum <code>binary&#95;op1( init, binary&#95;op2(&#42;first1, &#42;first2) ), ... </code>

Unlike the C++ Standard Template Library function <code>std::inner&#95;product</code>, this version offers no guarantee on order of execution.



```cpp
#include <thrust/inner_product.h>
...
float vec1[3] = {1.0f, 2.0f, 5.0f};
float vec2[3] = {4.0f, 1.0f, 5.0f};

float init = 0.0f;
thrust::plus<float>       binary_op1;
thrust::multiplies<float> binary_op2;

float result = thrust::inner_product(vec1, vec1 + 3, vec2, init, binary_op1, binary_op2);

// result == 31.0f
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction2's</code><code>first&#95;argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction2's</code><code>second&#95;argument&#95;type</code>. 
* **`OutputType`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>OutputType</code> is convertible to <code>BinaryFunction1's</code><code>first&#95;argument&#95;type</code>. 
* **`BinaryFunction1`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a>, and <code>BinaryFunction1's</code><code>return&#95;type</code> is convertible to <code>OutputType</code>. 
* **`BinaryFunction2`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a>, and <code>BinaryFunction2's</code><code>return&#95;type</code> is convertible to <code>BinaryFunction1's</code><code>second&#95;argument&#95;type</code>.

**Function Parameters**:
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 
* **`init`** Initial value of the result. 
* **`binary_op1`** Generalized addition operation. 
* **`binary_op2`** Generalized multiplication operation. 

**Returns**:
The inner product of sequences <code>[first1, last1)</code> and <code>[first2, last2)</code>.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/inner_product">https://en.cppreference.com/w/cpp/algorithm/inner_product</a>

<h3 id="function-make-constant-iterator">
Function <code>thrust::make&#95;constant&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ValueT,</span>
<span>&nbsp;&nbsp;typename IndexT&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant_iterator</a>< ValueT, IndexT > </span><span><b>make_constant_iterator</b>(ValueT x,</span>
<span>&nbsp;&nbsp;IndexT i = int());</span></code>
This version of <code>make&#95;constant&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a></code> from values given for both value and index. The type of <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a></code> may be inferred by the compiler from the types of its parameters.

**Function Parameters**:
* **`x`** The value of the returned <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a>'s</code> constant value. 
* **`i`** The index of the returned <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a></code> within a sequence. The type of this parameter defaults to <code>int</code>. In the default case, the value of this parameter is <code>0</code>.

**Returns**:
A new <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a></code> with constant value & index as given by <code>x</code> & <code>i</code>.

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant_iterator</a>

<h3 id="function-make-constant-iterator">
Function <code>thrust::make&#95;constant&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename V&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant_iterator</a>< V > </span><span><b>make_constant_iterator</b>(V x);</span></code>
This version of <code>make&#95;constant&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a></code> using only a parameter for the desired constant value. The value of the returned <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a>'s</code> index is set to <code>0</code>.

**Function Parameters**:
**`x`**: The value of the returned <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a>'s</code> constant value. 

**Returns**:
A new <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant&#95;iterator</a></code> with constant value equal to <code>x</code> and index equal to <code>0</code>. 

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant_iterator</a>

<h3 id="function-make-counting-iterator">
Function <code>thrust::make&#95;counting&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename Incrementable&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1counting__iterator.html">counting_iterator</a>< Incrementable > </span><span><b>make_counting_iterator</b>(Incrementable x);</span></code>
<code>make&#95;counting&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1counting__iterator.html">counting&#95;iterator</a></code> using an initial value for its <code>Incrementable</code> counter.

**Function Parameters**:
**`x`**: The initial value of the new <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1counting__iterator.html">counting&#95;iterator</a>'s</code> counter. 

**Returns**:
A new <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1counting__iterator.html">counting&#95;iterator</a></code> whose counter has been initialized to <code>x</code>. 

<h3 id="function-make-discard-iterator">
Function <code>thrust::make&#95;discard&#95;iterator</code>
</h3>

<code class="doxybook">
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1discard__iterator.html">discard_iterator</a> </span><span><b>make_discard_iterator</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1discard__iterator.html">discard_iterator</a><>::difference_type i = discard&#95;iterator&lt;&gt;::difference&#95;type(0));</span></code>
<code>make&#95;discard&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1discard__iterator.html">discard&#95;iterator</a></code> from an optional index parameter.

**Function Parameters**:
**`i`**: The index of the returned <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1discard__iterator.html">discard&#95;iterator</a></code> within a range. In the default case, the value of this parameter is <code>0</code>.

**Returns**:
A new <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1discard__iterator.html">discard&#95;iterator</a></code> with index as given by <code>i</code>.

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1constant__iterator.html">constant_iterator</a>

<h3 id="function-make-permutation-iterator">
Function <code>thrust::make&#95;permutation&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ElementIterator,</span>
<span>&nbsp;&nbsp;typename IndexIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1permutation__iterator.html">permutation_iterator</a>< ElementIterator, IndexIterator > </span><span><b>make_permutation_iterator</b>(ElementIterator e,</span>
<span>&nbsp;&nbsp;IndexIterator i);</span></code>
<code>make&#95;permutation&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1permutation__iterator.html">permutation&#95;iterator</a></code> from an <code>ElementIterator</code> pointing to a range of elements to "permute" and an <code>IndexIterator</code> pointing to a range of indices defining an indexing scheme on the values.

**Function Parameters**:
* **`e`** An <code>ElementIterator</code> pointing to a range of values. 
* **`i`** An <code>IndexIterator</code> pointing to an indexing scheme to use on <code>e</code>. 

**Returns**:
A new <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1permutation__iterator.html">permutation&#95;iterator</a></code> which permutes the range <code>e</code> by <code>i</code>. 

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1permutation__iterator.html">permutation_iterator</a>

<h3 id="function-make-reverse-iterator">
Function <code>thrust::make&#95;reverse&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename BidirectionalIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">reverse_iterator</a>< BidirectionalIterator > </span><span><b>make_reverse_iterator</b>(BidirectionalIterator x);</span></code>
<code>make&#95;reverse&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">reverse&#95;iterator</a></code> from a <code>BidirectionalIterator</code> pointing to a range of elements to reverse.

**Function Parameters**:
**`x`**: A <code>BidirectionalIterator</code> pointing to a range to reverse. 

**Returns**:
A new <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">reverse&#95;iterator</a></code> which reverses the range <code>x</code>. 

<h3 id="function-make-transform-input-output-iterator">
Function <code>thrust::make&#95;transform&#95;input&#95;output&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputFunction,</span>
<span>&nbsp;&nbsp;typename OutputFunction,</span>
<span>&nbsp;&nbsp;typename Iterator&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__input__output__iterator.html">transform_input_output_iterator</a>< InputFunction, OutputFunction, Iterator > __host__ __device__ </span><span><b>make_transform_input_output_iterator</b>(Iterator io,</span>
<span>&nbsp;&nbsp;InputFunction input_function,</span>
<span>&nbsp;&nbsp;OutputFunction output_function);</span></code>
<code>make&#95;transform&#95;input&#95;output&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__input__output__iterator.html">transform&#95;input&#95;output&#95;iterator</a></code> from an <code>Iterator</code> a <code>InputFunction</code> and a <code>OutputFunction</code>

**Function Parameters**:
* **`io`** An <code>Iterator</code> pointing to where the input to <code>InputFunction</code> will be read from and the result of <code>OutputFunction</code> will be written to 
* **`input_function`** An <code>InputFunction</code> to be executed on values read from the iterator 
* **`output_function`** An <code>OutputFunction</code> to be executed on values written to the iterator 

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__input__output__iterator.html">transform_input_output_iterator</a>

<h3 id="function-make-transform-iterator">
Function <code>thrust::make&#95;transform&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;class AdaptableUnaryFunction,</span>
<span>&nbsp;&nbsp;class Iterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__iterator.html">transform_iterator</a>< AdaptableUnaryFunction, Iterator > </span><span><b>make_transform_iterator</b>(Iterator it,</span>
<span>&nbsp;&nbsp;AdaptableUnaryFunction fun);</span></code>
<code>make&#95;transform&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__iterator.html">transform&#95;iterator</a></code> from an <code>Iterator</code> and <code>AdaptableUnaryFunction</code>.

**Function Parameters**:
* **`it`** The <code>Iterator</code> pointing to the input range of the newly created <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__iterator.html">transform&#95;iterator</a></code>. 
* **`fun`** The <code>AdaptableUnaryFunction</code> used to transform the range pointed to by <code>it</code> in the newly created <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__iterator.html">transform&#95;iterator</a></code>. 

**Returns**:
A new <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__iterator.html">transform&#95;iterator</a></code> which transforms the range at <code>it</code> by <code>fun</code>. 

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__iterator.html">transform_iterator</a>

<h3 id="function-make-transform-output-iterator">
Function <code>thrust::make&#95;transform&#95;output&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__output__iterator.html">transform_output_iterator</a>< UnaryFunction, OutputIterator > __host__ __device__ </span><span><b>make_transform_output_iterator</b>(OutputIterator out,</span>
<span>&nbsp;&nbsp;UnaryFunction fun);</span></code>
<code>make&#95;transform&#95;output&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__output__iterator.html">transform&#95;output&#95;iterator</a></code> from an <code>OutputIterator</code> and <code>UnaryFunction</code>.

**Function Parameters**:
* **`out`** The <code>OutputIterator</code> pointing to the output range of the newly created <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__output__iterator.html">transform&#95;output&#95;iterator</a></code>
* **`fun`** The <code>UnaryFunction</code> transform the object before assigning it to <code>out</code> by the newly created <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__output__iterator.html">transform&#95;output&#95;iterator</a></code>

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1transform__output__iterator.html">transform_output_iterator</a>

<h3 id="function-make-zip-iterator">
Function <code>thrust::make&#95;zip&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename... Iterators&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip_iterator</a>< <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">thrust::tuple</a>< Iterators... > > </span><span><b>make_zip_iterator</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">thrust::tuple</a>< Iterators... > t);</span></code>
<code>make&#95;zip&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip&#95;iterator</a></code> from a <code>tuple</code> of iterators.

**Function Parameters**:
**`t`**: The <code>tuple</code> of iterators to copy. 

**Returns**:
A newly created <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip&#95;iterator</a></code> which zips the iterators encapsulated in <code>t</code>.

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip_iterator</a>

<h3 id="function-make-zip-iterator">
Function <code>thrust::make&#95;zip&#95;iterator</code>
</h3>

<code class="doxybook">
<span>template &lt;typename... Iterators&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip_iterator</a>< <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">thrust::tuple</a>< Iterators... > > </span><span><b>make_zip_iterator</b>(Iterators... its);</span></code>
<code>make&#95;zip&#95;iterator</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip&#95;iterator</a></code> from iterators.

**Function Parameters**:
**`its`**: The iterators to copy. 

**Returns**:
A newly created <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip&#95;iterator</a></code> which zips the iterators.

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__iterator.html">zip_iterator</a>

<h3 id="function-all-of">
Function <code>thrust::all&#95;of</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ bool </span><span><b>all_of</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>all&#95;of</code> determines whether all elements in a range satify a predicate. Specifically, <code>all&#95;of</code> returns <code>true</code> if <code>pred(&#42;i)</code> is <code>true</code> for every iterator <code>i</code> in the range <code>[first, last)</code> and <code>false</code> otherwise.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/logical.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
bool A[3] = {true, true, false};

thrust::all_of(thrust::host, A, A + 2, thrust::identity<bool>()); // returns true
thrust::all_of(thrust::host, A, A + 3, thrust::identity<bool>()); // returns false

// empty range
thrust::all_of(thrust::host, A, A, thrust::identity<bool>()); // returns false
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
<code>true</code>, if all elements satisfy the predicate; <code>false</code>, otherwise.

**See**:
* any_of 
* none_of 
* transform_reduce 

<h3 id="function-all-of">
Function <code>thrust::all&#95;of</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>bool </span><span><b>all_of</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>all&#95;of</code> determines whether all elements in a range satify a predicate. Specifically, <code>all&#95;of</code> returns <code>true</code> if <code>pred(&#42;i)</code> is <code>true</code> for every iterator <code>i</code> in the range <code>[first, last)</code> and <code>false</code> otherwise.



```cpp
#include <thrust/logical.h>
#include <thrust/functional.h>
...
bool A[3] = {true, true, false};

thrust::all_of(A, A + 2, thrust::identity<bool>()); // returns true
thrust::all_of(A, A + 3, thrust::identity<bool>()); // returns false

// empty range
thrust::all_of(A, A, thrust::identity<bool>()); // returns false
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
<code>true</code>, if all elements satisfy the predicate; <code>false</code>, otherwise.

**See**:
* any_of 
* none_of 
* transform_reduce 

<h3 id="function-any-of">
Function <code>thrust::any&#95;of</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ bool </span><span><b>any_of</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>any&#95;of</code> determines whether any element in a range satifies a predicate. Specifically, <code>any&#95;of</code> returns <code>true</code> if <code>pred(&#42;i)</code> is <code>true</code> for any iterator <code>i</code> in the range <code>[first, last)</code> and <code>false</code> otherwise.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/logical.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
bool A[3] = {true, true, false};

thrust::any_of(thrust::host, A, A + 2, thrust::identity<bool>()); // returns true
thrust::any_of(thrust::host, A, A + 3, thrust::identity<bool>()); // returns true

thrust::any_of(thrust::host, A + 2, A + 3, thrust::identity<bool>()); // returns false

// empty range
thrust::any_of(thrust::host, A, A, thrust::identity<bool>()); // returns false
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
<code>true</code>, if any element satisfies the predicate; <code>false</code>, otherwise.

**See**:
* all_of 
* none_of 
* transform_reduce 

<h3 id="function-any-of">
Function <code>thrust::any&#95;of</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>bool </span><span><b>any_of</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>any&#95;of</code> determines whether any element in a range satifies a predicate. Specifically, <code>any&#95;of</code> returns <code>true</code> if <code>pred(&#42;i)</code> is <code>true</code> for any iterator <code>i</code> in the range <code>[first, last)</code> and <code>false</code> otherwise.



```cpp
#include <thrust/logical.h>
#include <thrust/functional.h>
...
bool A[3] = {true, true, false};

thrust::any_of(A, A + 2, thrust::identity<bool>()); // returns true
thrust::any_of(A, A + 3, thrust::identity<bool>()); // returns true

thrust::any_of(A + 2, A + 3, thrust::identity<bool>()); // returns false

// empty range
thrust::any_of(A, A, thrust::identity<bool>()); // returns false
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
<code>true</code>, if any element satisfies the predicate; <code>false</code>, otherwise.

**See**:
* all_of 
* none_of 
* transform_reduce 

<h3 id="function-none-of">
Function <code>thrust::none&#95;of</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ bool </span><span><b>none_of</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>none&#95;of</code> determines whether no element in a range satifies a predicate. Specifically, <code>none&#95;of</code> returns <code>true</code> if there is no iterator <code>i</code> in the range <code>[first, last)</code> such that <code>pred(&#42;i)</code> is <code>true</code>, and <code>false</code> otherwise.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/logical.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
bool A[3] = {true, true, false};

thrust::none_of(thrust::host, A, A + 2, thrust::identity<bool>()); // returns false
thrust::none_of(thrust::host, A, A + 3, thrust::identity<bool>()); // returns false

thrust::none_of(thrust::host, A + 2, A + 3, thrust::identity<bool>()); // returns true

// empty range
thrust::none_of(thrust::host, A, A, thrust::identity<bool>()); // returns true
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
<code>true</code>, if no element satisfies the predicate; <code>false</code>, otherwise.

**See**:
* all_of 
* any_of 
* transform_reduce 

<h3 id="function-none-of">
Function <code>thrust::none&#95;of</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>bool </span><span><b>none_of</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>none&#95;of</code> determines whether no element in a range satifies a predicate. Specifically, <code>none&#95;of</code> returns <code>true</code> if there is no iterator <code>i</code> in the range <code>[first, last)</code> such that <code>pred(&#42;i)</code> is <code>true</code>, and <code>false</code> otherwise.



```cpp
#include <thrust/logical.h>
#include <thrust/functional.h>
...
bool A[3] = {true, true, false};

thrust::none_of(A, A + 2, thrust::identity<bool>()); // returns false
thrust::none_of(A, A + 3, thrust::identity<bool>()); // returns false

thrust::none_of(A + 2, A + 3, thrust::identity<bool>()); // returns true

// empty range
thrust::none_of(A, A, thrust::identity<bool>()); // returns true
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`pred`** A predicate used to test range elements. 

**Returns**:
<code>true</code>, if no element satisfies the predicate; <code>false</code>, otherwise.

**See**:
* all_of 
* any_of 
* transform_reduce 

<h3 id="function-malloc">
Function <code>thrust::malloc</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy&gt;</span>
<span>__host__ __device__ pointer< void, DerivedPolicy > </span><span><b>malloc</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;std::size_t n);</span></code>
This version of <code>malloc</code> allocates untyped uninitialized storage associated with a given system.


The following code snippet demonstrates how to use <code>malloc</code> to allocate a range of memory associated with Thrust's device system.



```cpp
#include <thrust/memory.h>
...
// allocate some memory with thrust::malloc
const int N = 100;
thrust::device_system_tag device_sys;
thrust::pointer<void,thrust::device_space_tag> void_ptr = thrust::malloc(device_sys, N);

// manipulate memory
...

// deallocate void_ptr with thrust::free
thrust::free(device_sys, void_ptr);
```

**Template Parameters**:
**`DerivedPolicy`**: The name of the derived execution policy.

**Function Parameters**:
* **`system`** The Thrust system with which to associate the storage. 
* **`n`** The number of bytes of storage to allocate. 

**Preconditions**:
<code>DerivedPolicy</code> must be publically derived from <code>thrust::execution&#95;policy&lt;DerivedPolicy&gt;</code>.

**Returns**:
If allocation succeeds, a pointer to the allocated storage; a null pointer otherwise. The pointer must be deallocated with <code>thrust::free</code>.

**See**:
* free 
* device_malloc 

<h3 id="function-malloc">
Function <code>thrust::malloc</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename DerivedPolicy&gt;</span>
<span>__host__ __device__ pointer< T, DerivedPolicy > </span><span><b>malloc</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;std::size_t n);</span></code>
This version of <code>malloc</code> allocates typed uninitialized storage associated with a given system.


The following code snippet demonstrates how to use <code>malloc</code> to allocate a range of memory to accomodate integers associated with Thrust's device system.



```cpp
#include <thrust/memory.h>
...
// allocate storage for 100 ints with thrust::malloc
const int N = 100;
thrust::device_system_tag device_sys;
thrust::pointer<int,thrust::device_system_tag> ptr = thrust::malloc<int>(device_sys, N);

// manipulate memory
...

// deallocate ptr with thrust::free
thrust::free(device_sys, ptr);
```

**Template Parameters**:
**`DerivedPolicy`**: The name of the derived execution policy.

**Function Parameters**:
* **`system`** The Thrust system with which to associate the storage. 
* **`n`** The number of elements of type <code>T</code> which the storage should accomodate. 

**Preconditions**:
<code>DerivedPolicy</code> must be publically derived from <code>thrust::execution&#95;policy&lt;DerivedPolicy&gt;</code>.

**Returns**:
If allocation succeeds, a pointer to an allocation large enough to accomodate <code>n</code> elements of type <code>T</code>; a null pointer otherwise. The pointer must be deallocated with <code>thrust::free</code>.

**See**:
* free 
* device_malloc 

<h3 id="function-get-temporary-buffer">
Function <code>thrust::get&#95;temporary&#95;buffer</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename DerivedPolicy&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< thrust::pointer< T, DerivedPolicy >, typename thrust::pointer< T, DerivedPolicy >::difference_type > </span><span><b>get_temporary_buffer</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;typename thrust::pointer< T, DerivedPolicy >::difference_type n);</span></code>
<code>get&#95;temporary&#95;buffer</code> returns a pointer to storage associated with a given Thrust system sufficient to store up to <code>n</code> objects of type <code>T</code>. If not enough storage is available to accomodate <code>n</code> objects, an implementation may return a smaller buffer. The number of objects the returned buffer can accomodate is also returned.

Thrust uses <code>get&#95;temporary&#95;buffer</code> internally when allocating temporary storage required by algorithm implementations.

The storage allocated with <code>get&#95;temporary&#95;buffer</code> must be returned to the system with <code>return&#95;temporary&#95;buffer</code>.


The following code snippet demonstrates how to use <code>get&#95;temporary&#95;buffer</code> to allocate a range of memory to accomodate integers associated with Thrust's device system.



```cpp
#include <thrust/memory.h>
...
// allocate storage for 100 ints with thrust::get_temporary_buffer
const int N = 100;

typedef thrust::pair<
  thrust::pointer<int,thrust::device_system_tag>,
  std::ptrdiff_t
> ptr_and_size_t;

thrust::device_system_tag device_sys;
ptr_and_size_t ptr_and_size = thrust::get_temporary_buffer<int>(device_sys, N);

// manipulate up to 100 ints
for(int i = 0; i < ptr_and_size.second; ++i)
{
  *ptr_and_size.first = i;
}

// deallocate storage with thrust::return_temporary_buffer
thrust::return_temporary_buffer(device_sys, ptr_and_size.first);
```

**Template Parameters**:
**`DerivedPolicy`**: The name of the derived execution policy.

**Function Parameters**:
* **`system`** The Thrust system with which to associate the storage. 
* **`n`** The requested number of objects of type <code>T</code> the storage should accomodate. 

**Preconditions**:
<code>DerivedPolicy</code> must be publically derived from <code>thrust::execution&#95;policy&lt;DerivedPolicy&gt;</code>.

**Returns**:
A pair <code>p</code> such that <code>p.first</code> is a pointer to the allocated storage and <code>p.second</code> is the number of contiguous objects of type <code>T</code> that the storage can accomodate. If no storage can be allocated, <code>p.first</code> if no storage can be obtained. The storage must be returned to the system using <code>return&#95;temporary&#95;buffer</code>.

**See**:
* malloc 
* return_temporary_buffer 

<h3 id="function-free">
Function <code>thrust::free</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename Pointer&gt;</span>
<span>__host__ __device__ void </span><span><b>free</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;Pointer ptr);</span></code>
<code>free</code> deallocates the storage previously allocated by <code>thrust::malloc</code>.


The following code snippet demonstrates how to use <code>free</code> to deallocate a range of memory previously allocated with <code>thrust::malloc</code>.



```cpp
#include <thrust/memory.h>
...
// allocate storage for 100 ints with thrust::malloc
const int N = 100;
thrust::device_system_tag device_sys;
thrust::pointer<int,thrust::device_system_tag> ptr = thrust::malloc<int>(device_sys, N);

// mainpulate memory
...

// deallocate ptr with thrust::free
thrust::free(device_sys, ptr);
```

**Template Parameters**:
**`DerivedPolicy`**: The name of the derived execution policy.

**Function Parameters**:
* **`system`** The Thrust system with which the storage is associated. 
* **`ptr`** A pointer previously returned by <code>thrust::malloc</code>. If <code>ptr</code> is null, <code>free</code> does nothing.

**Preconditions**:
<code>ptr</code> shall have been returned by a previous call to <code>thrust::malloc(system, n)</code> or <code>thrust::malloc&lt;T&gt;(system, n)</code> for some type <code>T</code>.

<h3 id="function-return-temporary-buffer">
Function <code>thrust::return&#95;temporary&#95;buffer</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename Pointer&gt;</span>
<span>__host__ __device__ void </span><span><b>return_temporary_buffer</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system,</span>
<span>&nbsp;&nbsp;Pointer p,</span>
<span>&nbsp;&nbsp;std::ptrdiff_t n);</span></code>
<code>return&#95;temporary&#95;buffer</code> deallocates storage associated with a given Thrust system previously allocated by <code>get&#95;temporary&#95;buffer</code>.

Thrust uses <code>return&#95;temporary&#95;buffer</code> internally when deallocating temporary storage required by algorithm implementations.


The following code snippet demonstrates how to use <code>return&#95;temporary&#95;buffer</code> to deallocate a range of memory previously allocated by <code>get&#95;temporary&#95;buffer</code>.



```cpp
#include <thrust/memory.h>
...
// allocate storage for 100 ints with thrust::get_temporary_buffer
const int N = 100;

typedef thrust::pair<
  thrust::pointer<int,thrust::device_system_tag>,
  std::ptrdiff_t
> ptr_and_size_t;

thrust::device_system_tag device_sys;
ptr_and_size_t ptr_and_size = thrust::get_temporary_buffer<int>(device_sys, N);

// manipulate up to 100 ints
for(int i = 0; i < ptr_and_size.second; ++i)
{
  *ptr_and_size.first = i;
}

// deallocate storage with thrust::return_temporary_buffer
thrust::return_temporary_buffer(device_sys, ptr_and_size.first);
```

**Template Parameters**:
**`DerivedPolicy`**: The name of the derived execution policy.

**Function Parameters**:
* **`system`** The Thrust system with which the storage is associated. 
* **`p`** A pointer previously returned by <code>thrust::get&#95;temporary&#95;buffer</code>. If <code>ptr</code> is null, <code>return&#95;temporary&#95;buffer</code> does nothing.

**Preconditions**:
<code>p</code> shall have been previously allocated by <code>thrust::get&#95;temporary&#95;buffer</code>.

**See**:
* free 
* get_temporary_buffer 

<h3 id="function-raw-pointer-cast">
Function <code>thrust::raw&#95;pointer&#95;cast</code>
</h3>

<code class="doxybook">
<span>template &lt;typename Pointer&gt;</span>
<span>__host__ __device__ thrust::detail::pointer_traits< Pointer >::raw_pointer </span><span><b>raw_pointer_cast</b>(Pointer ptr);</span></code>
<code>raw&#95;pointer&#95;cast</code> creates a "raw" pointer from a pointer-like type, simply returning the wrapped pointer, should it exist.

**Function Parameters**:
**`ptr`**: The pointer of interest. 

**Returns**:
<code><a href="{{ site.baseurl }}/api/groups/group__tuple.html#function-get">ptr.get()</a></code>, if the expression is well formed; <code>ptr</code>, otherwise. 

**See**:
raw_reference_cast 

<h3 id="function-raw-reference-cast">
Function <code>thrust::raw&#95;reference&#95;cast</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ detail::raw_reference< T >::type </span><span><b>raw_reference_cast</b>(T & ref);</span></code>
<code>raw&#95;reference&#95;cast</code> creates a "raw" reference from a wrapped reference type, simply returning the underlying reference, should it exist.

If the argument is not a reference wrapper, the result is a reference to the argument.

**Note**:
There are two versions of <code>raw&#95;reference&#95;cast</code>. One for <code>const</code> references, and one for non-<code>const</code>. 

**Function Parameters**:
**`ref`**: The reference of interest. 

**Returns**:
<code>&#42;thrust::raw&#95;pointer&#95;cast(&ref)</code>. 

**See**:
raw_pointer_cast 

<h3 id="function-raw-reference-cast">
Function <code>thrust::raw&#95;reference&#95;cast</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T&gt;</span>
<span>__host__ __device__ detail::raw_reference< constT >::type </span><span><b>raw_reference_cast</b>(const T & ref);</span></code>
<code>raw&#95;reference&#95;cast</code> creates a "raw" reference from a wrapped reference type, simply returning the underlying reference, should it exist.

If the argument is not a reference wrapper, the result is a reference to the argument.

**Note**:
There are two versions of <code>raw&#95;reference&#95;cast</code>. One for <code>const</code> references, and one for non-<code>const</code>. 

**Function Parameters**:
**`ref`**: The reference of interest. 

**Returns**:
<code>&#42;thrust::raw&#95;pointer&#95;cast(&ref)</code>. 

**See**:
raw_pointer_cast 

<h3 id="function-merge">
Function <code>thrust::merge</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>merge</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>merge</code> combines two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into a single sorted range. That is, it copies from <code>[first1, last1)</code> and <code>[first2, last2)</code> into <code>[result, result + (last1 - first1) + (last2 - first2))</code> such that the resulting range is in ascending order. <code>merge</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in both input ranges the element from the first range precedes the element from the second. The return value is <code>result + (last1 - first1) + (last2 - first2)</code>.

This version of <code>merge</code> compares elements using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>merge</code> to compute the merger of two sorted sets of integers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/merge.h>
#include <thrust/execution_policy.h>
...
int A1[6] = {1, 3, 5, 7, 9, 11};
int A2[7] = {1, 1, 2, 3, 5,  8, 13};

int result[13];

int *result_end =
  thrust::merge(thrust::host,
                A1, A1 + 6,
                A2, A2 + 7,
                result);
// result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the merged output. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/merge">https://en.cppreference.com/w/cpp/algorithm/merge</a>
* <code>set&#95;union</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-merge">
Function <code>thrust::merge</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>merge</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>merge</code> combines two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into a single sorted range. That is, it copies from <code>[first1, last1)</code> and <code>[first2, last2)</code> into <code>[result, result + (last1 - first1) + (last2 - first2))</code> such that the resulting range is in ascending order. <code>merge</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in both input ranges the element from the first range precedes the element from the second. The return value is <code>result + (last1 - first1) + (last2 - first2)</code>.

This version of <code>merge</code> compares elements using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>merge</code> to compute the merger of two sorted sets of integers.



```cpp
#include <thrust/merge.h>
...
int A1[6] = {1, 3, 5, 7, 9, 11};
int A2[7] = {1, 1, 2, 3, 5,  8, 13};

int result[13];

int *result_end = thrust::merge(A1, A1 + 6, A2, A2 + 7, result);
// result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the merged output. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/merge">https://en.cppreference.com/w/cpp/algorithm/merge</a>
* <code>set&#95;union</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-merge">
Function <code>thrust::merge</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>merge</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>merge</code> combines two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into a single sorted range. That is, it copies from <code>[first1, last1)</code> and <code>[first2, last2)</code> into <code>[result, result + (last1 - first1) + (last2 - first2))</code> such that the resulting range is in ascending order. <code>merge</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in both input ranges the element from the first range precedes the element from the second. The return value is <code>result + (last1 - first1) + (last2 - first2)</code>.

This version of <code>merge</code> compares elements using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>merge</code> to compute the merger of two sets of integers sorted in descending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/merge.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A1[6] = {11, 9, 7, 5, 3, 1};
int A2[7] = {13, 8, 5, 3, 2, 1, 1};

int result[13];

int *result_end = thrust::merge(thrust::host,
                                A1, A1 + 6,
                                A2, A2 + 7,
                                result,
                                thrust::greater<int>());
// result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>first&#95;argument&#95;type</code>. and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>second&#95;argument&#95;type</code>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the merged output. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/merge">https://en.cppreference.com/w/cpp/algorithm/merge</a>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-merge">
Function <code>thrust::merge</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b>merge</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>merge</code> combines two sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> into a single sorted range. That is, it copies from <code>[first1, last1)</code> and <code>[first2, last2)</code> into <code>[result, result + (last1 - first1) + (last2 - first2))</code> such that the resulting range is in ascending order. <code>merge</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in both input ranges the element from the first range precedes the element from the second. The return value is <code>result + (last1 - first1) + (last2 - first2)</code>.

This version of <code>merge</code> compares elements using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>merge</code> to compute the merger of two sets of integers sorted in descending order.



```cpp
#include <thrust/merge.h>
#include <thrust/functional.h>
...
int A1[6] = {11, 9, 7, 5, 3, 1};
int A2[7] = {13, 8, 5, 3, 2, 1, 1};

int result[13];

int *result_end = thrust::merge(A1, A1 + 6, A2, A2 + 7, result, thrust::greater<int>());
// result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>first&#95;argument&#95;type</code>. and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>second&#95;argument&#95;type</code>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the merged output. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/merge">https://en.cppreference.com/w/cpp/algorithm/merge</a>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-merge-by-key">
Function <code>thrust::merge&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>merge_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>merge&#95;by&#95;key</code> performs a key-value merge. That is, <code>merge&#95;by&#95;key</code> copies elements from <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> into a single range, <code>[keys&#95;result, keys&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> such that the resulting range is in ascending key order.

At the same time, <code>merge&#95;by&#95;key</code> copies elements from the two associated ranges <code>[values&#95;first1 + (keys&#95;last1 - keys&#95;first1))</code> and <code>[values&#95;first2 + (keys&#95;last2 - keys&#95;first2))</code> into a single range, <code>[values&#95;result, values&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> such that the resulting range is in ascending order implied by each input element's associated key.

<code>merge&#95;by&#95;key</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in all input key ranges the element from the first range precedes the element from the second.

The return value is is <code>(keys&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> and <code>(values&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>merge&#95;by&#95;key</code> to compute the merger of two sets of integers sorted in ascending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/merge.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {1, 3, 5, 7, 9, 11};
int A_vals[6] = {0, 0, 0, 0, 0, 0};

int B_keys[7] = {1, 1, 2, 3, 5, 8, 13};
int B_vals[7] = {1, 1, 1, 1, 1, 1, 1};

int keys_result[13];
int vals_result[13];

thrust::pair<int*,int*> end =
  thrust::merge_by_key(thrust::host,
                       A_keys, A_keys + 6,
                       B_keys, B_keys + 7,
                       A_vals, B_vals,
                       keys_result, vals_result);

// keys_result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}
// vals_result = {0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0,  0,  1}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the merged output range of keys. 
* **`values_result`** The beginning of the merged output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* merge 
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-merge-by-key">
Function <code>thrust::merge&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>merge_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>merge&#95;by&#95;key</code> performs a key-value merge. That is, <code>merge&#95;by&#95;key</code> copies elements from <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> into a single range, <code>[keys&#95;result, keys&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> such that the resulting range is in ascending key order.

At the same time, <code>merge&#95;by&#95;key</code> copies elements from the two associated ranges <code>[values&#95;first1 + (keys&#95;last1 - keys&#95;first1))</code> and <code>[values&#95;first2 + (keys&#95;last2 - keys&#95;first2))</code> into a single range, <code>[values&#95;result, values&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> such that the resulting range is in ascending order implied by each input element's associated key.

<code>merge&#95;by&#95;key</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in all input key ranges the element from the first range precedes the element from the second.

The return value is is <code>(keys&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> and <code>(values&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code>.


The following code snippet demonstrates how to use <code>merge&#95;by&#95;key</code> to compute the merger of two sets of integers sorted in ascending order.



```cpp
#include <thrust/merge.h>
#include <thrust/functional.h>
...
int A_keys[6] = {1, 3, 5, 7, 9, 11};
int A_vals[6] = {0, 0, 0, 0, 0, 0};

int B_keys[7] = {1, 1, 2, 3, 5, 8, 13};
int B_vals[7] = {1, 1, 1, 1, 1, 1, 1};

int keys_result[13];
int vals_result[13];

thrust::pair<int*,int*> end = thrust::merge_by_key(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, B_vals, keys_result, vals_result);

// keys_result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}
// vals_result = {0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0,  0,  1}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the merged output range of keys. 
* **`values_result`** The beginning of the merged output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* merge 
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-merge-by-key">
Function <code>thrust::merge&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>merge_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;Compare comp);</span></code>
<code>merge&#95;by&#95;key</code> performs a key-value merge. That is, <code>merge&#95;by&#95;key</code> copies elements from <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> into a single range, <code>[keys&#95;result, keys&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> such that the resulting range is in ascending key order.

At the same time, <code>merge&#95;by&#95;key</code> copies elements from the two associated ranges <code>[values&#95;first1 + (keys&#95;last1 - keys&#95;first1))</code> and <code>[values&#95;first2 + (keys&#95;last2 - keys&#95;first2))</code> into a single range, <code>[values&#95;result, values&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> such that the resulting range is in ascending order implied by each input element's associated key.

<code>merge&#95;by&#95;key</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in all input key ranges the element from the first range precedes the element from the second.

The return value is is <code>(keys&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> and <code>(values&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code>.

This version of <code>merge&#95;by&#95;key</code> compares key elements using a function object <code>comp</code>.

The algorithm's execution is parallelized using <code>exec</code>.


The following code snippet demonstrates how to use <code>merge&#95;by&#95;key</code> to compute the merger of two sets of integers sorted in descending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/merge.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {11, 9, 7, 5, 3, 1};
int A_vals[6] = { 0, 0, 0, 0, 0, 0};

int B_keys[7] = {13, 8, 5, 3, 2, 1, 1};
int B_vals[7] = { 1, 1, 1, 1, 1, 1, 1};

int keys_result[13];
int vals_result[13];

thrust::pair<int*,int*> end =
  thrust::merge_by_key(thrust::host,
                       A_keys, A_keys + 6,
                       B_keys, B_keys + 7,
                       A_vals, B_vals,
                       keys_result, vals_result,
                       thrust::greater<int>());

// keys_result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}
// vals_result = { 1,  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>first&#95;argument&#95;type</code>. and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator1's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>second&#95;argument&#95;type</code>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator1's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the merged output range of keys. 
* **`values_result`** The beginning of the merged output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* merge 
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-merge-by-key">
Function <code>thrust::merge&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>merge_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>merge&#95;by&#95;key</code> performs a key-value merge. That is, <code>merge&#95;by&#95;key</code> copies elements from <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> into a single range, <code>[keys&#95;result, keys&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> such that the resulting range is in ascending key order.

At the same time, <code>merge&#95;by&#95;key</code> copies elements from the two associated ranges <code>[values&#95;first1 + (keys&#95;last1 - keys&#95;first1))</code> and <code>[values&#95;first2 + (keys&#95;last2 - keys&#95;first2))</code> into a single range, <code>[values&#95;result, values&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> such that the resulting range is in ascending order implied by each input element's associated key.

<code>merge&#95;by&#95;key</code> is stable, meaning both that the relative order of elements within each input range is preserved, and that for equivalent elements in all input key ranges the element from the first range precedes the element from the second.

The return value is is <code>(keys&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code> and <code>(values&#95;result + (keys&#95;last1 - keys&#95;first1) + (keys&#95;last2 - keys&#95;first2))</code>.

This version of <code>merge&#95;by&#95;key</code> compares key elements using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>merge&#95;by&#95;key</code> to compute the merger of two sets of integers sorted in descending order.



```cpp
#include <thrust/merge.h>
#include <thrust/functional.h>
...
int A_keys[6] = {11, 9, 7, 5, 3, 1};
int A_vals[6] = { 0, 0, 0, 0, 0, 0};

int B_keys[7] = {13, 8, 5, 3, 2, 1, 1};
int B_vals[7] = { 1, 1, 1, 1, 1, 1, 1};

int keys_result[13];
int vals_result[13];

thrust::pair<int*,int*> end = thrust::merge_by_key(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());

// keys_result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}
// vals_result = { 1,  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>first&#95;argument&#95;type</code>. and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator1's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>second&#95;argument&#95;type</code>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator1's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the merged output range of keys. 
* **`values_result`** The beginning of the merged output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* merge 
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-mismatch">
Function <code>thrust::mismatch</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< InputIterator1, InputIterator2 > </span><span><b>mismatch</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2);</span></code>
<code>mismatch</code> finds the first position where the two ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code> differ. The two versions of <code>mismatch</code> use different tests for whether elements differ.

This version of <code>mismatch</code> finds the first iterator <code>i</code> in <code>[first1, last1)</code> such that <code>&#42;i == &#42;(first2 + (i - first1))</code> is <code>false</code>. The return value is a <code>pair</code> whose first element is <code>i</code> and whose second element is <code>&#42;(first2 + (i - first1))</code>. If no such iterator <code>i</code> exists, the return value is a <code>pair</code> whose first element is <code>last1</code> and whose second element is <code>&#42;(first2 + (last1 - first1))</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/mismatch.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> vec1(4);
thrust::device_vector<int> vec2(4);

vec1[0] = 0;  vec2[0] = 0; 
vec1[1] = 5;  vec2[1] = 5;
vec1[2] = 3;  vec2[2] = 8;
vec1[3] = 7;  vec2[3] = 7;

typedef thrust::device_vector<int>::iterator Iterator;
thrust::pair<Iterator,Iterator> result;

result = thrust::mismatch(thrust::device, vec1.begin(), vec1.end(), vec2.begin());

// result.first  is vec1.begin() + 2
// result.second is vec2.begin() + 2
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> is equality comparable to <code>InputIterator2's</code><code>value&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 

**Returns**:
The first position where the sequences differ.

**See**:
* find 
* find_if 

<h3 id="function-mismatch">
Function <code>thrust::mismatch</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< InputIterator1, InputIterator2 > </span><span><b>mismatch</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2);</span></code>
<code>mismatch</code> finds the first position where the two ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code> differ. The two versions of <code>mismatch</code> use different tests for whether elements differ.

This version of <code>mismatch</code> finds the first iterator <code>i</code> in <code>[first1, last1)</code> such that <code>&#42;i == &#42;(first2 + (i - first1))</code> is <code>false</code>. The return value is a <code>pair</code> whose first element is <code>i</code> and whose second element is <code>&#42;(first2 + (i - first1))</code>. If no such iterator <code>i</code> exists, the return value is a <code>pair</code> whose first element is <code>last1</code> and whose second element is <code>&#42;(first2 + (last1 - first1))</code>.



```cpp
#include <thrust/mismatch.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> vec1(4);
thrust::device_vector<int> vec2(4);

vec1[0] = 0;  vec2[0] = 0; 
vec1[1] = 5;  vec2[1] = 5;
vec1[2] = 3;  vec2[2] = 8;
vec1[3] = 7;  vec2[3] = 7;

typedef thrust::device_vector<int>::iterator Iterator;
thrust::pair<Iterator,Iterator> result;

result = thrust::mismatch(vec1.begin(), vec1.end(), vec2.begin());

// result.first  is vec1.begin() + 2
// result.second is vec2.begin() + 2
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> is equality comparable to <code>InputIterator2's</code><code>value&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>.

**Function Parameters**:
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 

**Returns**:
The first position where the sequences differ.

**See**:
* find 
* find_if 

<h3 id="function-mismatch">
Function <code>thrust::mismatch</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< InputIterator1, InputIterator2 > </span><span><b>mismatch</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;BinaryPredicate pred);</span></code>
<code>mismatch</code> finds the first position where the two ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code> differ. The two versions of <code>mismatch</code> use different tests for whether elements differ.

This version of <code>mismatch</code> finds the first iterator <code>i</code> in <code>[first1, last1)</code> such that <code>pred(&#42;i, &#42;(first2 + (i - first1))</code> is <code>false</code>. The return value is a <code>pair</code> whose first element is <code>i</code> and whose second element is <code>&#42;(first2 + (i - first1))</code>. If no such iterator <code>i</code> exists, the return value is a <code>pair</code> whose first element is <code>last1</code> and whose second element is <code>&#42;(first2 + (last1 - first1))</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/mismatch.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> vec1(4);
thrust::device_vector<int> vec2(4);

vec1[0] = 0;  vec2[0] = 0; 
vec1[1] = 5;  vec2[1] = 5;
vec1[2] = 3;  vec2[2] = 8;
vec1[3] = 7;  vec2[3] = 7;

typedef thrust::device_vector<int>::iterator Iterator;
thrust::pair<Iterator,Iterator> result;

result = thrust::mismatch(thrust::device, vec1.begin(), vec1.end(), vec2.begin(), thrust::equal_to<int>());

// result.first  is vec1.begin() + 2
// result.second is vec2.begin() + 2
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Input Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 
* **`pred`** The binary predicate to compare elements. 

**Returns**:
The first position where the sequences differ.

**See**:
* find 
* find_if 

<h3 id="function-mismatch">
Function <code>thrust::mismatch</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< InputIterator1, InputIterator2 > </span><span><b>mismatch</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;BinaryPredicate pred);</span></code>
<code>mismatch</code> finds the first position where the two ranges <code>[first1, last1)</code> and <code>[first2, first2 + (last1 - first1))</code> differ. The two versions of <code>mismatch</code> use different tests for whether elements differ.

This version of <code>mismatch</code> finds the first iterator <code>i</code> in <code>[first1, last1)</code> such that <code>pred(&#42;i, &#42;(first2 + (i - first1))</code> is <code>false</code>. The return value is a <code>pair</code> whose first element is <code>i</code> and whose second element is <code>&#42;(first2 + (i - first1))</code>. If no such iterator <code>i</code> exists, the return value is a <code>pair</code> whose first element is <code>last1</code> and whose second element is <code>&#42;(first2 + (last1 - first1))</code>.



```cpp
#include <thrust/mismatch.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> vec1(4);
thrust::device_vector<int> vec2(4);

vec1[0] = 0;  vec2[0] = 0; 
vec1[1] = 5;  vec2[1] = 5;
vec1[2] = 3;  vec2[2] = 8;
vec1[3] = 7;  vec2[3] = 7;

typedef thrust::device_vector<int>::iterator Iterator;
thrust::pair<Iterator,Iterator> result;

result = thrust::mismatch(vec1.begin(), vec1.end(), vec2.begin(), thrust::equal_to<int>());

// result.first  is vec1.begin() + 2
// result.second is vec2.begin() + 2
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Input Iterator</a>.

**Function Parameters**:
* **`first1`** The beginning of the first sequence. 
* **`last1`** The end of the first sequence. 
* **`first2`** The beginning of the second sequence. 
* **`pred`** The binary predicate to compare elements. 

**Returns**:
The first position where the sequences differ.

**See**:
* find 
* find_if 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator==</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span></code>
\group relop 

Compares two optional objects

If both optionals contain a value, they are compared with <code>T</code>s relational operators. Otherwise <code>lhs</code> and <code>rhs</code> are equal only if they are both empty, and <code>lhs</code> is less than <code>rhs</code> only if <code>rhs</code> is empty and <code>lhs</code> is not. 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator!=</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span></code>
\group relop 

<h3 id="function-operator<">
Function <code>thrust::operator&lt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span></code>
\group relop 

<h3 id="function-operator>">
Function <code>thrust::operator&gt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span></code>
\group relop 

<h3 id="function-operator<=">
Function <code>thrust::operator&lt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<=</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span></code>
\group relop 

<h3 id="function-operator>=">
Function <code>thrust::operator&gt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator>=</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< U > & rhs);</span></code>
\group relop 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator==</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span></code>
\group relop_nullopt 

Compares an optional to a <code>nullopt</code>

Equivalent to comparing the optional to an empty optional 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator==</b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_nullopt 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator!=</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span></code>
\group relop_nullopt 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator!=</b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_nullopt 

<h3 id="function-operator<">
Function <code>thrust::operator&lt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > &,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span></code>
\group relop_nullopt 

<h3 id="function-operator<">
Function <code>thrust::operator&lt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<</b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_nullopt 

<h3 id="function-operator<=">
Function <code>thrust::operator&lt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<=</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span></code>
\group relop_nullopt 

<h3 id="function-operator<=">
Function <code>thrust::operator&lt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<=</b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > &);</span></code>
\group relop_nullopt 

<h3 id="function-operator>">
Function <code>thrust::operator&gt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span></code>
\group relop_nullopt 

<h3 id="function-operator>">
Function <code>thrust::operator&gt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator></b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > &);</span></code>
\group relop_nullopt 

<h3 id="function-operator>=">
Function <code>thrust::operator&gt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator>=</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > &,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>);</span></code>
\group relop_nullopt 

<h3 id="function-operator>=">
Function <code>thrust::operator&gt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator>=</b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1nullopt__t.html">nullopt_t</a>,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_nullopt 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator==</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span></code>
\group relop_t 

Compares the optional with a value.

If the optional has a value, it is compared with the other value using <code>T</code>s relational operators. Otherwise, the optional is considered less than the value. 

<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator==</b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_t 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator!=</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span></code>
\group relop_t 

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator!=</b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_t 

<h3 id="function-operator<">
Function <code>thrust::operator&lt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span></code>
\group relop_t 

<h3 id="function-operator<">
Function <code>thrust::operator&lt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<</b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_t 

<h3 id="function-operator<=">
Function <code>thrust::operator&lt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<=</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span></code>
\group relop_t 

<h3 id="function-operator<=">
Function <code>thrust::operator&lt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator<=</b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_t 

<h3 id="function-operator>">
Function <code>thrust::operator&gt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator></b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span></code>
\group relop_t 

<h3 id="function-operator>">
Function <code>thrust::operator&gt;</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator></b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_t 

<h3 id="function-operator>=">
Function <code>thrust::operator&gt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator>=</b>(const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;const U & rhs);</span></code>
\group relop_t 

<h3 id="function-operator>=">
Function <code>thrust::operator&gt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr bool </span><span><b>operator>=</b>(const U & lhs,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\group relop_t 

<h3 id="function-swap">
Function <code>thrust::swap</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;detail::enable_if_t< std::is_move_constructible< T >::value > * = nullptr,</span>
<span>&nbsp;&nbsp;detail::enable_if_t< detail::is_swappable< T >::value > * = nullptr&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ void </span><span><b>swap</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & lhs,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > & rhs);</span></code>
\synopsis template <class T>\nvoid swap(optional<T> &lhs, optional<T> &rhs); 

<h3 id="function-make-optional">
Function <code>thrust::make&#95;optional</code>
</h3>

<code class="doxybook">
<span>template &lt;class T = detail::i&#95;am&#95;secret,</span>
<span>&nbsp;&nbsp;class U,</span>
<span>&nbsp;&nbsp;class Ret = detail::conditional&#95;t&lt;std::is&#95;same&lt;T, detail::i&#95;am&#95;secret&gt;::value,                                    detail::decay&#95;t&lt;U&gt;, T&gt;&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< Ret > </span><span><b>make_optional</b>(U && v);</span></code>
<h3 id="function-make-optional">
Function <code>thrust::make&#95;optional</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class... Args&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > </span><span><b>make_optional</b>(Args &&... args);</span></code>
<h3 id="function-make-optional">
Function <code>thrust::make&#95;optional</code>
</h3>

<code class="doxybook">
<span>template &lt;class T,</span>
<span>&nbsp;&nbsp;class U,</span>
<span>&nbsp;&nbsp;class... Args&gt;</span>
<span>__thrust_exec_check_disable__ __host__ __device__ constexpr <a href="{{ site.baseurl }}/api/classes/classthrust_1_1optional.html">optional</a>< T > </span><span><b>make_optional</b>(std::initializer_list< U > il,</span>
<span>&nbsp;&nbsp;Args &&... args);</span></code>
<h3 id="function-optional">
Function <code>thrust::optional</code>
</h3>

<code class="doxybook">
<span>template &lt;class T&gt;</span>
<span><b>optional</b>(T);</span></code>
<h3 id="function-operator==">
Function <code>thrust::operator==</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator==</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span></code>
This operator tests two <code>pairs</code> for equality.

**Template Parameters**:
* **`T1`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`T2`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 

**Function Parameters**:
* **`x`** The first <code>pair</code> to compare. 
* **`y`** The second <code>pair</code> to compare. 

**Returns**:
<code>true</code> if and only if <code>x.first == y.first && x.second == y.second</code>.

<h3 id="function-operator<">
Function <code>thrust::operator&lt;</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator<</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span></code>
This operator tests two pairs for ascending ordering.

**Template Parameters**:
* **`T1`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>. 
* **`T2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>. 

**Function Parameters**:
* **`x`** The first <code>pair</code> to compare. 
* **`y`** The second <code>pair</code> to compare. 

**Returns**:
<code>true</code> if and only if <code>x.first &lt; y.first || (!(y.first &lt; x.first) && x.second &lt; y.second)</code>.

<h3 id="function-operator!=">
Function <code>thrust::operator!=</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator!=</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span></code>
This operator tests two pairs for inequality.

**Template Parameters**:
* **`T1`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`T2`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 

**Function Parameters**:
* **`x`** The first <code>pair</code> to compare. 
* **`y`** The second <code>pair</code> to compare. 

**Returns**:
<code>true</code> if and only if <code>!(x == y)</code>.

<h3 id="function-operator>">
Function <code>thrust::operator&gt;</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator></b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span></code>
This operator tests two pairs for descending ordering.

**Template Parameters**:
* **`T1`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>. 
* **`T2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>. 

**Function Parameters**:
* **`x`** The first <code>pair</code> to compare. 
* **`y`** The second <code>pair</code> to compare. 

**Returns**:
<code>true</code> if and only if <code>y &lt; x</code>.

<h3 id="function-operator<=">
Function <code>thrust::operator&lt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator<=</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span></code>
This operator tests two pairs for ascending ordering or equivalence.

**Template Parameters**:
* **`T1`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>. 
* **`T2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>. 

**Function Parameters**:
* **`x`** The first <code>pair</code> to compare. 
* **`y`** The second <code>pair</code> to compare. 

**Returns**:
<code>true</code> if and only if <code>!(y &lt; x)</code>.

<h3 id="function-operator>=">
Function <code>thrust::operator&gt;=</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ bool </span><span><b>operator>=</b>(const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;const <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span></code>
This operator tests two pairs for descending ordering or equivalence.

**Template Parameters**:
* **`T1`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>. 
* **`T2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>. 

**Function Parameters**:
* **`x`** The first <code>pair</code> to compare. 
* **`y`** The second <code>pair</code> to compare. 

**Returns**:
<code>true</code> if and only if <code>!(x &lt; y)</code>.

<h3 id="function-swap">
Function <code>thrust::swap</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ void </span><span><b>swap</b>(<a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & x,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > & y);</span></code>
<code>swap</code> swaps the contents of two <code>pair</code>s.

**Function Parameters**:
* **`x`** The first <code>pair</code> to swap. 
* **`y`** The second <code>pair</code> to swap. 

<h3 id="function-make-pair">
Function <code>thrust::make&#95;pair</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T1,</span>
<span>&nbsp;&nbsp;typename T2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>< T1, T2 > </span><span><b>make_pair</b>(T1 x,</span>
<span>&nbsp;&nbsp;T2 y);</span></code>
This convenience function creates a <code>pair</code> from two objects.

**Template Parameters**:
* **`T1`** There are no requirements on the type of <code>T1</code>. 
* **`T2`** There are no requirements on the type of <code>T2</code>. 

**Function Parameters**:
* **`x`** The first object to copy from. 
* **`y`** The second object to copy from. 

**Returns**:
A newly-constructed <code>pair</code> copied from <code>a</code> and <code>b</code>.

<h3 id="function-partition">
Function <code>thrust::partition</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>partition</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition</code> reorders the elements <code>[first, last)</code> based on the function object <code>pred</code>, such that all of the elements that satisfy <code>pred</code> precede the elements that fail to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[first, last)</code>, <code>pred(&#42;i)</code> is <code>true</code> for every iterator <code>i</code> in the range <code>[first,middle)</code> and <code>false</code> for every iterator <code>i</code> in the range <code>[middle, last)</code>. The return value of <code>partition</code> is <code>middle</code>.

Note that the relative order of elements in the two reordered sequences is not necessarily the same as it was in the original sequence. A different algorithm, <code>stable&#95;partition</code>, does guarantee to preserve the relative order.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>partition</code> to reorder a sequence so that even numbers precede odd numbers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/partition.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::partition(thrust::host,
                  A, A + N,
                  is_even());
// A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>, and <code>ForwardIterator</code> is mutable. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to reorder. 
* **`last`** The end of the sequence to reorder. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Returns**:
An iterator referring to the first element of the second partition, that is, the sequence of the elements which do not satisfy <code>pred</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/partition">https://en.cppreference.com/w/cpp/algorithm/partition</a>
* <code>stable&#95;partition</code>
* <code>partition&#95;copy</code>

<h3 id="function-partition">
Function <code>thrust::partition</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>partition</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition</code> reorders the elements <code>[first, last)</code> based on the function object <code>pred</code>, such that all of the elements that satisfy <code>pred</code> precede the elements that fail to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[first, last)</code>, <code>pred(&#42;i)</code> is <code>true</code> for every iterator <code>i</code> in the range <code>[first,middle)</code> and <code>false</code> for every iterator <code>i</code> in the range <code>[middle, last)</code>. The return value of <code>partition</code> is <code>middle</code>.

Note that the relative order of elements in the two reordered sequences is not necessarily the same as it was in the original sequence. A different algorithm, <code>stable&#95;partition</code>, does guarantee to preserve the relative order.


The following code snippet demonstrates how to use <code>partition</code> to reorder a sequence so that even numbers precede odd numbers.



```cpp
#include <thrust/partition.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::partition(A, A + N,
                   is_even());
// A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>, and <code>ForwardIterator</code> is mutable. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence to reorder. 
* **`last`** The end of the sequence to reorder. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Returns**:
An iterator referring to the first element of the second partition, that is, the sequence of the elements which do not satisfy <code>pred</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/partition">https://en.cppreference.com/w/cpp/algorithm/partition</a>
* <code>stable&#95;partition</code>
* <code>partition&#95;copy</code>

<h3 id="function-partition">
Function <code>thrust::partition</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>partition</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition</code> reorders the elements <code>[first, last)</code> based on the function object <code>pred</code> applied to a stencil range <code>[stencil, stencil + (last - first))</code>, such that all of the elements whose corresponding stencil element satisfies <code>pred</code> precede all of the elements whose corresponding stencil element fails to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[first, last)</code>, <code>pred(&#42;stencil&#95;i)</code> is <code>true</code> for every iterator <code>stencil&#95;i</code> in the range <code>[stencil,stencil + (middle - first))</code> and <code>false</code> for every iterator <code>stencil&#95;i</code> in the range <code>[stencil + (middle - first), stencil + (last - first))</code>. The return value of <code>stable&#95;partition</code> is <code>middle</code>.

Note that the relative order of elements in the two reordered sequences is not necessarily the same as it was in the original sequence. A different algorithm, <code>stable&#95;partition</code>, does guarantee to preserve the relative order.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>partition</code> to reorder a sequence so that even numbers precede odd numbers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/partition.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
int S[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::partition(thrust::host, A, A + N, S, is_even());
// A is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
// S is unmodified
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to reorder. 
* **`last`** The end of the sequence to reorder. 
* **`stencil`** The beginning of the stencil sequence. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[stencil, stencil + (last - first))</code> shall not overlap.

**Returns**:
An iterator referring to the first element of the second partition, that is, the sequence of the elements whose stencil elements do not satisfy <code>pred</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/partition">https://en.cppreference.com/w/cpp/algorithm/partition</a>
* <code>stable&#95;partition</code>
* <code>partition&#95;copy</code>

<h3 id="function-partition">
Function <code>thrust::partition</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>partition</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition</code> reorders the elements <code>[first, last)</code> based on the function object <code>pred</code> applied to a stencil range <code>[stencil, stencil + (last - first))</code>, such that all of the elements whose corresponding stencil element satisfies <code>pred</code> precede all of the elements whose corresponding stencil element fails to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[first, last)</code>, <code>pred(&#42;stencil&#95;i)</code> is <code>true</code> for every iterator <code>stencil&#95;i</code> in the range <code>[stencil,stencil + (middle - first))</code> and <code>false</code> for every iterator <code>stencil&#95;i</code> in the range <code>[stencil + (middle - first), stencil + (last - first))</code>. The return value of <code>stable&#95;partition</code> is <code>middle</code>.

Note that the relative order of elements in the two reordered sequences is not necessarily the same as it was in the original sequence. A different algorithm, <code>stable&#95;partition</code>, does guarantee to preserve the relative order.


The following code snippet demonstrates how to use <code>partition</code> to reorder a sequence so that even numbers precede odd numbers.



```cpp
#include <thrust/partition.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
int S[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::partition(A, A + N, S, is_even());
// A is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
// S is unmodified
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence to reorder. 
* **`last`** The end of the sequence to reorder. 
* **`stencil`** The beginning of the stencil sequence. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The ranges <code>[first,last)</code> and <code>[stencil, stencil + (last - first))</code> shall not overlap.

**Returns**:
An iterator referring to the first element of the second partition, that is, the sequence of the elements whose stencil elements do not satisfy <code>pred</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/partition">https://en.cppreference.com/w/cpp/algorithm/partition</a>
* <code>stable&#95;partition</code>
* <code>partition&#95;copy</code>

<h3 id="function-partition-copy">
Function <code>thrust::partition&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>partition_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition&#95;copy</code> differs from <code>partition</code> only in that the reordered sequence is written to difference output sequences, rather than in place.

<code>partition&#95;copy</code> copies the elements <code>[first, last)</code> based on the function object <code>pred</code>. All of the elements that satisfy <code>pred</code> are copied to the range beginning at <code>out&#95;true</code> and all the elements that fail to satisfy it are copied to the range beginning at <code>out&#95;false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>partition&#95;copy</code> to separate a sequence into two output sequences of even and odd numbers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/partition.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int result[10];
const int N = sizeof(A)/sizeof(int);
int *evens = result;
int *odds  = result + 5;
thrust::partition_copy(thrust::host, A, A + N, evens, odds, is_even());
// A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
// evens points to {2, 4, 6, 8, 10}
// odds points to {1, 3, 5, 7, 9}
```

**Note**:
The relative order of elements in the two reordered sequences is not necessarily the same as it was in the original sequence. A different algorithm, <code>stable&#95;partition&#95;copy</code>, does guarantee to preserve the relative order.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1</code> and <code>OutputIterator2's</code><code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to reorder. 
* **`last`** The end of the sequence to reorder. 
* **`out_true`** The destination of the resulting sequence of elements which satisfy <code>pred</code>. 
* **`out_false`** The destination of the resulting sequence of elements which fail to satisfy <code>pred</code>. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The input range shall not overlap with either output range.

**Returns**:
A <code>pair</code> p such that <code>p.first</code> is the end of the output range beginning at <code>out&#95;true</code> and <code>p.second</code> is the end of the output range beginning at <code>out&#95;false</code>.

**See**:
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf</a>
* <code>stable&#95;partition&#95;copy</code>
* <code>partition</code>

<h3 id="function-partition-copy">
Function <code>thrust::partition&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>partition_copy</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition&#95;copy</code> differs from <code>partition</code> only in that the reordered sequence is written to difference output sequences, rather than in place.

<code>partition&#95;copy</code> copies the elements <code>[first, last)</code> based on the function object <code>pred</code>. All of the elements that satisfy <code>pred</code> are copied to the range beginning at <code>out&#95;true</code> and all the elements that fail to satisfy it are copied to the range beginning at <code>out&#95;false</code>.


The following code snippet demonstrates how to use <code>partition&#95;copy</code> to separate a sequence into two output sequences of even and odd numbers.



```cpp
#include <thrust/partition.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int result[10];
const int N = sizeof(A)/sizeof(int);
int *evens = result;
int *odds  = result + 5;
thrust::partition_copy(A, A + N, evens, odds, is_even());
// A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
// evens points to {2, 4, 6, 8, 10}
// odds points to {1, 3, 5, 7, 9}
```

**Note**:
The relative order of elements in the two reordered sequences is not necessarily the same as it was in the original sequence. A different algorithm, <code>stable&#95;partition&#95;copy</code>, does guarantee to preserve the relative order.

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1</code> and <code>OutputIterator2's</code><code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence to reorder. 
* **`last`** The end of the sequence to reorder. 
* **`out_true`** The destination of the resulting sequence of elements which satisfy <code>pred</code>. 
* **`out_false`** The destination of the resulting sequence of elements which fail to satisfy <code>pred</code>. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The input range shall not overlap with either output range.

**Returns**:
A <code>pair</code> p such that <code>p.first</code> is the end of the output range beginning at <code>out&#95;true</code> and <code>p.second</code> is the end of the output range beginning at <code>out&#95;false</code>.

**See**:
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf</a>
* <code>stable&#95;partition&#95;copy</code>
* <code>partition</code>

<h3 id="function-partition-copy">
Function <code>thrust::partition&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>partition_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition&#95;copy</code> differs from <code>partition</code> only in that the reordered sequence is written to difference output sequences, rather than in place.

<code>partition&#95;copy</code> copies the elements <code>[first, last)</code> based on the function object <code>pred</code> which is applied to a range of stencil elements. All of the elements whose corresponding stencil element satisfies <code>pred</code> are copied to the range beginning at <code>out&#95;true</code> and all the elements whose stencil element fails to satisfy it are copied to the range beginning at <code>out&#95;false</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>partition&#95;copy</code> to separate a sequence into two output sequences of even and odd numbers using the <code>thrust::host</code> execution policy for parallelization.



```cpp
#include <thrust/partition.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int S[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
int result[10];
const int N = sizeof(A)/sizeof(int);
int *evens = result;
int *odds  = result + 5;
thrust::stable_partition_copy(thrust::host, A, A + N, S, evens, odds, thrust::identity<int>());
// A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// S remains {0, 1, 0, 1, 0, 1, 0, 1, 0,  1}
// result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
// evens points to {2, 4, 6, 8, 10}
// odds points to {1, 3, 5, 7, 9}
```

**Note**:
The relative order of elements in the two reordered sequences is not necessarily the same as it was in the original sequence. A different algorithm, <code>stable&#95;partition&#95;copy</code>, does guarantee to preserve the relative order.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1</code> and <code>OutputIterator2's</code><code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to reorder. 
* **`last`** The end of the sequence to reorder. 
* **`stencil`** The beginning of the stencil sequence. 
* **`out_true`** The destination of the resulting sequence of elements which satisfy <code>pred</code>. 
* **`out_false`** The destination of the resulting sequence of elements which fail to satisfy <code>pred</code>. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The input ranges shall not overlap with either output range.

**Returns**:
A <code>pair</code> p such that <code>p.first</code> is the end of the output range beginning at <code>out&#95;true</code> and <code>p.second</code> is the end of the output range beginning at <code>out&#95;false</code>.

**See**:
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf</a>
* <code>stable&#95;partition&#95;copy</code>
* <code>partition</code>

<h3 id="function-partition-copy">
Function <code>thrust::partition&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>partition_copy</b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition&#95;copy</code> differs from <code>partition</code> only in that the reordered sequence is written to difference output sequences, rather than in place.

<code>partition&#95;copy</code> copies the elements <code>[first, last)</code> based on the function object <code>pred</code> which is applied to a range of stencil elements. All of the elements whose corresponding stencil element satisfies <code>pred</code> are copied to the range beginning at <code>out&#95;true</code> and all the elements whose stencil element fails to satisfy it are copied to the range beginning at <code>out&#95;false</code>.


The following code snippet demonstrates how to use <code>partition&#95;copy</code> to separate a sequence into two output sequences of even and odd numbers.



```cpp
#include <thrust/partition.h>
#include <thrust/functional.h>
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int S[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
int result[10];
const int N = sizeof(A)/sizeof(int);
int *evens = result;
int *odds  = result + 5;
thrust::stable_partition_copy(A, A + N, S, evens, odds, thrust::identity<int>());
// A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// S remains {0, 1, 0, 1, 0, 1, 0, 1, 0,  1}
// result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
// evens points to {2, 4, 6, 8, 10}
// odds points to {1, 3, 5, 7, 9}
```

**Note**:
The relative order of elements in the two reordered sequences is not necessarily the same as it was in the original sequence. A different algorithm, <code>stable&#95;partition&#95;copy</code>, does guarantee to preserve the relative order.

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1</code> and <code>OutputIterator2's</code><code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence to reorder. 
* **`last`** The end of the sequence to reorder. 
* **`stencil`** The beginning of the stencil sequence. 
* **`out_true`** The destination of the resulting sequence of elements which satisfy <code>pred</code>. 
* **`out_false`** The destination of the resulting sequence of elements which fail to satisfy <code>pred</code>. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The input ranges shall not overlap with either output range.

**Returns**:
A <code>pair</code> p such that <code>p.first</code> is the end of the output range beginning at <code>out&#95;true</code> and <code>p.second</code> is the end of the output range beginning at <code>out&#95;false</code>.

**See**:
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf</a>
* <code>stable&#95;partition&#95;copy</code>
* <code>partition</code>

<h3 id="function-stable-partition">
Function <code>thrust::stable&#95;partition</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>stable_partition</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>stable&#95;partition</code> is much like <code>partition</code> : it reorders the elements in the range <code>[first, last)</code> based on the function object <code>pred</code>, such that all of the elements that satisfy <code>pred</code> precede all of the elements that fail to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[first, last)</code>, <code>pred(&#42;i)</code> is <code>true</code> for every iterator <code>i</code> in the range <code>[first,middle)</code> and <code>false</code> for every iterator <code>i</code> in the range <code>[middle, last)</code>. The return value of <code>stable&#95;partition</code> is <code>middle</code>.

<code>stable&#95;partition</code> differs from <code>partition</code> in that <code>stable&#95;partition</code> is guaranteed to preserve relative order. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code>, and <code>stencil&#95;x</code> and <code>stencil&#95;y</code> are the stencil elements in corresponding positions within <code>[stencil, stencil + (last - first))</code>, and <code>pred(stencil&#95;x) == pred(stencil&#95;y)</code>, and if <code>x</code> precedes <code>y</code>, then it will still be true after <code>stable&#95;partition</code> that <code>x</code> precedes <code>y</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>stable&#95;partition</code> to reorder a sequence so that even numbers precede odd numbers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/partition.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::stable_partition(thrust::host,
                         A, A + N,
                         is_even());
// A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>, and <code>ForwardIterator</code> is mutable. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element of the sequence to reorder. 
* **`last`** One position past the last element of the sequence to reorder. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Returns**:
An iterator referring to the first element of the second partition, that is, the sequence of the elements which do not satisfy pred.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/stable_partition">https://en.cppreference.com/w/cpp/algorithm/stable_partition</a>
* <code>partition</code>
* <code>stable&#95;partition&#95;copy</code>

<h3 id="function-stable-partition">
Function <code>thrust::stable&#95;partition</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>stable_partition</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>stable&#95;partition</code> is much like <code>partition</code> : it reorders the elements in the range <code>[first, last)</code> based on the function object <code>pred</code>, such that all of the elements that satisfy <code>pred</code> precede all of the elements that fail to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[first, last)</code>, <code>pred(&#42;i)</code> is <code>true</code> for every iterator <code>i</code> in the range <code>[first,middle)</code> and <code>false</code> for every iterator <code>i</code> in the range <code>[middle, last)</code>. The return value of <code>stable&#95;partition</code> is <code>middle</code>.

<code>stable&#95;partition</code> differs from <code>partition</code> in that <code>stable&#95;partition</code> is guaranteed to preserve relative order. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code>, and <code>stencil&#95;x</code> and <code>stencil&#95;y</code> are the stencil elements in corresponding positions within <code>[stencil, stencil + (last - first))</code>, and <code>pred(stencil&#95;x) == pred(stencil&#95;y)</code>, and if <code>x</code> precedes <code>y</code>, then it will still be true after <code>stable&#95;partition</code> that <code>x</code> precedes <code>y</code>.


The following code snippet demonstrates how to use <code>stable&#95;partition</code> to reorder a sequence so that even numbers precede odd numbers.



```cpp
#include <thrust/partition.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::stable_partition(A, A + N,
                          is_even());
// A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>, and <code>ForwardIterator</code> is mutable. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The first element of the sequence to reorder. 
* **`last`** One position past the last element of the sequence to reorder. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Returns**:
An iterator referring to the first element of the second partition, that is, the sequence of the elements which do not satisfy pred.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/stable_partition">https://en.cppreference.com/w/cpp/algorithm/stable_partition</a>
* <code>partition</code>
* <code>stable&#95;partition&#95;copy</code>

<h3 id="function-stable-partition">
Function <code>thrust::stable&#95;partition</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>stable_partition</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>stable&#95;partition</code> is much like <code>partition:</code> it reorders the elements in the range <code>[first, last)</code> based on the function object <code>pred</code> applied to a stencil range <code>[stencil, stencil + (last - first))</code>, such that all of the elements whose corresponding stencil element satisfies <code>pred</code> precede all of the elements whose corresponding stencil element fails to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[first, last)</code>, <code>pred(&#42;stencil&#95;i)</code> is <code>true</code> for every iterator <code>stencil&#95;i</code> in the range <code>[stencil,stencil + (middle - first))</code> and <code>false</code> for every iterator <code>stencil&#95;i</code> in the range <code>[stencil + (middle - first), stencil + (last - first))</code>. The return value of <code>stable&#95;partition</code> is <code>middle</code>.

<code>stable&#95;partition</code> differs from <code>partition</code> in that <code>stable&#95;partition</code> is guaranteed to preserve relative order. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code>, such that <code>pred(x) == pred(y)</code>, and if <code>x</code> precedes <code>y</code>, then it will still be true after <code>stable&#95;partition</code> that <code>x</code> precedes <code>y</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>stable&#95;partition</code> to reorder a sequence so that even numbers precede odd numbers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/partition.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
int S[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::stable_partition(thrust::host, A, A + N, S, is_even());
// A is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
// S is unmodified
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element of the sequence to reorder. 
* **`last`** One position past the last element of the sequence to reorder. 
* **`stencil`** The beginning of the stencil sequence. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The range <code>[first, last)</code> shall not overlap with the range <code>[stencil, stencil + (last - first))</code>.

**Returns**:
An iterator referring to the first element of the second partition, that is, the sequence of the elements whose stencil elements do not satisfy <code>pred</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/stable_partition">https://en.cppreference.com/w/cpp/algorithm/stable_partition</a>
* <code>partition</code>
* <code>stable&#95;partition&#95;copy</code>

<h3 id="function-stable-partition">
Function <code>thrust::stable&#95;partition</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>stable_partition</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>stable&#95;partition</code> is much like <code>partition:</code> it reorders the elements in the range <code>[first, last)</code> based on the function object <code>pred</code> applied to a stencil range <code>[stencil, stencil + (last - first))</code>, such that all of the elements whose corresponding stencil element satisfies <code>pred</code> precede all of the elements whose corresponding stencil element fails to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[first, last)</code>, <code>pred(&#42;stencil&#95;i)</code> is <code>true</code> for every iterator <code>stencil&#95;i</code> in the range <code>[stencil,stencil + (middle - first))</code> and <code>false</code> for every iterator <code>stencil&#95;i</code> in the range <code>[stencil + (middle - first), stencil + (last - first))</code>. The return value of <code>stable&#95;partition</code> is <code>middle</code>.

<code>stable&#95;partition</code> differs from <code>partition</code> in that <code>stable&#95;partition</code> is guaranteed to preserve relative order. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code>, such that <code>pred(x) == pred(y)</code>, and if <code>x</code> precedes <code>y</code>, then it will still be true after <code>stable&#95;partition</code> that <code>x</code> precedes <code>y</code>.


The following code snippet demonstrates how to use <code>stable&#95;partition</code> to reorder a sequence so that even numbers precede odd numbers.



```cpp
#include <thrust/partition.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
int S[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::stable_partition(A, A + N, S, is_even());
// A is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
// S is unmodified
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The first element of the sequence to reorder. 
* **`last`** One position past the last element of the sequence to reorder. 
* **`stencil`** The beginning of the stencil sequence. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The range <code>[first, last)</code> shall not overlap with the range <code>[stencil, stencil + (last - first))</code>.

**Returns**:
An iterator referring to the first element of the second partition, that is, the sequence of the elements whose stencil elements do not satisfy <code>pred</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/stable_partition">https://en.cppreference.com/w/cpp/algorithm/stable_partition</a>
* <code>partition</code>
* <code>stable&#95;partition&#95;copy</code>

<h3 id="function-stable-partition-copy">
Function <code>thrust::stable&#95;partition&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>stable_partition_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>stable&#95;partition&#95;copy</code> differs from <code>stable&#95;partition</code> only in that the reordered sequence is written to different output sequences, rather than in place.

<code>stable&#95;partition&#95;copy</code> copies the elements <code>[first, last)</code> based on the function object <code>pred</code>. All of the elements that satisfy <code>pred</code> are copied to the range beginning at <code>out&#95;true</code> and all the elements that fail to satisfy it are copied to the range beginning at <code>out&#95;false</code>.

<code>stable&#95;partition&#95;copy</code> differs from <code>partition&#95;copy</code> in that <code>stable&#95;partition&#95;copy</code> is guaranteed to preserve relative order. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code>, such that <code>pred(x) == pred(y)</code>, and if <code>x</code> precedes <code>y</code>, then it will still be true after <code>stable&#95;partition&#95;copy</code> that <code>x</code> precedes <code>y</code> in the output.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>stable&#95;partition&#95;copy</code> to reorder a sequence so that even numbers precede odd numbers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/partition.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int result[10];
const int N = sizeof(A)/sizeof(int);
int *evens = result;
int *odds  = result + 5;
thrust::stable_partition_copy(thrust::host, A, A + N, evens, odds, is_even());
// A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
// evens points to {2, 4, 6, 8, 10}
// odds points to {1, 3, 5, 7, 9}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1</code> and <code>OutputIterator2's</code><code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element of the sequence to reorder. 
* **`last`** One position past the last element of the sequence to reorder. 
* **`out_true`** The destination of the resulting sequence of elements which satisfy <code>pred</code>. 
* **`out_false`** The destination of the resulting sequence of elements which fail to satisfy <code>pred</code>. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The input ranges shall not overlap with either output range.

**Returns**:
A <code>pair</code> p such that <code>p.first</code> is the end of the output range beginning at <code>out&#95;true</code> and <code>p.second</code> is the end of the output range beginning at <code>out&#95;false</code>.

**See**:
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf</a>
* <code>partition&#95;copy</code>
* <code>stable&#95;partition</code>

<h3 id="function-stable-partition-copy">
Function <code>thrust::stable&#95;partition&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>stable_partition_copy</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>stable&#95;partition&#95;copy</code> differs from <code>stable&#95;partition</code> only in that the reordered sequence is written to different output sequences, rather than in place.

<code>stable&#95;partition&#95;copy</code> copies the elements <code>[first, last)</code> based on the function object <code>pred</code>. All of the elements that satisfy <code>pred</code> are copied to the range beginning at <code>out&#95;true</code> and all the elements that fail to satisfy it are copied to the range beginning at <code>out&#95;false</code>.

<code>stable&#95;partition&#95;copy</code> differs from <code>partition&#95;copy</code> in that <code>stable&#95;partition&#95;copy</code> is guaranteed to preserve relative order. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code>, such that <code>pred(x) == pred(y)</code>, and if <code>x</code> precedes <code>y</code>, then it will still be true after <code>stable&#95;partition&#95;copy</code> that <code>x</code> precedes <code>y</code> in the output.


The following code snippet demonstrates how to use <code>stable&#95;partition&#95;copy</code> to reorder a sequence so that even numbers precede odd numbers.



```cpp
#include <thrust/partition.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int result[10];
const int N = sizeof(A)/sizeof(int);
int *evens = result;
int *odds  = result + 5;
thrust::stable_partition_copy(A, A + N, evens, odds, is_even());
// A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
// evens points to {2, 4, 6, 8, 10}
// odds points to {1, 3, 5, 7, 9}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1</code> and <code>OutputIterator2's</code><code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The first element of the sequence to reorder. 
* **`last`** One position past the last element of the sequence to reorder. 
* **`out_true`** The destination of the resulting sequence of elements which satisfy <code>pred</code>. 
* **`out_false`** The destination of the resulting sequence of elements which fail to satisfy <code>pred</code>. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The input ranges shall not overlap with either output range.

**Returns**:
A <code>pair</code> p such that <code>p.first</code> is the end of the output range beginning at <code>out&#95;true</code> and <code>p.second</code> is the end of the output range beginning at <code>out&#95;false</code>.

**See**:
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf</a>
* <code>partition&#95;copy</code>
* <code>stable&#95;partition</code>

<h3 id="function-stable-partition-copy">
Function <code>thrust::stable&#95;partition&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>stable_partition_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>stable&#95;partition&#95;copy</code> differs from <code>stable&#95;partition</code> only in that the reordered sequence is written to different output sequences, rather than in place.

<code>stable&#95;partition&#95;copy</code> copies the elements <code>[first, last)</code> based on the function object <code>pred</code> which is applied to a range of stencil elements. All of the elements whose corresponding stencil element satisfies <code>pred</code> are copied to the range beginning at <code>out&#95;true</code> and all the elements whose stencil element fails to satisfy it are copied to the range beginning at <code>out&#95;false</code>.

<code>stable&#95;partition&#95;copy</code> differs from <code>partition&#95;copy</code> in that <code>stable&#95;partition&#95;copy</code> is guaranteed to preserve relative order. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code>, such that <code>pred(x) == pred(y)</code>, and if <code>x</code> precedes <code>y</code>, then it will still be true after <code>stable&#95;partition&#95;copy</code> that <code>x</code> precedes <code>y</code> in the output.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>stable&#95;partition&#95;copy</code> to reorder a sequence so that even numbers precede odd numbers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/partition.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int S[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
int result[10];
const int N = sizeof(A)/sizeof(int);
int *evens = result;
int *odds  = result + 5;
thrust::stable_partition_copy(thrust::host, A, A + N, S, evens, odds, thrust::identity<int>());
// A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// S remains {0, 1, 0, 1, 0, 1, 0, 1, 0,  1}
// result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
// evens points to {2, 4, 6, 8, 10}
// odds points to {1, 3, 5, 7, 9}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1</code> and <code>OutputIterator2's</code><code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element of the sequence to reorder. 
* **`last`** One position past the last element of the sequence to reorder. 
* **`stencil`** The beginning of the stencil sequence. 
* **`out_true`** The destination of the resulting sequence of elements which satisfy <code>pred</code>. 
* **`out_false`** The destination of the resulting sequence of elements which fail to satisfy <code>pred</code>. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The input ranges shall not overlap with either output range.

**Returns**:
A <code>pair</code> p such that <code>p.first</code> is the end of the output range beginning at <code>out&#95;true</code> and <code>p.second</code> is the end of the output range beginning at <code>out&#95;false</code>.

**See**:
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf</a>
* <code>partition&#95;copy</code>
* <code>stable&#95;partition</code>

<h3 id="function-stable-partition-copy">
Function <code>thrust::stable&#95;partition&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>stable_partition_copy</b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator1 out_true,</span>
<span>&nbsp;&nbsp;OutputIterator2 out_false,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>stable&#95;partition&#95;copy</code> differs from <code>stable&#95;partition</code> only in that the reordered sequence is written to different output sequences, rather than in place.

<code>stable&#95;partition&#95;copy</code> copies the elements <code>[first, last)</code> based on the function object <code>pred</code> which is applied to a range of stencil elements. All of the elements whose corresponding stencil element satisfies <code>pred</code> are copied to the range beginning at <code>out&#95;true</code> and all the elements whose stencil element fails to satisfy it are copied to the range beginning at <code>out&#95;false</code>.

<code>stable&#95;partition&#95;copy</code> differs from <code>partition&#95;copy</code> in that <code>stable&#95;partition&#95;copy</code> is guaranteed to preserve relative order. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code>, such that <code>pred(x) == pred(y)</code>, and if <code>x</code> precedes <code>y</code>, then it will still be true after <code>stable&#95;partition&#95;copy</code> that <code>x</code> precedes <code>y</code> in the output.


The following code snippet demonstrates how to use <code>stable&#95;partition&#95;copy</code> to reorder a sequence so that even numbers precede odd numbers.



```cpp
#include <thrust/partition.h>
#include <thrust/functional.h>
...
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int S[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
int result[10];
const int N = sizeof(A)/sizeof(int);
int *evens = result;
int *odds  = result + 5;
thrust::stable_partition_copy(A, A + N, S, evens, odds, thrust::identity<int>());
// A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// S remains {0, 1, 0, 1, 0, 1, 0, 1, 0,  1}
// result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
// evens points to {2, 4, 6, 8, 10}
// odds points to {1, 3, 5, 7, 9}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1</code> and <code>OutputIterator2's</code><code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The first element of the sequence to reorder. 
* **`last`** One position past the last element of the sequence to reorder. 
* **`stencil`** The beginning of the stencil sequence. 
* **`out_true`** The destination of the resulting sequence of elements which satisfy <code>pred</code>. 
* **`out_false`** The destination of the resulting sequence of elements which fail to satisfy <code>pred</code>. 
* **`pred`** A function object which decides to which partition each element of the sequence <code>[first, last)</code> belongs. 

**Preconditions**:
The input ranges shall not overlap with either output range.

**Returns**:
A <code>pair</code> p such that <code>p.first</code> is the end of the output range beginning at <code>out&#95;true</code> and <code>p.second</code> is the end of the output range beginning at <code>out&#95;false</code>.

**See**:
* <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf</a>
* <code>partition&#95;copy</code>
* <code>stable&#95;partition</code>

<h3 id="function-partition-point">
Function <code>thrust::partition&#95;point</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>partition_point</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition&#95;point</code> returns an iterator pointing to the end of the true partition of a partitioned range. <code>partition&#95;point</code> requires the input range <code>[first,last)</code> to be a partition; that is, all elements which satisfy <code>pred</code> shall appear before those that do not.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/partition.h>
#include <thrust/execution_policy.h>

struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};

...

int A[] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};
int * B = thrust::partition_point(thrust::host, A, A + 10, is_even());
// B - A is 5
// [A, B) contains only even values
```

**Note**:
Though similar, <code>partition&#95;point</code> is not redundant with <code>find&#95;if&#95;not</code>. <code>partition&#95;point's</code> precondition provides an opportunity for a faster implemention.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range to consider. 
* **`last`** The end of the range to consider. 
* **`pred`** A function object which decides to which partition each element of the range <code>[first, last)</code> belongs. 

**Preconditions**:
The range <code>[first, last)</code> shall be partitioned by <code>pred</code>.

**Returns**:
An iterator <code>mid</code> such that <code>all&#95;of(first, mid, pred)</code> and <code>none&#95;of(mid, last, pred)</code> are both true.

**See**:
* <code>partition</code>
* <code>find&#95;if&#95;not</code>

<h3 id="function-partition-point">
Function <code>thrust::partition&#95;point</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>partition_point</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>partition&#95;point</code> returns an iterator pointing to the end of the true partition of a partitioned range. <code>partition&#95;point</code> requires the input range <code>[first,last)</code> to be a partition; that is, all elements which satisfy <code>pred</code> shall appear before those that do not. 

```cpp
#include <thrust/partition.h>

struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};

...

int A[] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};
int * B = thrust::partition_point(A, A + 10, is_even());
// B - A is 5
// [A, B) contains only even values
```

**Note**:
Though similar, <code>partition&#95;point</code> is not redundant with <code>find&#95;if&#95;not</code>. <code>partition&#95;point's</code> precondition provides an opportunity for a faster implemention.

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the range to consider. 
* **`last`** The end of the range to consider. 
* **`pred`** A function object which decides to which partition each element of the range <code>[first, last)</code> belongs. 

**Preconditions**:
The range <code>[first, last)</code> shall be partitioned by <code>pred</code>.

**Returns**:
An iterator <code>mid</code> such that <code>all&#95;of(first, mid, pred)</code> and <code>none&#95;of(mid, last, pred)</code> are both true.

**See**:
* <code>partition</code>
* <code>find&#95;if&#95;not</code>

<h3 id="function-is-partitioned">
Function <code>thrust::is&#95;partitioned</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ bool </span><span><b>is_partitioned</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>is&#95;partitioned</code> returns <code>true</code> if the given range is partitioned with respect to a predicate, and <code>false</code> otherwise.

Specifically, <code>is&#95;partitioned</code> returns <code>true</code> if <code>[first, last)</code> is empty of if <code>[first, last)</code> is partitioned by <code>pred</code>, i.e. if all elements that satisfy <code>pred</code> appear before those that do not.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/partition.h>
#include <thrust/execution_policy.h>

struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};

...

int A[] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};
int B[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

thrust::is_partitioned(thrust::host, A, A + 10, is_even()); // returns true
thrust::is_partitioned(thrust::host, B, B + 10, is_even()); // returns false
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range to consider. 
* **`last`** The end of the range to consider. 
* **`pred`** A function object which decides to which partition each element of the range <code>[first, last)</code> belongs. 

**Returns**:
<code>true</code> if the range <code>[first, last)</code> is partitioned with respect to <code>pred</code>, or if <code>[first, last)</code> is empty. <code>false</code>, otherwise.

**See**:
<code>partition</code>

<h3 id="function-is-partitioned">
Function <code>thrust::is&#95;partitioned</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>bool </span><span><b>is_partitioned</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>is&#95;partitioned</code> returns <code>true</code> if the given range is partitioned with respect to a predicate, and <code>false</code> otherwise.

Specifically, <code>is&#95;partitioned</code> returns <code>true</code> if <code>[first, last)</code> is empty of if <code>[first, last)</code> is partitioned by <code>pred</code>, i.e. if all elements that satisfy <code>pred</code> appear before those that do not.



```cpp
#include <thrust/partition.h>

struct is_even
{
  __host__ __device__
  bool operator()(const int &x)
  {
    return (x % 2) == 0;
  }
};

...

int A[] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};
int B[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

thrust::is_partitioned(A, A + 10, is_even()); // returns true
thrust::is_partitioned(B, B + 10, is_even()); // returns false
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the range to consider. 
* **`last`** The end of the range to consider. 
* **`pred`** A function object which decides to which partition each element of the range <code>[first, last)</code> belongs. 

**Returns**:
<code>true</code> if the range <code>[first, last)</code> is partitioned with respect to <code>pred</code>, or if <code>[first, last)</code> is empty. <code>false</code>, otherwise.

**See**:
<code>partition</code>

<h3 id="function-get-per-device-resource">
Function <code>thrust::get&#95;per&#95;device&#95;resource</code>
</h3>

<code class="doxybook">
<span>template &lt;typename MR,</span>
<span>&nbsp;&nbsp;typename DerivedPolicy&gt;</span>
<span>__host__ MR * </span><span><b>get_per_device_resource</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & system);</span></code>
Returns a global instance of <code>MR</code> for the current device of the provided system.

**Template Parameters**:
**`MR`**: type of a memory resource to get an instance from. Must be <code>DefaultConstructible</code>. 

**Function Parameters**:
**`system`**: execution policy for which the resource is requested. 

**Returns**:
a pointer to a global instance of <code>MR</code> for the current device. 

<h3 id="function-reduce">
Function <code>thrust::reduce</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::value_type </span><span><b>reduce</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last);</span></code>
<code>reduce</code> is a generalization of summation: it computes the sum (or some other binary operation) of all the elements in the range <code>[first, last)</code>. This version of <code>reduce</code> uses <code>0</code> as the initial value of the reduction. <code>reduce</code> is similar to the C++ Standard Template Library's <code>std::accumulate</code>. The primary difference between the two functions is that <code>std::accumulate</code> guarantees the order of summation, while <code>reduce</code> requires associativity of the binary operation to parallelize the reduction.

Note that <code>reduce</code> also assumes that the binary reduction operator (in this case operator+) is commutative. If the reduction operator is not commutative then <code>thrust::reduce</code> should not be used. Instead, one could use <code>inclusive&#95;scan</code> (which does not require commutativity) and select the last element of the output array.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>reduce</code> to compute the sum of a sequence of integers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/reduce.h>
#include <thrust/execution_policy.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int result = thrust::reduce(thrust::host, data, data + 6);

// result == 9
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and if <code>x</code> and <code>y</code> are objects of <code>InputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined and is convertible to <code>InputIterator's</code><code>value&#95;type</code>. If <code>T</code> is <code>InputIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
The result of the reduction.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a>

<h3 id="function-reduce">
Function <code>thrust::reduce</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< InputIterator >::value_type </span><span><b>reduce</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last);</span></code>
<code>reduce</code> is a generalization of summation: it computes the sum (or some other binary operation) of all the elements in the range <code>[first, last)</code>. This version of <code>reduce</code> uses <code>0</code> as the initial value of the reduction. <code>reduce</code> is similar to the C++ Standard Template Library's <code>std::accumulate</code>. The primary difference between the two functions is that <code>std::accumulate</code> guarantees the order of summation, while <code>reduce</code> requires associativity of the binary operation to parallelize the reduction.

Note that <code>reduce</code> also assumes that the binary reduction operator (in this case operator+) is commutative. If the reduction operator is not commutative then <code>thrust::reduce</code> should not be used. Instead, one could use <code>inclusive&#95;scan</code> (which does not require commutativity) and select the last element of the output array.


The following code snippet demonstrates how to use <code>reduce</code> to compute the sum of a sequence of integers.



```cpp
#include <thrust/reduce.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int result = thrust::reduce(data, data + 6);

// result == 9
```

**Template Parameters**:
**`InputIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and if <code>x</code> and <code>y</code> are objects of <code>InputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined and is convertible to <code>InputIterator's</code><code>value&#95;type</code>. If <code>T</code> is <code>InputIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
The result of the reduction.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a>

<h3 id="function-reduce">
Function <code>thrust::reduce</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ T </span><span><b>reduce</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;T init);</span></code>
<code>reduce</code> is a generalization of summation: it computes the sum (or some other binary operation) of all the elements in the range <code>[first, last)</code>. This version of <code>reduce</code> uses <code>init</code> as the initial value of the reduction. <code>reduce</code> is similar to the C++ Standard Template Library's <code>std::accumulate</code>. The primary difference between the two functions is that <code>std::accumulate</code> guarantees the order of summation, while <code>reduce</code> requires associativity of the binary operation to parallelize the reduction.

Note that <code>reduce</code> also assumes that the binary reduction operator (in this case operator+) is commutative. If the reduction operator is not commutative then <code>thrust::reduce</code> should not be used. Instead, one could use <code>inclusive&#95;scan</code> (which does not require commutativity) and select the last element of the output array.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>reduce</code> to compute the sum of a sequence of integers including an intialization value using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/reduce.h>
#include <thrust/execution_policy.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int result = thrust::reduce(thrust::host, data, data + 6, 1);

// result == 10
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and if <code>x</code> and <code>y</code> are objects of <code>InputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined and is convertible to <code>T</code>. 
* **`T`** is convertible to <code>InputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`init`** The initial value. 

**Returns**:
The result of the reduction.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a>

<h3 id="function-reduce">
Function <code>thrust::reduce</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>T </span><span><b>reduce</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;T init);</span></code>
<code>reduce</code> is a generalization of summation: it computes the sum (or some other binary operation) of all the elements in the range <code>[first, last)</code>. This version of <code>reduce</code> uses <code>init</code> as the initial value of the reduction. <code>reduce</code> is similar to the C++ Standard Template Library's <code>std::accumulate</code>. The primary difference between the two functions is that <code>std::accumulate</code> guarantees the order of summation, while <code>reduce</code> requires associativity of the binary operation to parallelize the reduction.

Note that <code>reduce</code> also assumes that the binary reduction operator (in this case operator+) is commutative. If the reduction operator is not commutative then <code>thrust::reduce</code> should not be used. Instead, one could use <code>inclusive&#95;scan</code> (which does not require commutativity) and select the last element of the output array.


The following code snippet demonstrates how to use <code>reduce</code> to compute the sum of a sequence of integers including an intialization value.



```cpp
#include <thrust/reduce.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int result = thrust::reduce(data, data + 6, 1);

// result == 10
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and if <code>x</code> and <code>y</code> are objects of <code>InputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined and is convertible to <code>T</code>. 
* **`T`** is convertible to <code>InputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`init`** The initial value. 

**Returns**:
The result of the reduction.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a>

<h3 id="function-reduce">
Function <code>thrust::reduce</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ T </span><span><b>reduce</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span></code>
<code>reduce</code> is a generalization of summation: it computes the sum (or some other binary operation) of all the elements in the range <code>[first, last)</code>. This version of <code>reduce</code> uses <code>init</code> as the initial value of the reduction and <code>binary&#95;op</code> as the binary function used for summation. <code>reduce</code> is similar to the C++ Standard Template Library's <code>std::accumulate</code>. The primary difference between the two functions is that <code>std::accumulate</code> guarantees the order of summation, while <code>reduce</code> requires associativity of <code>binary&#95;op</code> to parallelize the reduction.

Note that <code>reduce</code> also assumes that the binary reduction operator (in this case <code>binary&#95;op</code>) is commutative. If the reduction operator is not commutative then <code>thrust::reduce</code> should not be used. Instead, one could use <code>inclusive&#95;scan</code> (which does not require commutativity) and select the last element of the output array.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>reduce</code> to compute the maximum value of a sequence of integers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/reduce.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int result = thrust::reduce(thrust::host,
                            data, data + 6,
                            -1,
                            thrust::maximum<int>());
// result == 3
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>T</code>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a>, and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputType</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`init`** The initial value. 
* **`binary_op`** The binary function used to 'sum' values. 

**Returns**:
The result of the reduction.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a>
* transform_reduce 

<h3 id="function-reduce">
Function <code>thrust::reduce</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>T </span><span><b>reduce</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span></code>
<code>reduce</code> is a generalization of summation: it computes the sum (or some other binary operation) of all the elements in the range <code>[first, last)</code>. This version of <code>reduce</code> uses <code>init</code> as the initial value of the reduction and <code>binary&#95;op</code> as the binary function used for summation. <code>reduce</code> is similar to the C++ Standard Template Library's <code>std::accumulate</code>. The primary difference between the two functions is that <code>std::accumulate</code> guarantees the order of summation, while <code>reduce</code> requires associativity of <code>binary&#95;op</code> to parallelize the reduction.

Note that <code>reduce</code> also assumes that the binary reduction operator (in this case <code>binary&#95;op</code>) is commutative. If the reduction operator is not commutative then <code>thrust::reduce</code> should not be used. Instead, one could use <code>inclusive&#95;scan</code> (which does not require commutativity) and select the last element of the output array.


The following code snippet demonstrates how to use <code>reduce</code> to compute the maximum value of a sequence of integers.



```cpp
#include <thrust/reduce.h>
#include <thrust/functional.h>
...
int data[6] = {1, 0, 2, 2, 1, 3};
int result = thrust::reduce(data, data + 6,
                            -1,
                            thrust::maximum<int>());
// result == 3
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>T</code>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a>, and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputType</code>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`init`** The initial value. 
* **`binary_op`** The binary function used to 'sum' values. 

**Returns**:
The result of the reduction.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate">https://en.cppreference.com/w/cpp/algorithm/accumulate</a>
* transform_reduce 

<h3 id="function-reduce-by-key">
Function <code>thrust::reduce&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>reduce_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output);</span></code>
<code>reduce&#95;by&#95;key</code> is a generalization of <code>reduce</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>reduce&#95;by&#95;key</code> copies the first element of the group to the <code>keys&#95;output</code>. The corresponding values in the range are reduced using the <code>plus</code> and the result copied to <code>values&#95;output</code>.

This version of <code>reduce&#95;by&#95;key</code> uses the function object <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html">equal&#95;to</a></code> to test for equality and <code>plus</code> to reduce values with equal keys.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>reduce&#95;by&#95;key</code> to compact a sequence of key/value pairs and sum values with equal keys using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/reduce.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
new_end = thrust::reduce_by_key(thrust::host, A, A + N, B, C, D);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_output`** The beginning of the output key range. 
* **`values_output`** The beginning of the output value range. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;output, keys&#95;output&#95;last)</code> and <code>[values&#95;output, values&#95;output&#95;last)</code>.

**See**:
* reduce 
* unique_copy 
* unique_by_key 
* unique_by_key_copy 

<h3 id="function-reduce-by-key">
Function <code>thrust::reduce&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>reduce_by_key</b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output);</span></code>
<code>reduce&#95;by&#95;key</code> is a generalization of <code>reduce</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>reduce&#95;by&#95;key</code> copies the first element of the group to the <code>keys&#95;output</code>. The corresponding values in the range are reduced using the <code>plus</code> and the result copied to <code>values&#95;output</code>.

This version of <code>reduce&#95;by&#95;key</code> uses the function object <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html">equal&#95;to</a></code> to test for equality and <code>plus</code> to reduce values with equal keys.


The following code snippet demonstrates how to use <code>reduce&#95;by&#95;key</code> to compact a sequence of key/value pairs and sum values with equal keys.



```cpp
#include <thrust/reduce.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
new_end = thrust::reduce_by_key(A, A + N, B, C, D);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_output`** The beginning of the output key range. 
* **`values_output`** The beginning of the output value range. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;output, keys&#95;output&#95;last)</code> and <code>[values&#95;output, values&#95;output&#95;last)</code>.

**See**:
* reduce 
* unique_copy 
* unique_by_key 
* unique_by_key_copy 

<h3 id="function-reduce-by-key">
Function <code>thrust::reduce&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>reduce_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>reduce&#95;by&#95;key</code> is a generalization of <code>reduce</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>reduce&#95;by&#95;key</code> copies the first element of the group to the <code>keys&#95;output</code>. The corresponding values in the range are reduced using the <code>plus</code> and the result copied to <code>values&#95;output</code>.

This version of <code>reduce&#95;by&#95;key</code> uses the function object <code>binary&#95;pred</code> to test for equality and <code>plus</code> to reduce values with equal keys.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>reduce&#95;by&#95;key</code> to compact a sequence of key/value pairs and sum values with equal keys using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/reduce.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
thrust::equal_to<int> binary_pred;
new_end = thrust::reduce_by_key(thrust::host, A, A + N, B, C, D, binary_pred);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_output`** The beginning of the output key range. 
* **`values_output`** The beginning of the output value range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;output, keys&#95;output&#95;last)</code> and <code>[values&#95;output, values&#95;output&#95;last)</code>.

**See**:
* reduce 
* unique_copy 
* unique_by_key 
* unique_by_key_copy 

<h3 id="function-reduce-by-key">
Function <code>thrust::reduce&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>reduce_by_key</b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>reduce&#95;by&#95;key</code> is a generalization of <code>reduce</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>reduce&#95;by&#95;key</code> copies the first element of the group to the <code>keys&#95;output</code>. The corresponding values in the range are reduced using the <code>plus</code> and the result copied to <code>values&#95;output</code>.

This version of <code>reduce&#95;by&#95;key</code> uses the function object <code>binary&#95;pred</code> to test for equality and <code>plus</code> to reduce values with equal keys.


The following code snippet demonstrates how to use <code>reduce&#95;by&#95;key</code> to compact a sequence of key/value pairs and sum values with equal keys.



```cpp
#include <thrust/reduce.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
thrust::equal_to<int> binary_pred;
new_end = thrust::reduce_by_key(A, A + N, B, C, D, binary_pred);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_output`** The beginning of the output key range. 
* **`values_output`** The beginning of the output value range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;output, keys&#95;output&#95;last)</code> and <code>[values&#95;output, values&#95;output&#95;last)</code>.

**See**:
* reduce 
* unique_copy 
* unique_by_key 
* unique_by_key_copy 

<h3 id="function-reduce-by-key">
Function <code>thrust::reduce&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>reduce_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span></code>
<code>reduce&#95;by&#95;key</code> is a generalization of <code>reduce</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>reduce&#95;by&#95;key</code> copies the first element of the group to the <code>keys&#95;output</code>. The corresponding values in the range are reduced using the <code>BinaryFunction</code><code>binary&#95;op</code> and the result copied to <code>values&#95;output</code>. Specifically, if consecutive key iterators <code>i</code> and <code></code>(i + 1) are such that <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is <code>true</code>, then the corresponding values are reduced to a single value with <code>binary&#95;op</code>.

This version of <code>reduce&#95;by&#95;key</code> uses the function object <code>binary&#95;pred</code> to test for equality and <code>binary&#95;op</code> to reduce values with equal keys.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>reduce&#95;by&#95;key</code> to compact a sequence of key/value pairs and sum values with equal keys using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/reduce.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
thrust::equal_to<int> binary_pred;
thrust::plus<int> binary_op;
new_end = thrust::reduce_by_key(thrust::host, A, A + N, B, C, D, binary_pred, binary_op);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_output`** The beginning of the output key range. 
* **`values_output`** The beginning of the output value range. 
* **`binary_pred`** The binary predicate used to determine equality. 
* **`binary_op`** The binary function used to accumulate values. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;output, keys&#95;output&#95;last)</code> and <code>[values&#95;output, values&#95;output&#95;last)</code>.

**See**:
* reduce 
* unique_copy 
* unique_by_key 
* unique_by_key_copy 

<h3 id="function-reduce-by-key">
Function <code>thrust::reduce&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>reduce_by_key</b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_output,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_output,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span></code>
<code>reduce&#95;by&#95;key</code> is a generalization of <code>reduce</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>reduce&#95;by&#95;key</code> copies the first element of the group to the <code>keys&#95;output</code>. The corresponding values in the range are reduced using the <code>BinaryFunction</code><code>binary&#95;op</code> and the result copied to <code>values&#95;output</code>. Specifically, if consecutive key iterators <code>i</code> and <code></code>(i + 1) are such that <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is <code>true</code>, then the corresponding values are reduced to a single value with <code>binary&#95;op</code>.

This version of <code>reduce&#95;by&#95;key</code> uses the function object <code>binary&#95;pred</code> to test for equality and <code>binary&#95;op</code> to reduce values with equal keys.


The following code snippet demonstrates how to use <code>reduce&#95;by&#95;key</code> to compact a sequence of key/value pairs and sum values with equal keys.



```cpp
#include <thrust/reduce.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
thrust::equal_to<int> binary_pred;
thrust::plus<int> binary_op;
new_end = thrust::reduce_by_key(A, A + N, B, C, D, binary_pred, binary_op);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_output`** The beginning of the output key range. 
* **`values_output`** The beginning of the output value range. 
* **`binary_pred`** The binary predicate used to determine equality. 
* **`binary_op`** The binary function used to accumulate values. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;output, keys&#95;output&#95;last)</code> and <code>[values&#95;output, values&#95;output&#95;last)</code>.

**See**:
* reduce 
* unique_copy 
* unique_by_key 
* unique_by_key_copy 

<h3 id="function-remove">
Function <code>thrust::remove</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>remove</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>remove</code> removes from the range <code>[first, last)</code> all elements that are equal to <code>value</code>. That is, <code>remove</code> returns an iterator <code>new&#95;last</code> such that the range <code>[first, new&#95;last)</code> contains no elements equal to <code>value</code>. The iterators in the range <code>[new&#95;first,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove</code> is stable, meaning that the relative order of elements that are not equal to <code>value</code> is unchanged.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>remove</code> to remove a number of interest from a range using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/remove.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int A[N] = {3, 1, 4, 1, 5, 9};
int *new_end = thrust::remove(A, A + N, 1);
// The first four values of A are now {3, 4, 5, 9}
// Values beyond new_end are unspecified
```

**Note**:
The meaning of "removal" is somewhat subtle. <code>remove</code> does not destroy any iterators, and does not change the distance between <code>first</code> and <code>last</code>. (There's no way that it could do anything of the sort.) So, for example, if <code>V</code> is a <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device_vector</a>, <code>remove(V.begin(), V.end(), 0)</code> does not change <code>V.size()</code>: <code>V</code> will contain just as many elements as it did before. <code>remove</code> returns an iterator that points to the end of the resulting range after elements have been removed from it; it follows that the elements after that iterator are of no interest, and may be discarded. If you are removing elements from a <a href="https://en.cppreference.com/w/cpp/container">Sequence</a>, you may simply erase them. That is, a reasonable way of removing elements from a <a href="https://en.cppreference.com/w/cpp/container">Sequence</a> is <code>S.erase(remove(S.begin(), S.end(), x), S.end())</code>.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, and objects of type <code>T</code> can be compared for equality with objects of <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`value`** The value to remove from the range <code>[first, last)</code>. Elements which are equal to value are removed from the sequence. 

**Returns**:
A <code>ForwardIterator</code> pointing to the end of the resulting range of elements which are not equal to <code>value</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove">https://en.cppreference.com/w/cpp/algorithm/remove</a>
* remove_if 
* remove_copy 
* remove_copy_if 

<h3 id="function-remove">
Function <code>thrust::remove</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>ForwardIterator </span><span><b>remove</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>remove</code> removes from the range <code>[first, last)</code> all elements that are equal to <code>value</code>. That is, <code>remove</code> returns an iterator <code>new&#95;last</code> such that the range <code>[first, new&#95;last)</code> contains no elements equal to <code>value</code>. The iterators in the range <code>[new&#95;first,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove</code> is stable, meaning that the relative order of elements that are not equal to <code>value</code> is unchanged.


The following code snippet demonstrates how to use <code>remove</code> to remove a number of interest from a range.



```cpp
#include <thrust/remove.h>
...
const int N = 6;
int A[N] = {3, 1, 4, 1, 5, 9};
int *new_end = thrust::remove(A, A + N, 1);
// The first four values of A are now {3, 4, 5, 9}
// Values beyond new_end are unspecified
```

**Note**:
The meaning of "removal" is somewhat subtle. <code>remove</code> does not destroy any iterators, and does not change the distance between <code>first</code> and <code>last</code>. (There's no way that it could do anything of the sort.) So, for example, if <code>V</code> is a <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device_vector</a>, <code>remove(V.begin(), V.end(), 0)</code> does not change <code>V.size()</code>: <code>V</code> will contain just as many elements as it did before. <code>remove</code> returns an iterator that points to the end of the resulting range after elements have been removed from it; it follows that the elements after that iterator are of no interest, and may be discarded. If you are removing elements from a <a href="https://en.cppreference.com/w/cpp/container">Sequence</a>, you may simply erase them. That is, a reasonable way of removing elements from a <a href="https://en.cppreference.com/w/cpp/container">Sequence</a> is <code>S.erase(remove(S.begin(), S.end(), x), S.end())</code>.

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, and objects of type <code>T</code> can be compared for equality with objects of <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`value`** The value to remove from the range <code>[first, last)</code>. Elements which are equal to value are removed from the sequence. 

**Returns**:
A <code>ForwardIterator</code> pointing to the end of the resulting range of elements which are not equal to <code>value</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove">https://en.cppreference.com/w/cpp/algorithm/remove</a>
* remove_if 
* remove_copy 
* remove_copy_if 

<h3 id="function-remove-copy">
Function <code>thrust::remove&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>remove_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>remove&#95;copy</code> copies elements that are not equal to <code>value</code> from the range <code>[first, last)</code> to a range beginning at <code>result</code>. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as in the range <code>[first, last)</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>remove&#95;copy</code> to copy a sequence of numbers to an output range while omitting a value of interest using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/remove.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int V[N] = {-2, 0, -1, 0, 1, 2};
int result[N-2];
thrust::remove_copy(thrust::host, V, V + N, result, 0);
// V remains {-2, 0, -1, 0, 1, 2}
// result is now {-2, -1, 1, 2}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, and objects of type <code>T</code> can be compared for equality with objects of <code>InputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`result`** The resulting range is copied to the sequence beginning at this location. 
* **`value`** The value to omit from the copied range. 

**Preconditions**:
The range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code>.

**Returns**:
An OutputIterator pointing to the end of the resulting range of elements which are not equal to <code>value</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove_copy">https://en.cppreference.com/w/cpp/algorithm/remove_copy</a>
* remove 
* remove_if 
* remove_copy_if 

<h3 id="function-remove-copy">
Function <code>thrust::remove&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b>remove_copy</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;const T & value);</span></code>
<code>remove&#95;copy</code> copies elements that are not equal to <code>value</code> from the range <code>[first, last)</code> to a range beginning at <code>result</code>. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as in the range <code>[first, last)</code>.


The following code snippet demonstrates how to use <code>remove&#95;copy</code> to copy a sequence of numbers to an output range while omitting a value of interest.



```cpp
#include <thrust/remove.h>
...
const int N = 6;
int V[N] = {-2, 0, -1, 0, 1, 2};
int result[N-2];
thrust::remove_copy(V, V + N, result, 0);
// V remains {-2, 0, -1, 0, 1, 2}
// result is now {-2, -1, 1, 2}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, and objects of type <code>T</code> can be compared for equality with objects of <code>InputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`result`** The resulting range is copied to the sequence beginning at this location. 
* **`value`** The value to omit from the copied range. 

**Preconditions**:
The range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code>.

**Returns**:
An OutputIterator pointing to the end of the resulting range of elements which are not equal to <code>value</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove_copy">https://en.cppreference.com/w/cpp/algorithm/remove_copy</a>
* remove 
* remove_if 
* remove_copy_if 

<h3 id="function-remove-if">
Function <code>thrust::remove&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>remove_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>remove&#95;if</code> removes from the range <code>[first, last)</code> every element <code>x</code> such that <code>pred(x)</code> is <code>true</code>. That is, <code>remove&#95;if</code> returns an iterator <code>new&#95;last</code> such that the range <code>[first,new&#95;last)</code> contains no elements for which <code>pred</code> is <code>true</code>. The iterators in the range <code>[new&#95;last,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove&#95;if</code> is stable, meaning that the relative order of elements that are not removed is unchanged.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>remove&#95;if</code> to remove all even numbers from an array of integers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/remove.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
int *new_end = thrust::remove_if(thrust::host, A, A + N, is_even());
// The first three values of A are now {1, 5, 7}
// Values beyond new_end are unspecified
```

**Note**:
The meaning of "removal" is somewhat subtle. <code>remove&#95;if</code> does not destroy any iterators, and does not change the distance between <code>first</code> and <code>last</code>. (There's no way that it could do anything of the sort.) So, for example, if <code>V</code> is a <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device_vector</a>, <code>remove&#95;if(V.begin(), V.end(), pred)</code> does not change <code>V.size()</code>: <code>V</code> will contain just as many elements as it did before. <code>remove&#95;if</code> returns an iterator that points to the end of the resulting range after elements have been removed from it; it follows that the elements after that iterator are of no interest, and may be discarded. If you are removing elements from a <a href="https://en.cppreference.com/w/cpp/container">Sequence</a>, you may simply erase them. That is, a reasonable way of removing elements from a <a href="https://en.cppreference.com/w/cpp/container">Sequence</a> is <code>S.erase(remove&#95;if(S.begin(), S.end(), pred), S.end())</code>.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`pred`** A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>true</code> are removed from the sequence. 

**Returns**:
A ForwardIterator pointing to the end of the resulting range of elements for which <code>pred</code> evaluated to <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove">https://en.cppreference.com/w/cpp/algorithm/remove</a>
* remove 
* remove_copy 
* remove_copy_if 

<h3 id="function-remove-if">
Function <code>thrust::remove&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>remove_if</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>remove&#95;if</code> removes from the range <code>[first, last)</code> every element <code>x</code> such that <code>pred(x)</code> is <code>true</code>. That is, <code>remove&#95;if</code> returns an iterator <code>new&#95;last</code> such that the range <code>[first,new&#95;last)</code> contains no elements for which <code>pred</code> is <code>true</code>. The iterators in the range <code>[new&#95;last,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove&#95;if</code> is stable, meaning that the relative order of elements that are not removed is unchanged.


The following code snippet demonstrates how to use <code>remove&#95;if</code> to remove all even numbers from an array of integers.



```cpp
#include <thrust/remove.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
int *new_end = thrust::remove_if(A, A + N, is_even());
// The first three values of A are now {1, 5, 7}
// Values beyond new_end are unspecified
```

**Note**:
The meaning of "removal" is somewhat subtle. <code>remove&#95;if</code> does not destroy any iterators, and does not change the distance between <code>first</code> and <code>last</code>. (There's no way that it could do anything of the sort.) So, for example, if <code>V</code> is a <a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device_vector</a>, <code>remove&#95;if(V.begin(), V.end(), pred)</code> does not change <code>V.size()</code>: <code>V</code> will contain just as many elements as it did before. <code>remove&#95;if</code> returns an iterator that points to the end of the resulting range after elements have been removed from it; it follows that the elements after that iterator are of no interest, and may be discarded. If you are removing elements from a <a href="https://en.cppreference.com/w/cpp/container">Sequence</a>, you may simply erase them. That is, a reasonable way of removing elements from a <a href="https://en.cppreference.com/w/cpp/container">Sequence</a> is <code>S.erase(remove&#95;if(S.begin(), S.end(), pred), S.end())</code>.

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`pred`** A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>true</code> are removed from the sequence. 

**Returns**:
A ForwardIterator pointing to the end of the resulting range of elements for which <code>pred</code> evaluated to <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove">https://en.cppreference.com/w/cpp/algorithm/remove</a>
* remove 
* remove_copy 
* remove_copy_if 

<h3 id="function-remove-copy-if">
Function <code>thrust::remove&#95;copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>remove_copy_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>remove&#95;copy&#95;if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that elements for which <code>pred</code> is <code>true</code> are not copied. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as the range <code>[first,last)</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>remove&#95;copy&#95;if</code> to copy a sequence of numbers to an output range while omitting even numbers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/remove.h>
#include <thrust/execution_policy.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...
const int N = 6;
int V[N] = {-2, 0, -1, 0, 1, 2};
int result[2];
thrust::remove_copy_if(thrust::host, V, V + N, result, is_even());
// V remains {-2, 0, -1, 0, 1, 2}
// result is now {-1, 1}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`result`** The resulting range is copied to the sequence beginning at this location. 
* **`pred`** A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are not copied to the resulting sequence. 

**Preconditions**:
The range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code>.

**Returns**:
An OutputIterator pointing to the end of the resulting range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove_copy">https://en.cppreference.com/w/cpp/algorithm/remove_copy</a>
* remove 
* remove_copy 
* remove_if 

<h3 id="function-remove-copy-if">
Function <code>thrust::remove&#95;copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b>remove_copy_if</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>remove&#95;copy&#95;if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that elements for which <code>pred</code> is <code>true</code> are not copied. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as the range <code>[first,last)</code>.


The following code snippet demonstrates how to use <code>remove&#95;copy&#95;if</code> to copy a sequence of numbers to an output range while omitting even numbers.



```cpp
#include <thrust/remove.h>
...
struct is_even
{
  __host__ __device__
  bool operator()(const int x)
  {
    return (x % 2) == 0;
  }
};
...
const int N = 6;
int V[N] = {-2, 0, -1, 0, 1, 2};
int result[2];
thrust::remove_copy_if(V, V + N, result, is_even());
// V remains {-2, 0, -1, 0, 1, 2}
// result is now {-1, 1}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`result`** The resulting range is copied to the sequence beginning at this location. 
* **`pred`** A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are not copied to the resulting sequence. 

**Preconditions**:
The range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code>.

**Returns**:
An OutputIterator pointing to the end of the resulting range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove_copy">https://en.cppreference.com/w/cpp/algorithm/remove_copy</a>
* remove 
* remove_copy 
* remove_if 

<h3 id="function-remove-if">
Function <code>thrust::remove&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>remove_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>remove&#95;if</code> removes from the range <code>[first, last)</code> every element <code>x</code> such that <code>pred(x)</code> is <code>true</code>. That is, <code>remove&#95;if</code> returns an iterator <code>new&#95;last</code> such that the range <code>[first, new&#95;last)</code> contains no elements for which <code>pred</code> of the corresponding stencil value is <code>true</code>. The iterators in the range <code>[new&#95;last,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove&#95;if</code> is stable, meaning that the relative order of elements that are not removed is unchanged.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>remove&#95;if</code> to remove specific elements from an array of integers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/remove.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
int S[N] = {0, 1, 1, 1, 0, 0};

int *new_end = thrust::remove_if(thrust::host, A, A + N, S, thrust::identity<int>());
// The first three values of A are now {1, 5, 7}
// Values beyond new_end are unspecified
```

**Note**:
The range <code>[first, last)</code> is not permitted to overlap with the range <code>[stencil, stencil + (last - first))</code>.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a> and <code>ForwardIterator</code> is mutable. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`stencil`** The beginning of the stencil sequence. 
* **`pred`** A predicate to evaluate for each element of the range <code>[stencil, stencil + (last - first))</code>. Elements for which <code>pred</code> evaluates to <code>true</code> are removed from the sequence <code>[first, last)</code>

**Preconditions**:
* The range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code>. 
* The range <code>[stencil, stencil + (last - first))</code> shall not overlap the range <code>[result, result + (last - first))</code>.

**Returns**:
A ForwardIterator pointing to the end of the resulting range of elements for which <code>pred</code> evaluated to <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove">https://en.cppreference.com/w/cpp/algorithm/remove</a>
* remove 
* remove_copy 
* remove_copy_if 

<h3 id="function-remove-if">
Function <code>thrust::remove&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>remove_if</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>remove&#95;if</code> removes from the range <code>[first, last)</code> every element <code>x</code> such that <code>pred(x)</code> is <code>true</code>. That is, <code>remove&#95;if</code> returns an iterator <code>new&#95;last</code> such that the range <code>[first, new&#95;last)</code> contains no elements for which <code>pred</code> of the corresponding stencil value is <code>true</code>. The iterators in the range <code>[new&#95;last,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove&#95;if</code> is stable, meaning that the relative order of elements that are not removed is unchanged.


The following code snippet demonstrates how to use <code>remove&#95;if</code> to remove specific elements from an array of integers.



```cpp
#include <thrust/remove.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
int S[N] = {0, 1, 1, 1, 0, 0};

int *new_end = thrust::remove_if(A, A + N, S, thrust::identity<int>());
// The first three values of A are now {1, 5, 7}
// Values beyond new_end are unspecified
```

**Note**:
The range <code>[first, last)</code> is not permitted to overlap with the range <code>[stencil, stencil + (last - first))</code>.

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a> and <code>ForwardIterator</code> is mutable. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`stencil`** The beginning of the stencil sequence. 
* **`pred`** A predicate to evaluate for each element of the range <code>[stencil, stencil + (last - first))</code>. Elements for which <code>pred</code> evaluates to <code>true</code> are removed from the sequence <code>[first, last)</code>

**Preconditions**:
* The range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code>. 
* The range <code>[stencil, stencil + (last - first))</code> shall not overlap the range <code>[result, result + (last - first))</code>.

**Returns**:
A ForwardIterator pointing to the end of the resulting range of elements for which <code>pred</code> evaluated to <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove">https://en.cppreference.com/w/cpp/algorithm/remove</a>
* remove 
* remove_copy 
* remove_copy_if 

<h3 id="function-remove-copy-if">
Function <code>thrust::remove&#95;copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>remove_copy_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>remove&#95;copy&#95;if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that elements for which <code>pred</code> of the corresponding stencil value is <code>true</code> are not copied. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as the range <code>[first,last)</code>.

The algorithm's execution policy is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>remove&#95;copy&#95;if</code> to copy a sequence of numbers to an output range while omitting specific elements using the <code>thrust::host</code> execution policy for parallelization.



```cpp
#include <thrust/remove.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int V[N] = {-2, 0, -1, 0, 1, 2};
int S[N] = { 1, 1,  0, 1, 0, 1};
int result[2];
thrust::remove_copy_if(thrust::host, V, V + N, S, result, thrust::identity<int>());
// V remains {-2, 0, -1, 0, 1, 2}
// result is now {-1, 1}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The resulting range is copied to the sequence beginning at this location. 
* **`pred`** A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are not copied to the resulting sequence. 

**Preconditions**:
The range <code>[stencil, stencil + (last - first))</code> shall not overlap the range <code>[result, result + (last - first))</code>.

**Returns**:
An OutputIterator pointing to the end of the resulting range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove_copy">https://en.cppreference.com/w/cpp/algorithm/remove_copy</a>
* remove 
* remove_copy 
* remove_if 
* copy_if 

<h3 id="function-remove-copy-if">
Function <code>thrust::remove&#95;copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>OutputIterator </span><span><b>remove_copy_if</b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>remove&#95;copy&#95;if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that elements for which <code>pred</code> of the corresponding stencil value is <code>true</code> are not copied. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as the range <code>[first,last)</code>.


The following code snippet demonstrates how to use <code>remove&#95;copy&#95;if</code> to copy a sequence of numbers to an output range while omitting specific elements.



```cpp
#include <thrust/remove.h>
...
const int N = 6;
int V[N] = {-2, 0, -1, 0, 1, 2};
int S[N] = { 1, 1,  0, 1, 0, 1};
int result[2];
thrust::remove_copy_if(V, V + N, S, result, thrust::identity<int>());
// V remains {-2, 0, -1, 0, 1, 2}
// result is now {-1, 1}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The resulting range is copied to the sequence beginning at this location. 
* **`pred`** A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are not copied to the resulting sequence. 

**Preconditions**:
The range <code>[stencil, stencil + (last - first))</code> shall not overlap the range <code>[result, result + (last - first))</code>.

**Returns**:
An OutputIterator pointing to the end of the resulting range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/remove_copy">https://en.cppreference.com/w/cpp/algorithm/remove_copy</a>
* remove 
* remove_copy 
* remove_if 
* copy_if 

<h3 id="function-replace">
Function <code>thrust::replace</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b>replace</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & old_value,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace</code> replaces every element in the range [first, last) equal to <code>old&#95;value</code> with <code>new&#95;value</code>. That is: for every iterator <code>i</code>, if <code>&#42;i == old&#95;value</code> then it performs the <code>assignment &#42;i = new&#95;value</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>replace</code> to replace a value of interest in a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> with another using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>

...

thrust::device_vector<int> A(4);
A[0] = 1;
A[1] = 2;
A[2] = 3;
A[3] = 1;

thrust::replace(thrust::device, A.begin(), A.end(), 1, 99);

// A contains [99, 2, 3, 99]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable>Assignable">Assignable</a>, <code>T</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">EqualityComparable</a>, objects of <code>T</code> may be compared for equality with objects of <code>ForwardIterator's</code><code>value&#95;type</code>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence of interest. 
* **`last`** The end of the sequence of interest. 
* **`old_value`** The value to replace. 
* **`new_value`** The new value to replace <code>old&#95;value</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace">https://en.cppreference.com/w/cpp/algorithm/replace</a>
* <code>replace&#95;if</code>
* <code>replace&#95;copy</code>
* <code>replace&#95;copy&#95;if</code>

<h3 id="function-replace">
Function <code>thrust::replace</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b>replace</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & old_value,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace</code> replaces every element in the range [first, last) equal to <code>old&#95;value</code> with <code>new&#95;value</code>. That is: for every iterator <code>i</code>, if <code>&#42;i == old&#95;value</code> then it performs the <code>assignment &#42;i = new&#95;value</code>.


The following code snippet demonstrates how to use <code>replace</code> to replace a value of interest in a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> with another.



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>

...

thrust::device_vector<int> A(4);
A[0] = 1;
A[1] = 2;
A[2] = 3;
A[3] = 1;

thrust::replace(A.begin(), A.end(), 1, 99);

// A contains [99, 2, 3, 99]
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable>Assignable">Assignable</a>, <code>T</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">EqualityComparable</a>, objects of <code>T</code> may be compared for equality with objects of <code>ForwardIterator's</code><code>value&#95;type</code>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence of interest. 
* **`last`** The end of the sequence of interest. 
* **`old_value`** The value to replace. 
* **`new_value`** The new value to replace <code>old&#95;value</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace">https://en.cppreference.com/w/cpp/algorithm/replace</a>
* <code>replace&#95;if</code>
* <code>replace&#95;copy</code>
* <code>replace&#95;copy&#95;if</code>

<h3 id="function-replace-if">
Function <code>thrust::replace&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b>replace_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace&#95;if</code> replaces every element in the range <code>[first, last)</code> for which <code>pred</code> returns <code>true</code> with <code>new&#95;value</code>. That is: for every iterator <code>i</code>, if <code>pred(&#42;i)</code> is <code>true</code> then it performs the assignment <code>&#42;i = new&#95;value</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>replace&#95;if</code> to replace a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a>'s</code> negative elements with <code>0</code> using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
struct is_less_than_zero
{
  __host__ __device__
  bool operator()(int x)
  {
    return x < 0;
  }
};

...

thrust::device_vector<int> A(4);
A[0] =  1;
A[1] = -3;
A[2] =  2;
A[3] = -1;

is_less_than_zero pred;

thrust::replace_if(thrust::device, A.begin(), A.end(), pred, 0);

// A contains [1, 0, 2, 0]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence of interest. 
* **`last`** The end of the sequence of interest. 
* **`pred`** The predicate to test on every value of the range <code>[first,last)</code>. 
* **`new_value`** The new value to replace elements which <code>pred(&#42;i)</code> evaluates to <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace">https://en.cppreference.com/w/cpp/algorithm/replace</a>
* <code>replace</code>
* <code>replace&#95;copy</code>
* <code>replace&#95;copy&#95;if</code>

<h3 id="function-replace-if">
Function <code>thrust::replace&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b>replace_if</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace&#95;if</code> replaces every element in the range <code>[first, last)</code> for which <code>pred</code> returns <code>true</code> with <code>new&#95;value</code>. That is: for every iterator <code>i</code>, if <code>pred(&#42;i)</code> is <code>true</code> then it performs the assignment <code>&#42;i = new&#95;value</code>.


The following code snippet demonstrates how to use <code>replace&#95;if</code> to replace a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a>'s</code> negative elements with <code>0</code>.



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>
...
struct is_less_than_zero
{
  __host__ __device__
  bool operator()(int x)
  {
    return x < 0;
  }
};

...

thrust::device_vector<int> A(4);
A[0] =  1;
A[1] = -3;
A[2] =  2;
A[3] = -1;

is_less_than_zero pred;

thrust::replace_if(A.begin(), A.end(), pred, 0);

// A contains [1, 0, 2, 0]
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence of interest. 
* **`last`** The end of the sequence of interest. 
* **`pred`** The predicate to test on every value of the range <code>[first,last)</code>. 
* **`new_value`** The new value to replace elements which <code>pred(&#42;i)</code> evaluates to <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace">https://en.cppreference.com/w/cpp/algorithm/replace</a>
* <code>replace</code>
* <code>replace&#95;copy</code>
* <code>replace&#95;copy&#95;if</code>

<h3 id="function-replace-if">
Function <code>thrust::replace&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b>replace_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace&#95;if</code> replaces every element in the range <code>[first, last)</code> for which <code>pred(&#42;s)</code> returns <code>true</code> with <code>new&#95;value</code>. That is: for every iterator <code>i</code> in the range <code>[first, last)</code>, and <code>s</code> in the range <code>[stencil, stencil + (last - first))</code>, if <code>pred(&#42;s)</code> is <code>true</code> then it performs the assignment <code>&#42;i = new&#95;value</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>replace&#95;if</code> to replace a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a>'s</code> element with <code>0</code> when its corresponding stencil element is less than zero using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>

struct is_less_than_zero
{
  __host__ __device__
  bool operator()(int x)
  {
    return x < 0;
  }
};

...

thrust::device_vector<int> A(4);
A[0] =  10;
A[1] =  20;
A[2] =  30;
A[3] =  40;

thrust::device_vector<int> S(4);
S[0] = -1;
S[1] =  0;
S[2] = -1;
S[3] =  0;

is_less_than_zero pred;
thrust::replace_if(thrust::device, A.begin(), A.end(), S.begin(), pred, 0);

// A contains [0, 20, 0, 40]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence of interest. 
* **`last`** The end of the sequence of interest. 
* **`stencil`** The beginning of the stencil sequence. 
* **`pred`** The predicate to test on every value of the range <code>[first,last)</code>. 
* **`new_value`** The new value to replace elements which <code>pred(&#42;i)</code> evaluates to <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace">https://en.cppreference.com/w/cpp/algorithm/replace</a>
* <code>replace</code>
* <code>replace&#95;copy</code>
* <code>replace&#95;copy&#95;if</code>

<h3 id="function-replace-if">
Function <code>thrust::replace&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b>replace_if</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;InputIterator stencil,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace&#95;if</code> replaces every element in the range <code>[first, last)</code> for which <code>pred(&#42;s)</code> returns <code>true</code> with <code>new&#95;value</code>. That is: for every iterator <code>i</code> in the range <code>[first, last)</code>, and <code>s</code> in the range <code>[stencil, stencil + (last - first))</code>, if <code>pred(&#42;s)</code> is <code>true</code> then it performs the assignment <code>&#42;i = new&#95;value</code>.


The following code snippet demonstrates how to use <code>replace&#95;if</code> to replace a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a>'s</code> element with <code>0</code> when its corresponding stencil element is less than zero.



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>

struct is_less_than_zero
{
  __host__ __device__
  bool operator()(int x)
  {
    return x < 0;
  }
};

...

thrust::device_vector<int> A(4);
A[0] =  10;
A[1] =  20;
A[2] =  30;
A[3] =  40;

thrust::device_vector<int> S(4);
S[0] = -1;
S[1] =  0;
S[2] = -1;
S[3] =  0;

is_less_than_zero pred;
thrust::replace_if(A.begin(), A.end(), S.begin(), pred, 0);

// A contains [0, 20, 0, 40]
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence of interest. 
* **`last`** The end of the sequence of interest. 
* **`stencil`** The beginning of the stencil sequence. 
* **`pred`** The predicate to test on every value of the range <code>[first,last)</code>. 
* **`new_value`** The new value to replace elements which <code>pred(&#42;i)</code> evaluates to <code>true</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace">https://en.cppreference.com/w/cpp/algorithm/replace</a>
* <code>replace</code>
* <code>replace&#95;copy</code>
* <code>replace&#95;copy&#95;if</code>

<h3 id="function-replace-copy">
Function <code>thrust::replace&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>replace_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;const T & old_value,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace&#95;copy</code> copies elements from the range <code>[first, last)</code> to the range <code>[result, result + (last-first))</code>, except that any element equal to <code>old&#95;value</code> is not copied; <code>new&#95;value</code> is copied instead.

More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>replace&#95;copy</code> performs the assignment <code>&#42;(result+n) = new&#95;value</code> if <code>&#42;(first+n) == old&#95;value</code>, and <code>&#42;(result+n) = &#42;(first+n)</code> otherwise.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> A(4);
A[0] = 1;
A[1] = 2;
A[2] = 3;
A[3] = 1;

thrust::device_vector<int> B(4);

thrust::replace_copy(thrust::device, A.begin(), A.end(), B.begin(), 1, 99);

// B contains [99, 2, 3, 99]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, <code>T</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, <code>T</code> may be compared for equality with <code>InputIterator's</code><code>value&#95;type</code>, and <code>T</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to copy from. 
* **`last`** The end of the sequence to copy from. 
* **`result`** The beginning of the sequence to copy to. 
* **`old_value`** The value to replace. 
* **`new_value`** The replacement value for which <code>&#42;i == old&#95;value</code> evaluates to <code>true</code>. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
<code>result + (last-first)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace_copy">https://en.cppreference.com/w/cpp/algorithm/replace_copy</a>
* <code>copy</code>
* <code>replace</code>
* <code>replace&#95;if</code>
* <code>replace&#95;copy&#95;if</code>

<h3 id="function-replace-copy">
Function <code>thrust::replace&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b>replace_copy</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;const T & old_value,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace&#95;copy</code> copies elements from the range <code>[first, last)</code> to the range <code>[result, result + (last-first))</code>, except that any element equal to <code>old&#95;value</code> is not copied; <code>new&#95;value</code> is copied instead.

More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>replace&#95;copy</code> performs the assignment <code>&#42;(result+n) = new&#95;value</code> if <code>&#42;(first+n) == old&#95;value</code>, and <code>&#42;(result+n) = &#42;(first+n)</code> otherwise.



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> A(4);
A[0] = 1;
A[1] = 2;
A[2] = 3;
A[3] = 1;

thrust::device_vector<int> B(4);

thrust::replace_copy(A.begin(), A.end(), B.begin(), 1, 99);

// B contains [99, 2, 3, 99]
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, <code>T</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>, <code>T</code> may be compared for equality with <code>InputIterator's</code><code>value&#95;type</code>, and <code>T</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence to copy from. 
* **`last`** The end of the sequence to copy from. 
* **`result`** The beginning of the sequence to copy to. 
* **`old_value`** The value to replace. 
* **`new_value`** The replacement value for which <code>&#42;i == old&#95;value</code> evaluates to <code>true</code>. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
<code>result + (last-first)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace_copy">https://en.cppreference.com/w/cpp/algorithm/replace_copy</a>
* <code>copy</code>
* <code>replace</code>
* <code>replace&#95;if</code>
* <code>replace&#95;copy&#95;if</code>

<h3 id="function-replace-copy-if">
Function <code>thrust::replace&#95;copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>replace_copy_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace&#95;copy&#95;if</code> copies elements from the range <code>[first, last)</code> to the range <code>[result, result + (last-first))</code>, except that any element for which <code>pred</code> is <code>true</code> is not copied; <code>new&#95;value</code> is copied instead.

More precisely, for every integer <code>n</code> such that 0 <= n < last-first, <code>replace&#95;copy&#95;if</code> performs the assignment <code>&#42;(result+n) = new&#95;value</code> if <code>pred(&#42;(first+n))</code>, and <code>&#42;(result+n) = &#42;(first+n)</code> otherwise.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>

struct is_less_than_zero
{
  __host__ __device__
  bool operator()(int x)
  {
    return x < 0;
  }
};

...

thrust::device_vector<int> A(4);
A[0] =  1;
A[1] = -3;
A[2] =  2;
A[3] = -1;

thrust::device_vector<int> B(4);
is_less_than_zero pred;

thrust::replace_copy_if(thrust::device, A.begin(), A.end(), B.begin(), pred, 0);

// B contains [1, 0, 2, 0]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to copy from. 
* **`last`** The end of the sequence to copy from. 
* **`result`** The beginning of the sequence to copy to. 
* **`pred`** The predicate to test on every value of the range <code>[first,last)</code>. 
* **`new_value`** The replacement value to assign <code>pred(&#42;i)</code> evaluates to <code>true</code>. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
<code>result + (last-first)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace_copy">https://en.cppreference.com/w/cpp/algorithm/replace_copy</a>
* <code>replace</code>
* <code>replace&#95;if</code>
* <code>replace&#95;copy</code>

<h3 id="function-replace-copy-if">
Function <code>thrust::replace&#95;copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b>replace_copy_if</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
<code>replace&#95;copy&#95;if</code> copies elements from the range <code>[first, last)</code> to the range <code>[result, result + (last-first))</code>, except that any element for which <code>pred</code> is <code>true</code> is not copied; <code>new&#95;value</code> is copied instead.

More precisely, for every integer <code>n</code> such that 0 <= n < last-first, <code>replace&#95;copy&#95;if</code> performs the assignment <code>&#42;(result+n) = new&#95;value</code> if <code>pred(&#42;(first+n))</code>, and <code>&#42;(result+n) = &#42;(first+n)</code> otherwise.



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>

struct is_less_than_zero
{
  __host__ __device__
  bool operator()(int x)
  {
    return x < 0;
  }
};

...

thrust::device_vector<int> A(4);
A[0] =  1;
A[1] = -3;
A[2] =  2;
A[3] = -1;

thrust::device_vector<int> B(4);
is_less_than_zero pred;

thrust::replace_copy_if(A.begin(), A.end(), B.begin(), pred, 0);

// B contains [1, 0, 2, 0]
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence to copy from. 
* **`last`** The end of the sequence to copy from. 
* **`result`** The beginning of the sequence to copy to. 
* **`pred`** The predicate to test on every value of the range <code>[first,last)</code>. 
* **`new_value`** The replacement value to assign <code>pred(&#42;i)</code> evaluates to <code>true</code>. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
<code>result + (last-first)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/replace_copy">https://en.cppreference.com/w/cpp/algorithm/replace_copy</a>
* <code>replace</code>
* <code>replace&#95;if</code>
* <code>replace&#95;copy</code>

<h3 id="function-replace-copy-if">
Function <code>thrust::replace&#95;copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>replace_copy_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
This version of <code>replace&#95;copy&#95;if</code> copies elements from the range <code>[first, last)</code> to the range <code>[result, result + (last-first))</code>, except that any element whose corresponding stencil element causes <code>pred</code> to be <code>true</code> is not copied; <code>new&#95;value</code> is copied instead.

More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>replace&#95;copy&#95;if</code> performs the assignment <code>&#42;(result+n) = new&#95;value</code> if <code>pred(&#42;(stencil+n))</code>, and <code>&#42;(result+n) = &#42;(first+n)</code> otherwise.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>

struct is_less_than_zero
{
  __host__ __device__
  bool operator()(int x)
  {
    return x < 0;
  }
};

...

thrust::device_vector<int> A(4);
A[0] =  10;
A[1] =  20;
A[2] =  30;
A[3] =  40;

thrust::device_vector<int> S(4);
S[0] = -1;
S[1] =  0;
S[2] = -1;
S[3] =  0;

thrust::device_vector<int> B(4);
is_less_than_zero pred;

thrust::replace_if(thrust::device, A.begin(), A.end(), S.begin(), B.begin(), pred, 0);

// B contains [0, 20, 0, 40]
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to copy from. 
* **`last`** The end of the sequence to copy from. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The beginning of the sequence to copy to. 
* **`pred`** The predicate to test on every value of the range <code>[stencil, stencil + (last - first))</code>. 
* **`new_value`** The replacement value to assign when <code>pred(&#42;s)</code> evaluates to <code>true</code>. 

**Preconditions**:
* <code>first</code> may equal <code>result</code>, but the ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap otherwise. 
* <code>stencil</code> may equal <code>result</code>, but the ranges <code>[stencil, stencil + (last - first))</code> and <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
<code>result + (last-first)</code>

**See**:
* <code>replace&#95;copy</code>
* <code>replace&#95;if</code>

<h3 id="function-replace-copy-if">
Function <code>thrust::replace&#95;copy&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename Predicate,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b>replace_copy_if</b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;Predicate pred,</span>
<span>&nbsp;&nbsp;const T & new_value);</span></code>
This version of <code>replace&#95;copy&#95;if</code> copies elements from the range <code>[first, last)</code> to the range <code>[result, result + (last-first))</code>, except that any element whose corresponding stencil element causes <code>pred</code> to be <code>true</code> is not copied; <code>new&#95;value</code> is copied instead.

More precisely, for every integer <code>n</code> such that <code>0 &lt;= n &lt; last-first</code>, <code>replace&#95;copy&#95;if</code> performs the assignment <code>&#42;(result+n) = new&#95;value</code> if <code>pred(&#42;(stencil+n))</code>, and <code>&#42;(result+n) = &#42;(first+n)</code> otherwise.



```cpp
#include <thrust/replace.h>
#include <thrust/device_vector.h>

struct is_less_than_zero
{
  __host__ __device__
  bool operator()(int x)
  {
    return x < 0;
  }
};

...

thrust::device_vector<int> A(4);
A[0] =  10;
A[1] =  20;
A[2] =  30;
A[3] =  40;

thrust::device_vector<int> S(4);
S[0] = -1;
S[1] =  0;
S[2] = -1;
S[3] =  0;

thrust::device_vector<int> B(4);
is_less_than_zero pred;

thrust::replace_if(A.begin(), A.end(), S.begin(), B.begin(), pred, 0);

// B contains [0, 20, 0, 40]
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence to copy from. 
* **`last`** The end of the sequence to copy from. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The beginning of the sequence to copy to. 
* **`pred`** The predicate to test on every value of the range <code>[stencil, stencil + (last - first))</code>. 
* **`new_value`** The replacement value to assign when <code>pred(&#42;s)</code> evaluates to <code>true</code>. 

**Preconditions**:
* <code>first</code> may equal <code>result</code>, but the ranges <code>[first, last)</code> and <code>[result, result + (last - first))</code> shall not overlap otherwise. 
* <code>stencil</code> may equal <code>result</code>, but the ranges <code>[stencil, stencil + (last - first))</code> and <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
<code>result + (last-first)</code>

**See**:
* <code>replace&#95;copy</code>
* <code>replace&#95;if</code>

<h3 id="function-reverse">
Function <code>thrust::reverse</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename BidirectionalIterator&gt;</span>
<span>__host__ __device__ void </span><span><b>reverse</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;BidirectionalIterator first,</span>
<span>&nbsp;&nbsp;BidirectionalIterator last);</span></code>
<code>reverse</code> reverses a range. That is: for every <code>i</code> such that <code>0 &lt;= i &lt;= (last - first) / 2</code>, it exchanges <code>&#42;(first + i)</code> and <code>&#42;(last - (i + 1))</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>reverse</code> to reverse a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> of integers using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/reverse.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int data[N] = {0, 1, 2, 3, 4, 5};
thrust::device_vector<int> v(data, data + N);
thrust::reverse(thrust::device, v.begin(), v.end());
// v is now {5, 4, 3, 2, 1, 0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`BidirectionalIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator">Bidirectional Iterator</a> and <code>BidirectionalIterator</code> is mutable.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range to reverse. 
* **`last`** The end of the range to reverse.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/reverse">https://en.cppreference.com/w/cpp/algorithm/reverse</a>
* <code>reverse&#95;copy</code>
* <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">reverse&#95;iterator</a></code>

<h3 id="function-reverse">
Function <code>thrust::reverse</code>
</h3>

<code class="doxybook">
<span>template &lt;typename BidirectionalIterator&gt;</span>
<span>void </span><span><b>reverse</b>(BidirectionalIterator first,</span>
<span>&nbsp;&nbsp;BidirectionalIterator last);</span></code>
<code>reverse</code> reverses a range. That is: for every <code>i</code> such that <code>0 &lt;= i &lt;= (last - first) / 2</code>, it exchanges <code>&#42;(first + i)</code> and <code>&#42;(last - (i + 1))</code>.


The following code snippet demonstrates how to use <code>reverse</code> to reverse a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> of integers.



```cpp
#include <thrust/reverse.h>
...
const int N = 6;
int data[N] = {0, 1, 2, 3, 4, 5};
thrust::device_vector<int> v(data, data + N);
thrust::reverse(v.begin(), v.end());
// v is now {5, 4, 3, 2, 1, 0}
```

**Template Parameters**:
**`BidirectionalIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator">Bidirectional Iterator</a> and <code>BidirectionalIterator</code> is mutable.

**Function Parameters**:
* **`first`** The beginning of the range to reverse. 
* **`last`** The end of the range to reverse.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/reverse">https://en.cppreference.com/w/cpp/algorithm/reverse</a>
* <code>reverse&#95;copy</code>
* <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">reverse&#95;iterator</a></code>

<h3 id="function-reverse-copy">
Function <code>thrust::reverse&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename BidirectionalIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>reverse_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;BidirectionalIterator first,</span>
<span>&nbsp;&nbsp;BidirectionalIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>reverse&#95;copy</code> differs from <code>reverse</code> only in that the reversed range is written to a different output range, rather than inplace.

<code>reverse&#95;copy</code> copies elements from the range <code>[first, last)</code> to the range <code>[result, result + (last - first))</code> such that the copy is a reverse of the original range. Specifically: for every <code>i</code> such that <code>0 &lt;= i &lt; (last - first)</code>, <code>reverse&#95;copy</code> performs the assignment <code>&#42;(result + (last - first) - i) = &#42;(first + i)</code>.

The return value is <code>result + (last - first))</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>reverse&#95;copy</code> to reverse an input <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> of integers to an output <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/reverse.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int data[N] = {0, 1, 2, 3, 4, 5};
thrust::device_vector<int> input(data, data + N);
thrust::device_vector<int> output(N);
thrust::reverse_copy(thrust::device, v.begin(), v.end(), output.begin());
// input is still {0, 1, 2, 3, 4, 5}
// output is now  {5, 4, 3, 2, 1, 0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`BidirectionalIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator">Bidirectional Iterator</a>, and <code>BidirectionalIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range to reverse. 
* **`last`** The end of the range to reverse. 
* **`result`** The beginning of the output range.

**Preconditions**:
The range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/reverse_copy">https://en.cppreference.com/w/cpp/algorithm/reverse_copy</a>
* <code>reverse</code>
* <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">reverse&#95;iterator</a></code>

<h3 id="function-reverse-copy">
Function <code>thrust::reverse&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename BidirectionalIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>reverse_copy</b>(BidirectionalIterator first,</span>
<span>&nbsp;&nbsp;BidirectionalIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>reverse&#95;copy</code> differs from <code>reverse</code> only in that the reversed range is written to a different output range, rather than inplace.

<code>reverse&#95;copy</code> copies elements from the range <code>[first, last)</code> to the range <code>[result, result + (last - first))</code> such that the copy is a reverse of the original range. Specifically: for every <code>i</code> such that <code>0 &lt;= i &lt; (last - first)</code>, <code>reverse&#95;copy</code> performs the assignment <code>&#42;(result + (last - first) - i) = &#42;(first + i)</code>.

The return value is <code>result + (last - first))</code>.


The following code snippet demonstrates how to use <code>reverse&#95;copy</code> to reverse an input <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> of integers to an output <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code>.



```cpp
#include <thrust/reverse.h>
...
const int N = 6;
int data[N] = {0, 1, 2, 3, 4, 5};
thrust::device_vector<int> input(data, data + N);
thrust::device_vector<int> output(N);
thrust::reverse_copy(v.begin(), v.end(), output.begin());
// input is still {0, 1, 2, 3, 4, 5}
// output is now  {5, 4, 3, 2, 1, 0}
```

**Template Parameters**:
* **`BidirectionalIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator">Bidirectional Iterator</a>, and <code>BidirectionalIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first`** The beginning of the range to reverse. 
* **`last`** The end of the range to reverse. 
* **`result`** The beginning of the output range.

**Preconditions**:
The range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/reverse_copy">https://en.cppreference.com/w/cpp/algorithm/reverse_copy</a>
* <code>reverse</code>
* <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1reverse__iterator.html">reverse&#95;iterator</a></code>

<h3 id="function-inclusive-scan">
Function <code>thrust::inclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>inclusive_scan</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>inclusive&#95;scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. More precisely, <code>&#42;first</code> is assigned to <code>&#42;result</code> and the sum of <code>&#42;first</code> and <code>&#42;(first + 1)</code> is assigned to <code>&#42;(result + 1)</code>, and so on. This version of <code>inclusive&#95;scan</code> assumes plus as the associative operator. 

 When the input and output sequences are the same, the scan is performed in-place.

<code>inclusive&#95;scan</code> is similar to <code>std::partial&#95;sum</code> in the STL. The primary difference between the two functions is that <code>std::partial&#95;sum</code> guarantees a serial summation order, while <code>inclusive&#95;scan</code> requires associativity of the binary operation to parallelize the prefix sum.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>inclusive&#95;scan</code> to compute an in-place prefix sum using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/execution_policy.h>
...

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::inclusive_scan(thrust::host, data, data + 6, data); // in-place scan

// data is now {1, 1, 3, 5, 6, 9}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-inclusive-scan">
Function <code>thrust::inclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>inclusive_scan</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>inclusive&#95;scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. More precisely, <code>&#42;first</code> is assigned to <code>&#42;result</code> and the sum of <code>&#42;first</code> and <code>&#42;(first + 1)</code> is assigned to <code>&#42;(result + 1)</code>, and so on. This version of <code>inclusive&#95;scan</code> assumes plus as the associative operator. 

 When the input and output sequences are the same, the scan is performed in-place.

<code>inclusive&#95;scan</code> is similar to <code>std::partial&#95;sum</code> in the STL. The primary difference between the two functions is that <code>std::partial&#95;sum</code> guarantees a serial summation order, while <code>inclusive&#95;scan</code> requires associativity of the binary operation to parallelize the prefix sum.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>inclusive&#95;scan</code>



```cpp
#include <thrust/scan.h>

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::inclusive_scan(data, data + 6, data); // in-place scan

// data is now {1, 1, 3, 5, 6, 9}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-inclusive-scan">
Function <code>thrust::inclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>inclusive_scan</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>inclusive&#95;scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. When the input and output sequences are the same, the scan is performed in-place.

<code>inclusive&#95;scan</code> is similar to <code>std::partial&#95;sum</code> in the STL. The primary difference between the two functions is that <code>std::partial&#95;sum</code> guarantees a serial summation order, while <code>inclusive&#95;scan</code> requires associativity of the binary operation to parallelize the prefix sum.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>inclusive&#95;scan</code> to compute an in-place prefix sum using the <code>thrust::host</code> execution policy for parallelization:



```cpp
int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

thrust::maximum<int> binary_op;

thrust::inclusive_scan(thrust::host, data, data + 10, data, binary_op); // in-place scan

// data is now {-5, 0, 2, 2, 2, 4, 4, 4, 4, 8}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and <code>OutputIterator's</code><code>value&#95;type</code> is convertible to both <code>AssociativeOperator's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`binary_op`** The associatve operator used to 'sum' values. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-inclusive-scan">
Function <code>thrust::inclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b>inclusive_scan</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>inclusive&#95;scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. When the input and output sequences are the same, the scan is performed in-place.

<code>inclusive&#95;scan</code> is similar to <code>std::partial&#95;sum</code> in the STL. The primary difference between the two functions is that <code>std::partial&#95;sum</code> guarantees a serial summation order, while <code>inclusive&#95;scan</code> requires associativity of the binary operation to parallelize the prefix sum.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>inclusive&#95;scan</code>



```cpp
int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

thrust::maximum<int> binary_op;

thrust::inclusive_scan(data, data + 10, data, binary_op); // in-place scan

// data is now {-5, 0, 2, 2, 2, 4, 4, 4, 4, 8}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and <code>OutputIterator's</code><code>value&#95;type</code> is convertible to both <code>AssociativeOperator's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`binary_op`** The associatve operator used to 'sum' values. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-exclusive-scan">
Function <code>thrust::exclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>exclusive_scan</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>exclusive&#95;scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>0</code> is assigned to <code>&#42;result</code> and the sum of <code>0</code> and <code>&#42;first</code> is assigned to <code>&#42;(result + 1)</code>, and so on. This version of <code>exclusive&#95;scan</code> assumes plus as the associative operator and <code>0</code> as the initial value. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>exclusive&#95;scan</code> to compute an in-place prefix sum using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/execution_policy.h>
...

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::exclusive_scan(thrust::host, data, data + 6, data); // in-place scan

// data is now {0, 1, 1, 3, 5, 6}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-exclusive-scan">
Function <code>thrust::exclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>exclusive_scan</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>exclusive&#95;scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>0</code> is assigned to <code>&#42;result</code> and the sum of <code>0</code> and <code>&#42;first</code> is assigned to <code>&#42;(result + 1)</code>, and so on. This version of <code>exclusive&#95;scan</code> assumes plus as the associative operator and <code>0</code> as the initial value. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>exclusive&#95;scan</code>



```cpp
#include <thrust/scan.h>

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::exclusive_scan(data, data + 6, data); // in-place scan

// data is now {0, 1, 1, 3, 5, 6}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-exclusive-scan">
Function <code>thrust::exclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>exclusive_scan</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init);</span></code>
<code>exclusive&#95;scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>&#42;result</code> and the sum of <code>init</code> and <code>&#42;first</code> is assigned to <code>&#42;(result + 1)</code>, and so on. This version of <code>exclusive&#95;scan</code> assumes plus as the associative operator but requires an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>exclusive&#95;scan</code> to compute an in-place prefix sum using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/execution_policy.h>

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::exclusive_scan(thrust::host, data, data + 6, data, 4); // in-place scan

// data is now {4, 5, 5, 7, 9, 10}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined. 
* **`T`** is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`init`** The initial value. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-exclusive-scan">
Function <code>thrust::exclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b>exclusive_scan</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init);</span></code>
<code>exclusive&#95;scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>&#42;result</code> and the sum of <code>init</code> and <code>&#42;first</code> is assigned to <code>&#42;(result + 1)</code>, and so on. This version of <code>exclusive&#95;scan</code> assumes plus as the associative operator but requires an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>exclusive&#95;scan</code>



```cpp
#include <thrust/scan.h>

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::exclusive_scan(data, data + 6, data, 4); // in-place scan

// data is now {4, 5, 5, 7, 9, 10}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined. 
* **`T`** is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`init`** The initial value. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-exclusive-scan">
Function <code>thrust::exclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>exclusive_scan</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>exclusive&#95;scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>&#42;result</code> and the value <code>binary&#95;op(init, &#42;first)</code> is assigned to <code>&#42;(result + 1)</code>, and so on. This version of the function requires both an associative operator and an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>exclusive&#95;scan</code> to compute an in-place prefix sum using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

thrust::maximum<int> binary_op;

thrust::exclusive_scan(thrust::host, data, data + 10, data, 1, binary_op); // in-place scan

// data is now {1, 1, 1, 2, 2, 2, 4, 4, 4, 4 }
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and <code>OutputIterator's</code><code>value&#95;type</code> is convertible to both <code>AssociativeOperator's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`T`** is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`init`** The initial value. 
* **`binary_op`** The associatve operator used to 'sum' values. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-exclusive-scan">
Function <code>thrust::exclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b>exclusive_scan</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>exclusive&#95;scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>&#42;result</code> and the value <code>binary&#95;op(init, &#42;first)</code> is assigned to <code>&#42;(result + 1)</code>, and so on. This version of the function requires both an associative operator and an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>exclusive&#95;scan</code>



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>

int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

thrust::maximum<int> binary_op;

thrust::exclusive_scan(data, data + 10, data, 1, binary_op); // in-place scan

// data is now {1, 1, 1, 2, 2, 2, 4, 4, 4, 4 }
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and <code>OutputIterator's</code><code>value&#95;type</code> is convertible to both <code>AssociativeOperator's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`T`** is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`init`** The initial value. 
* **`binary_op`** The associatve operator used to 'sum' values. 

**Preconditions**:
<code>first</code> may equal <code>result</code> but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum">https://en.cppreference.com/w/cpp/algorithm/partial_sum</a>

<h3 id="function-inclusive-scan-by-key">
Function <code>thrust::inclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>inclusive_scan_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html">equal&#95;to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>&#42;i == &#42;(i+1)</code>, and belong to different segments otherwise.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/execution_policy.h>
...

int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

thrust::inclusive_scan_by_key(thrust::host, keys, keys + 10, data, data); // in-place scan

// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* inclusive_scan 
* exclusive_scan_by_key 

<h3 id="function-inclusive-scan-by-key">
Function <code>thrust::inclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>inclusive_scan_by_key</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html">equal&#95;to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>&#42;i == &#42;(i+1)</code>, and belong to different segments otherwise.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code>



```cpp
#include <thrust/scan.h>

int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

thrust::inclusive_scan_by_key(keys, keys + 10, data, data); // in-place scan

// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined.

**Function Parameters**:
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* inclusive_scan 
* exclusive_scan_by_key 

<h3 id="function-inclusive-scan-by-key">
Function <code>thrust::inclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>inclusive_scan_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

thrust::equal_to<int> binary_pred;

thrust::inclusive_scan_by_key(thrust::host, keys, keys + 10, data, data, binary_pred); // in-place scan

// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`binary_pred`** The binary predicate used to determine equality of keys. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* inclusive_scan 
* exclusive_scan_by_key 

<h3 id="function-inclusive-scan-by-key">
Function <code>thrust::inclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>OutputIterator </span><span><b>inclusive_scan_by_key</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code>



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>

int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

thrust::equal_to<int> binary_pred;

thrust::inclusive_scan_by_key(keys, keys + 10, data, data, binary_pred); // in-place scan

// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`binary_pred`** The binary predicate used to determine equality of keys. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* inclusive_scan 
* exclusive_scan_by_key 

<h3 id="function-inclusive-scan-by-key">
Function <code>thrust::inclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>inclusive_scan_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the associative operator <code>binary&#95;op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

thrust::equal_to<int> binary_pred;
thrust::plus<int>     binary_op;

thrust::inclusive_scan_by_key(thrust::host, keys, keys + 10, data, data, binary_pred, binary_op); // in-place scan

// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`binary_pred`** The binary predicate used to determine equality of keys. 
* **`binary_op`** The associatve operator used to 'sum' values. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* inclusive_scan 
* exclusive_scan_by_key 

<h3 id="function-inclusive-scan-by-key">
Function <code>thrust::inclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b>inclusive_scan_by_key</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

This version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the associative operator <code>binary&#95;op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.


The following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code>



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>

int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

thrust::equal_to<int> binary_pred;
thrust::plus<int>     binary_op;

thrust::inclusive_scan_by_key(keys, keys + 10, data, data, binary_pred, binary_op); // in-place scan

// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`binary_pred`** The binary predicate used to determine equality of keys. 
* **`binary_op`** The associatve operator used to 'sum' values. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* inclusive_scan 
* exclusive_scan_by_key 

<h3 id="function-exclusive-scan-by-key">
Function <code>thrust::exclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>exclusive_scan_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive segmented prefix

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>0</code> to initialize the exclusive scan operation.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> assumes <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html">equal&#95;to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1</code> belong to the same segment if <code>&#42;i == &#42;(i+1)</code>, and belong to different segments otherwise.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

Refer to the most general form of <code>exclusive&#95;scan&#95;by&#95;key</code> for additional details.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/execution_policy.h>
...

int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

thrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals); // in-place scan

// vals is now {0, 1, 2, 0, 1, 0, 0, 1, 2, 3};
```

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence.

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**See**:
exclusive_scan 

<h3 id="function-exclusive-scan-by-key">
Function <code>thrust::exclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>exclusive_scan_by_key</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive segmented prefix

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>0</code> to initialize the exclusive scan operation.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> assumes <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html">equal&#95;to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1</code> belong to the same segment if <code>&#42;i == &#42;(i+1)</code>, and belong to different segments otherwise.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

Refer to the most general form of <code>exclusive&#95;scan&#95;by&#95;key</code> for additional details.


The following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code>.



```cpp
#include <thrust/scan.h>

int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

thrust::exclusive_scan_by_key(key, key + 10, vals, vals); // in-place scan

// vals is now {0, 1, 2, 0, 1, 0, 0, 1, 2, 3};
```

**Function Parameters**:
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence.

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**See**:
exclusive_scan 

<h3 id="function-exclusive-scan-by-key">
Function <code>thrust::exclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>exclusive_scan_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init);</span></code>
<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

int init = 5;

thrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals, init); // in-place scan

// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};
```

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`init`** The initial of the exclusive sum value. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* exclusive_scan 
* inclusive_scan_by_key 

<h3 id="function-exclusive-scan-by-key">
Function <code>thrust::exclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>OutputIterator </span><span><b>exclusive_scan_by_key</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init);</span></code>
<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code>



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>

int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

int init = 5;

thrust::exclusive_scan_by_key(key, key + 10, vals, vals, init); // in-place scan

// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};
```

**Function Parameters**:
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`init`** The initial of the exclusive sum value. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* exclusive_scan 
* inclusive_scan_by_key 

<h3 id="function-exclusive-scan-by-key">
Function <code>thrust::exclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>exclusive_scan_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>binary&#95;pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

int init = 5;

thrust::equal_to<int> binary_pred;

thrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals, init, binary_pred); // in-place scan

// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};
```

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`init`** The initial of the exclusive sum value. 
* **`binary_pred`** The binary predicate used to determine equality of keys. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* exclusive_scan 
* inclusive_scan_by_key 

<h3 id="function-exclusive-scan-by-key">
Function <code>thrust::exclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>OutputIterator </span><span><b>exclusive_scan_by_key</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>binary&#95;pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code>



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>

int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

int init = 5;

thrust::equal_to<int> binary_pred;

thrust::exclusive_scan_by_key(key, key + 10, vals, vals, init, binary_pred); // in-place scan

// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};
```

**Function Parameters**:
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`init`** The initial of the exclusive sum value. 
* **`binary_pred`** The binary predicate used to determine equality of keys. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* exclusive_scan 
* inclusive_scan_by_key 

<h3 id="function-exclusive-scan-by-key">
Function <code>thrust::exclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>exclusive_scan_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>binary&#95;pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the associative operator <code>binary&#95;op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

int init = 5;

thrust::equal_to<int> binary_pred;
thrust::plus<int>     binary_op;

thrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals, init, binary_pred, binary_op); // in-place scan

// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. 
* **`T`** is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`init`** The initial of the exclusive sum value. 
* **`binary_pred`** The binary predicate used to determine equality of keys. 
* **`binary_op`** The associatve operator used to 'sum' values. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* exclusive_scan 
* inclusive_scan_by_key 

<h3 id="function-exclusive-scan-by-key">
Function <code>thrust::exclusive&#95;scan&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b>exclusive_scan_by_key</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>binary&#95;pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.

This version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the associative operator <code>binary&#95;op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.

Results are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.


The following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code>



```cpp
#include <thrust/scan.h>
#include <thrust/functional.h>

int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

int init = 5;

thrust::equal_to<int> binary_pred;
thrust::plus<int>     binary_op;

thrust::exclusive_scan_by_key(key, key + 10, vals, vals, init, binary_pred, binary_op); // in-place scan

// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. 
* **`T`** is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first1`** The beginning of the key sequence. 
* **`last1`** The end of the key sequence. 
* **`first2`** The beginning of the input value sequence. 
* **`result`** The beginning of the output value sequence. 
* **`init`** The initial of the exclusive sum value. 
* **`binary_pred`** The binary predicate used to determine equality of keys. 
* **`binary_op`** The associatve operator used to 'sum' values. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. 
* <code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* exclusive_scan 
* inclusive_scan_by_key 

<h3 id="function-scatter">
Function <code>thrust::scatter</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>__host__ __device__ void </span><span><b>scatter</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;RandomAccessIterator result);</span></code>
<code>scatter</code> copies elements from a source range into an output array according to a map. For each iterator <code>i</code> in the range [<code>first</code>, <code>last</code>), the value <code>&#42;i</code> is assigned to <code>output[&#42;(map + (i - first))]</code>. The output iterator must permit random access. If the same index appears more than once in the range <code>[map, map + (last - first))</code>, the result is undefined.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>scatter</code> to reorder a range using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/scatter.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
// mark even indices with a 1; odd indices with a 0
int values[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
thrust::device_vector<int> d_values(values, values + 10);

// scatter all even indices into the first half of the
// range, and odd indices vice versa
int map[10]   = {0, 5, 1, 6, 2, 7, 3, 8, 4, 9};
thrust::device_vector<int> d_map(map, map + 10);

thrust::device_vector<int> d_output(10);
thrust::scatter(thrust::device,
                d_values.begin(), d_values.end(),
                d_map.begin(), d_output.begin());
// d_output is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
```

**Note**:
<code>scatter</code> is the inverse of thrust::gather. 

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>value&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** Beginning of the sequence of values to scatter. 
* **`last`** End of the sequence of values to scatter. 
* **`map`** Beginning of the sequence of output indices. 
* **`result`** Destination of the source elements.

**Preconditions**:
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[first,last)</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[map,map + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The expression <code>result[&#42;i]</code> shall be valid for all iterators in the range <code>[map,map + (last - first))</code>.

<h3 id="function-scatter">
Function <code>thrust::scatter</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>void </span><span><b>scatter</b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;RandomAccessIterator result);</span></code>
<code>scatter</code> copies elements from a source range into an output array according to a map. For each iterator <code>i</code> in the range [<code>first</code>, <code>last</code>), the value <code>&#42;i</code> is assigned to <code>output[&#42;(map + (i - first))]</code>. The output iterator must permit random access. If the same index appears more than once in the range <code>[map, map + (last - first))</code>, the result is undefined.


The following code snippet demonstrates how to use <code>scatter</code> to reorder a range.



```cpp
#include <thrust/scatter.h>
#include <thrust/device_vector.h>
...
// mark even indices with a 1; odd indices with a 0
int values[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
thrust::device_vector<int> d_values(values, values + 10);

// scatter all even indices into the first half of the
// range, and odd indices vice versa
int map[10]   = {0, 5, 1, 6, 2, 7, 3, 8, 4, 9};
thrust::device_vector<int> d_map(map, map + 10);

thrust::device_vector<int> d_output(10);
thrust::scatter(d_values.begin(), d_values.end(),
                d_map.begin(), d_output.begin());
// d_output is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
```

**Note**:
<code>scatter</code> is the inverse of thrust::gather. 

**Template Parameters**:
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>value&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a>.

**Function Parameters**:
* **`first`** Beginning of the sequence of values to scatter. 
* **`last`** End of the sequence of values to scatter. 
* **`map`** Beginning of the sequence of output indices. 
* **`result`** Destination of the source elements.

**Preconditions**:
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[first,last)</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[map,map + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The expression <code>result[&#42;i]</code> shall be valid for all iterators in the range <code>[map,map + (last - first))</code>.

<h3 id="function-scatter-if">
Function <code>thrust::scatter&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>__host__ __device__ void </span><span><b>scatter_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator output);</span></code>
<code>scatter&#95;if</code> conditionally copies elements from a source range into an output array according to a map. For each iterator <code>i</code> in the range <code>[first, last)</code> such that <code>&#42;(stencil + (i - first))</code> is true, the value <code>&#42;i</code> is assigned to <code>output[&#42;(map + (i - first))]</code>. The output iterator must permit random access. If the same index appears more than once in the range <code>[map, map + (last - first))</code> the result is undefined.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/scatter.h>
#include <thrust/execution_policy.h>
...
int V[8] = {10, 20, 30, 40, 50, 60, 70, 80};
int M[8] = {0, 5, 1, 6, 2, 7, 3, 4};
int S[8] = {1, 0, 1, 0, 1, 0, 1, 0};
int D[8] = {0, 0, 0, 0, 0, 0, 0, 0};

thrust::scatter_if(thrust::host, V, V + 8, M, S, D);

// D contains [10, 30, 50, 70, 0, 0, 0, 0];
```

**Note**:
<code>scatter&#95;if</code> is the inverse of thrust::gather_if. 

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>value&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`InputIterator3`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator3's</code><code>value&#95;type</code> must be convertible to <code>bool</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** Beginning of the sequence of values to scatter. 
* **`last`** End of the sequence of values to scatter. 
* **`map`** Beginning of the sequence of output indices. 
* **`stencil`** Beginning of the sequence of predicate values. 
* **`output`** Beginning of the destination range.

**Preconditions**:
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[first,last)</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[map,map + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[stencil,stencil + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The expression <code>result[&#42;i]</code> shall be valid for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code> for which the following condition holds: <code>&#42;(stencil + i) != false</code>.

<h3 id="function-scatter-if">
Function <code>thrust::scatter&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>void </span><span><b>scatter_if</b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator output);</span></code>
<code>scatter&#95;if</code> conditionally copies elements from a source range into an output array according to a map. For each iterator <code>i</code> in the range <code>[first, last)</code> such that <code>&#42;(stencil + (i - first))</code> is true, the value <code>&#42;i</code> is assigned to <code>output[&#42;(map + (i - first))]</code>. The output iterator must permit random access. If the same index appears more than once in the range <code>[map, map + (last - first))</code> the result is undefined.



```cpp
#include <thrust/scatter.h>
...
int V[8] = {10, 20, 30, 40, 50, 60, 70, 80};
int M[8] = {0, 5, 1, 6, 2, 7, 3, 4};
int S[8] = {1, 0, 1, 0, 1, 0, 1, 0};
int D[8] = {0, 0, 0, 0, 0, 0, 0, 0};

thrust::scatter_if(V, V + 8, M, S, D);

// D contains [10, 30, 50, 70, 0, 0, 0, 0];
```

**Note**:
<code>scatter&#95;if</code> is the inverse of thrust::gather_if. 

**Template Parameters**:
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>value&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`InputIterator3`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator3's</code><code>value&#95;type</code> must be convertible to <code>bool</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a>.

**Function Parameters**:
* **`first`** Beginning of the sequence of values to scatter. 
* **`last`** End of the sequence of values to scatter. 
* **`map`** Beginning of the sequence of output indices. 
* **`stencil`** Beginning of the sequence of predicate values. 
* **`output`** Beginning of the destination range.

**Preconditions**:
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[first,last)</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[map,map + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[stencil,stencil + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The expression <code>result[&#42;i]</code> shall be valid for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code> for which the following condition holds: <code>&#42;(stencil + i) != false</code>.

<h3 id="function-scatter-if">
Function <code>thrust::scatter&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ void </span><span><b>scatter_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator output,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>scatter&#95;if</code> conditionally copies elements from a source range into an output array according to a map. For each iterator <code>i</code> in the range <code>[first, last)</code> such that <code>pred(&#42;(stencil + (i - first)))</code> is <code>true</code>, the value <code>&#42;i</code> is assigned to <code>output[&#42;(map + (i - first))]</code>. The output iterator must permit random access. If the same index appears more than once in the range <code>[map, map + (last - first))</code> the result is undefined.

The algorithm's execution is parallelized as determined by <code>exec</code>.



```cpp
#include <thrust/scatter.h>
#include <thrust/execution_policy.h>

struct is_even
{
  __host__ __device__
  bool operator()(int x)
  {
    return (x % 2) == 0;
  }
};

...

int V[8] = {10, 20, 30, 40, 50, 60, 70, 80};
int M[8] = {0, 5, 1, 6, 2, 7, 3, 4};
int S[8] = {2, 1, 2, 1, 2, 1, 2, 1};
int D[8] = {0, 0, 0, 0, 0, 0, 0, 0};

is_even pred;
thrust::scatter_if(thrust::host, V, V + 8, M, S, D, pred);

// D contains [10, 30, 50, 70, 0, 0, 0, 0];
```

**Note**:
<code>scatter&#95;if</code> is the inverse of thrust::gather_if. 

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>value&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`InputIterator3`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator3's</code><code>value&#95;type</code> must be convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a>. 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** Beginning of the sequence of values to scatter. 
* **`last`** End of the sequence of values to scatter. 
* **`map`** Beginning of the sequence of output indices. 
* **`stencil`** Beginning of the sequence of predicate values. 
* **`output`** Beginning of the destination range. 
* **`pred`** Predicate to apply to the stencil values.

**Preconditions**:
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[first,last)</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[map,map + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[stencil,stencil + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The expression <code>result[&#42;i]</code> shall be valid for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code> for which the following condition holds: <code>pred(&#42;(stencil + i)) != false</code>.

<h3 id="function-scatter-if">
Function <code>thrust::scatter&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>void </span><span><b>scatter_if</b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 map,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;RandomAccessIterator output,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
<code>scatter&#95;if</code> conditionally copies elements from a source range into an output array according to a map. For each iterator <code>i</code> in the range <code>[first, last)</code> such that <code>pred(&#42;(stencil + (i - first)))</code> is <code>true</code>, the value <code>&#42;i</code> is assigned to <code>output[&#42;(map + (i - first))]</code>. The output iterator must permit random access. If the same index appears more than once in the range <code>[map, map + (last - first))</code> the result is undefined.



```cpp
#include <thrust/scatter.h>

struct is_even
{
  __host__ __device__
  bool operator()(int x)
  {
    return (x % 2) == 0;
  }
};

...

int V[8] = {10, 20, 30, 40, 50, 60, 70, 80};
int M[8] = {0, 5, 1, 6, 2, 7, 3, 4};
int S[8] = {2, 1, 2, 1, 2, 1, 2, 1};
int D[8] = {0, 0, 0, 0, 0, 0, 0, 0};

is_even pred;
thrust::scatter_if(V, V + 8, M, S, D, pred);

// D contains [10, 30, 50, 70, 0, 0, 0, 0];
```

**Note**:
<code>scatter&#95;if</code> is the inverse of thrust::gather_if. 

**Template Parameters**:
* **`InputIterator1`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>value&#95;type</code>. 
* **`InputIterator2`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> must be convertible to <code>RandomAccessIterator's</code><code>difference&#95;type</code>. 
* **`InputIterator3`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator3's</code><code>value&#95;type</code> must be convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`RandomAccessIterator`** must be a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access iterator</a>. 
* **`Predicate`** must be a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** Beginning of the sequence of values to scatter. 
* **`last`** End of the sequence of values to scatter. 
* **`map`** Beginning of the sequence of output indices. 
* **`stencil`** Beginning of the sequence of predicate values. 
* **`output`** Beginning of the destination range. 
* **`pred`** Predicate to apply to the stencil values.

**Preconditions**:
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[first,last)</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[map,map + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The iterator <code>result + i</code> shall not refer to any element referenced by any iterator <code>j</code> in the range <code>[stencil,stencil + (last - first))</code> for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code>.
* The expression <code>result[&#42;i]</code> shall be valid for all iterators <code>i</code> in the range <code>[map,map + (last - first))</code> for which the following condition holds: <code>pred(&#42;(stencil + i)) != false</code>.

<h3 id="function-sequence">
Function <code>thrust::sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ void </span><span><b>sequence</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>sequence</code> fills the range <code>[first, last)</code> with a sequence of numbers.

For each iterator <code>i</code> in the range <code>[first, last)</code>, this version of <code>sequence</code> performs the assignment <code>&#42;i = (i - first)</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>sequence</code> to fill a range with a sequence of numbers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sequence.h>
#include <thrust/execution_policy.h>
...
const int N = 10;
int A[N];
thrust::sequence(thrust::host, A, A + 10);
// A is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```

**Note**:
Unlike the similar C++ STL function <code>std::iota</code>, <code>sequence</code> offers no guarantee on order of execution.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and if <code>x</code> and <code>y</code> are objects of <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined, and if <code>T</code> is <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/iota">https://en.cppreference.com/w/cpp/algorithm/iota</a>

<h3 id="function-sequence">
Function <code>thrust::sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator&gt;</span>
<span>void </span><span><b>sequence</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>sequence</code> fills the range <code>[first, last)</code> with a sequence of numbers.

For each iterator <code>i</code> in the range <code>[first, last)</code>, this version of <code>sequence</code> performs the assignment <code>&#42;i = (i - first)</code>.


The following code snippet demonstrates how to use <code>sequence</code> to fill a range with a sequence of numbers.



```cpp
#include <thrust/sequence.h>
...
const int N = 10;
int A[N];
thrust::sequence(A, A + 10);
// A is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```

**Note**:
Unlike the similar C++ STL function <code>std::iota</code>, <code>sequence</code> offers no guarantee on order of execution.

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and if <code>x</code> and <code>y</code> are objects of <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined, and if <code>T</code> is <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/iota">https://en.cppreference.com/w/cpp/algorithm/iota</a>

<h3 id="function-sequence">
Function <code>thrust::sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b>sequence</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;T init);</span></code>
<code>sequence</code> fills the range <code>[first, last)</code> with a sequence of numbers.

For each iterator <code>i</code> in the range <code>[first, last)</code>, this version of <code>sequence</code> performs the assignment <code>&#42;i = init + (i - first)</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>sequence</code> to fill a range with a sequence of numbers starting from the value 1 using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sequence.h>
#include <thrust/execution_policy.h>
...
const int N = 10;
int A[N];
thrust::sequence(thrust::host, A, A + 10, 1);
// A is now {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

**Note**:
Unlike the similar C++ STL function <code>std::iota</code>, <code>sequence</code> offers no guarantee on order of execution.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and if <code>x</code> and <code>y</code> are objects of <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined, and if <code>T</code> is <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`init`** The first value of the sequence of numbers.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/iota">https://en.cppreference.com/w/cpp/algorithm/iota</a>

<h3 id="function-sequence">
Function <code>thrust::sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b>sequence</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;T init);</span></code>
<code>sequence</code> fills the range <code>[first, last)</code> with a sequence of numbers.

For each iterator <code>i</code> in the range <code>[first, last)</code>, this version of <code>sequence</code> performs the assignment <code>&#42;i = init + (i - first)</code>.


The following code snippet demonstrates how to use <code>sequence</code> to fill a range with a sequence of numbers starting from the value 1.



```cpp
#include <thrust/sequence.h>
...
const int N = 10;
int A[N];
thrust::sequence(A, A + 10, 1);
// A is now {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

**Note**:
Unlike the similar C++ STL function <code>std::iota</code>, <code>sequence</code> offers no guarantee on order of execution.

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and if <code>x</code> and <code>y</code> are objects of <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined, and if <code>T</code> is <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`init`** The first value of the sequence of numbers.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/iota">https://en.cppreference.com/w/cpp/algorithm/iota</a>

<h3 id="function-sequence">
Function <code>thrust::sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b>sequence</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;T step);</span></code>
<code>sequence</code> fills the range <code>[first, last)</code> with a sequence of numbers.

For each iterator <code>i</code> in the range <code>[first, last)</code>, this version of <code>sequence</code> performs the assignment <code>&#42;i = init + step &#42; (i - first)</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>sequence</code> to fill a range with a sequence of numbers starting from the value 1 with a step size of 3 using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sequence.h>
#include <thrust/execution_policy.h>
...
const int N = 10;
int A[N];
thrust::sequence(thrust::host, A, A + 10, 1, 3);
// A is now {1, 4, 7, 10, 13, 16, 19, 22, 25, 28}
```

**Note**:
Unlike the similar C++ STL function <code>std::iota</code>, <code>sequence</code> offers no guarantee on order of execution.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and if <code>x</code> and <code>y</code> are objects of <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined, and if <code>T</code> is <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`init`** The first value of the sequence of numbers 
* **`step`** The difference between consecutive elements.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/iota">https://en.cppreference.com/w/cpp/algorithm/iota</a>

<h3 id="function-sequence">
Function <code>thrust::sequence</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b>sequence</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;T step);</span></code>
<code>sequence</code> fills the range <code>[first, last)</code> with a sequence of numbers.

For each iterator <code>i</code> in the range <code>[first, last)</code>, this version of <code>sequence</code> performs the assignment <code>&#42;i = init + step &#42; (i - first)</code>.


The following code snippet demonstrates how to use <code>sequence</code> to fill a range with a sequence of numbers starting from the value 1 with a step size of 3.



```cpp
#include <thrust/sequence.h>
...
const int N = 10;
int A[N];
thrust::sequence(A, A + 10, 1, 3);
// A is now {1, 4, 7, 10, 13, 16, 19, 22, 25, 28}
```

**Note**:
Unlike the similar C++ STL function <code>std::iota</code>, <code>sequence</code> offers no guarantee on order of execution.

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and if <code>x</code> and <code>y</code> are objects of <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined, and if <code>T</code> is <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined. 
* **`T`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and <code>T</code> is convertible to <code>ForwardIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`init`** The first value of the sequence of numbers 
* **`step`** The difference between consecutive elements.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/iota">https://en.cppreference.com/w/cpp/algorithm/iota</a>

<h3 id="function-set-difference">
Function <code>thrust::set&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>set_difference</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>set&#95;difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.

This version of <code>set&#95;difference</code> compares elements using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;difference</code> to compute the set difference of two sets of integers sorted in ascending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A1[7] = {0, 1, 3, 4, 5, 6, 9};
int A2[5] = {1, 3, 5, 7, 9};

int result[3];

int *result_end = thrust::set_difference(thrust::host, A1, A1 + 7, A2, A2 + 5, result);
// result is now {0, 4, 6}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_difference">https://en.cppreference.com/w/cpp/algorithm/set_difference</a>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-difference">
Function <code>thrust::set&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>set_difference</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>set&#95;difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.

This version of <code>set&#95;difference</code> compares elements using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>set&#95;difference</code> to compute the set difference of two sets of integers sorted in ascending order.



```cpp
#include <thrust/set_operations.h>
...
int A1[7] = {0, 1, 3, 4, 5, 6, 9};
int A2[5] = {1, 3, 5, 7, 9};

int result[3];

int *result_end = thrust::set_difference(A1, A1 + 7, A2, A2 + 5, result);
// result is now {0, 4, 6}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_difference">https://en.cppreference.com/w/cpp/algorithm/set_difference</a>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-difference">
Function <code>thrust::set&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>set_difference</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.

This version of <code>set&#95;difference</code> compares elements using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;difference</code> to compute the set difference of two sets of integers sorted in descending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A1[7] = {9, 6, 5, 4, 3, 1, 0};
int A2[5] = {9, 7, 5, 3, 1};

int result[3];

int *result_end = thrust::set_difference(thrust::host, A1, A1 + 7, A2, A2 + 5, result, thrust::greater<int>());
// result is now {6, 4, 0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>first&#95;argument&#95;type</code>. and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>second&#95;argument&#95;type</code>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_difference">https://en.cppreference.com/w/cpp/algorithm/set_difference</a>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-difference">
Function <code>thrust::set&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b>set_difference</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;difference</code> constructs a sorted range that is the set difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;difference</code> performs the "difference" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code> and not contained in <code>[first2, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[first1, last1)</code> range shall be copied to the output range.

This version of <code>set&#95;difference</code> compares elements using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>set&#95;difference</code> to compute the set difference of two sets of integers sorted in descending order.



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
...
int A1[7] = {9, 6, 5, 4, 3, 1, 0};
int A2[5] = {9, 7, 5, 3, 1};

int result[3];

int *result_end = thrust::set_difference(A1, A1 + 7, A2, A2 + 5, result, thrust::greater<int>());
// result is now {6, 4, 0}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>first&#95;argument&#95;type</code>. and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>second&#95;argument&#95;type</code>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_difference">https://en.cppreference.com/w/cpp/algorithm/set_difference</a>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-intersection">
Function <code>thrust::set&#95;intersection</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>set_intersection</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>set&#95;intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set&#95;intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.

This version of <code>set&#95;intersection</code> compares objects using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;intersection</code> to compute the set intersection of two sets of integers sorted in ascending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A1[6] = {1, 3, 5, 7, 9, 11};
int A2[7] = {1, 1, 2, 3, 5,  8, 13};

int result[7];

int *result_end = thrust::set_intersection(thrust::host, A1, A1 + 6, A2, A2 + 7, result);
// result is now {1, 3, 5}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_intersection">https://en.cppreference.com/w/cpp/algorithm/set_intersection</a>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-intersection">
Function <code>thrust::set&#95;intersection</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>set_intersection</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>set&#95;intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set&#95;intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.

This version of <code>set&#95;intersection</code> compares objects using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>set&#95;intersection</code> to compute the set intersection of two sets of integers sorted in ascending order.



```cpp
#include <thrust/set_operations.h>
...
int A1[6] = {1, 3, 5, 7, 9, 11};
int A2[7] = {1, 1, 2, 3, 5,  8, 13};

int result[7];

int *result_end = thrust::set_intersection(A1, A1 + 6, A2, A2 + 7, result);
// result is now {1, 3, 5}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_intersection">https://en.cppreference.com/w/cpp/algorithm/set_intersection</a>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-intersection">
Function <code>thrust::set&#95;intersection</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>set_intersection</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set&#95;intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.

This version of <code>set&#95;intersection</code> compares elements using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;intersection</code> to compute the set intersection of sets of integers sorted in descending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A1[6] = {11, 9, 7, 5, 3, 1};
int A2[7] = {13, 8, 5, 3, 2,  1, 1};

int result[3];

int *result_end = thrust::set_intersection(thrust::host, A1, A1 + 6, A2, A2 + 7, result, thrust::greater<int>());
// result is now {5, 3, 1}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_intersection">https://en.cppreference.com/w/cpp/algorithm/set_intersection</a>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-intersection">
Function <code>thrust::set&#95;intersection</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b>set_intersection</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;intersection</code> constructs a sorted range that is the intersection of sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;intersection</code> performs the "intersection" operation from set theory: the output range contains a copy of every element that is contained in both <code>[first1, last1)</code> and <code>[first2, last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if a value appears <code>m</code> times in <code>[first1, last1)</code> and <code>n</code> times in <code>[first2, last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the output range. <code>set&#95;intersection</code> is stable, meaning that both elements are copied from the first range rather than the second, and that the relative order of elements in the output range is the same as in the first input range.

This version of <code>set&#95;intersection</code> compares elements using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>set&#95;intersection</code> to compute the set intersection of sets of integers sorted in descending order.



```cpp
#include <thrust/set_operations.h>
...
int A1[6] = {11, 9, 7, 5, 3, 1};
int A2[7] = {13, 8, 5, 3, 2,  1, 1};

int result[3];

int *result_end = thrust::set_intersection(A1, A1 + 6, A2, A2 + 7, result, thrust::greater<int>());
// result is now {5, 3, 1}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_intersection">https://en.cppreference.com/w/cpp/algorithm/set_intersection</a>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-symmetric-difference">
Function <code>thrust::set&#95;symmetric&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>set_symmetric_difference</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>set&#95;symmetric&#95;difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;symmetric&#95;difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.

This version of <code>set&#95;union</code> compares elements using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference</code> to compute the symmetric difference of two sets of integers sorted in ascending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A1[7] = {0, 1, 2, 2, 4, 6, 7};
int A2[5] = {1, 1, 2, 5, 8};

int result[6];

int *result_end = thrust::set_symmetric_difference(thrust::host, A1, A1 + 7, A2, A2 + 5, result);
// result = {0, 4, 5, 6, 7, 8}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference">https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference</a>
* <code>merge</code>
* <code>includes</code>
* <code>set&#95;difference</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-symmetric-difference">
Function <code>thrust::set&#95;symmetric&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>set_symmetric_difference</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>set&#95;symmetric&#95;difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;symmetric&#95;difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.

This version of <code>set&#95;union</code> compares elements using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference</code> to compute the symmetric difference of two sets of integers sorted in ascending order.



```cpp
#include <thrust/set_operations.h>
...
int A1[7] = {0, 1, 2, 2, 4, 6, 7};
int A2[5] = {1, 1, 2, 5, 8};

int result[6];

int *result_end = thrust::set_symmetric_difference(A1, A1 + 7, A2, A2 + 5, result);
// result = {0, 4, 5, 6, 7, 8}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference">https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference</a>
* <code>merge</code>
* <code>includes</code>
* <code>set&#95;difference</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-symmetric-difference">
Function <code>thrust::set&#95;symmetric&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>set_symmetric_difference</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;symmetric&#95;difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;symmetric&#95;difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.

This version of <code>set&#95;union</code> compares elements using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference</code> to compute the symmetric difference of two sets of integers sorted in descending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A1[7] = {7, 6, 4, 2, 2, 1, 0};
int A2[5] = {8, 5, 2, 1, 1};

int result[6];

int *result_end = thrust::set_symmetric_difference(thrust::host, A1, A1 + 7, A2, A2 + 5, result);
// result = {8, 7, 6, 5, 4, 0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference">https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference</a>
* <code>merge</code>
* <code>includes</code>
* <code>set&#95;difference</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-symmetric-difference">
Function <code>thrust::set&#95;symmetric&#95;difference</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b>set_symmetric_difference</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;symmetric&#95;difference</code> constructs a sorted range that is the set symmetric difference of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;symmetric&#95;difference</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[first1, last1)</code> but not <code>[first2, last1)</code>, and a copy of every element that is contained in <code>[first2, last2)</code> but not <code>[first1, last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[first2, last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[first1, last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[first2, last2)</code> if <code>m &lt; n</code>.

This version of <code>set&#95;union</code> compares elements using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference</code> to compute the symmetric difference of two sets of integers sorted in descending order.



```cpp
#include <thrust/set_operations.h>
...
int A1[7] = {7, 6, 4, 2, 2, 1, 0};
int A2[5] = {8, 5, 2, 1, 1};

int result[6];

int *result_end = thrust::set_symmetric_difference(A1, A1 + 7, A2, A2 + 5, result);
// result = {8, 7, 6, 5, 4, 0}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference">https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference</a>
* <code>merge</code>
* <code>includes</code>
* <code>set&#95;difference</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-union">
Function <code>thrust::set&#95;union</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>set_union</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>set&#95;union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.

This version of <code>set&#95;union</code> compares elements using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;union</code> to compute the union of two sets of integers sorted in ascending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A1[7] = {0, 2, 4, 6, 8, 10, 12};
int A2[5] = {1, 3, 5, 7, 9};

int result[11];

int *result_end = thrust::set_union(thrust::host, A1, A1 + 7, A2, A2 + 5, result);
// result = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_union">https://en.cppreference.com/w/cpp/algorithm/set_union</a>
* <code>merge</code>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-union">
Function <code>thrust::set&#95;union</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>set_union</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>set&#95;union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.

This version of <code>set&#95;union</code> compares elements using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>set&#95;union</code> to compute the union of two sets of integers sorted in ascending order.



```cpp
#include <thrust/set_operations.h>
...
int A1[7] = {0, 2, 4, 6, 8, 10, 12};
int A2[5] = {1, 3, 5, 7, 9};

int result[11];

int *result_end = thrust::set_union(A1, A1 + 7, A2, A2 + 5, result);
// result = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_union">https://en.cppreference.com/w/cpp/algorithm/set_union</a>
* <code>merge</code>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-union">
Function <code>thrust::set&#95;union</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>set_union</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.

This version of <code>set&#95;union</code> compares elements using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;union</code> to compute the union of two sets of integers sorted in ascending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A1[7] = {12, 10, 8, 6, 4, 2, 0};
int A2[5] = {9, 7, 5, 3, 1};

int result[11];

int *result_end = thrust::set_union(thrust::host, A1, A1 + 7, A2, A2 + 5, result, thrust::greater<int>());
// result = {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>first&#95;argument&#95;type</code>. and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>second&#95;argument&#95;type</code>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_union">https://en.cppreference.com/w/cpp/algorithm/set_union</a>
* <code>merge</code>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-union">
Function <code>thrust::set&#95;union</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>OutputIterator </span><span><b>set_union</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator2 last2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;union</code> constructs a sorted range that is the union of the sorted ranges <code>[first1, last1)</code> and <code>[first2, last2)</code>. The return value is the end of the output range.

In the simplest case, <code>set&#95;union</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[first1, last1)</code>, <code>[first2, last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[first1, last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[first2, last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.

This version of <code>set&#95;union</code> compares elements using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>set&#95;union</code> to compute the union of two sets of integers sorted in ascending order.



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
...
int A1[7] = {12, 10, 8, 6, 4, 2, 0};
int A2[5] = {9, 7, 5, 3, 1};

int result[11];

int *result_end = thrust::set_union(A1, A1 + 7, A2, A2 + 5, result, thrust::greater<int>());
// result = {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>first&#95;argument&#95;type</code>. and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2's</code><code>value&#95;type</code> is convertable to <code>StrictWeakCompare's</code><code>second&#95;argument&#95;type</code>. and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input range. 
* **`last1`** The end of the first input range. 
* **`first2`** The beginning of the second input range. 
* **`last2`** The end of the second input range. 
* **`result`** The beginning of the output range. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting range shall not overlap with either input range.

**Returns**:
The end of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/set_union">https://en.cppreference.com/w/cpp/algorithm/set_union</a>
* <code>merge</code>
* <code>includes</code>
* <code>set&#95;union</code>
* <code>set&#95;intersection</code>
* <code>set&#95;symmetric&#95;difference</code>
* <code>sort</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-difference-by-key">
Function <code>thrust::set&#95;difference&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_difference_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>set&#95;difference&#95;by&#95;key</code> performs a key-value difference operation from set theory. <code>set&#95;difference&#95;by&#95;key</code> constructs a sorted range that is the difference of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;difference&#95;by&#95;key</code> performs the "difference" operation from set theory: the keys output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code> and not contained in <code>[keys&#95;first2, keys&#95;last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys&#95;first2, keys&#95;last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[keys&#95;first1, keys&#95;last1)</code> range shall be copied to the output range.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;difference&#95;by&#95;key</code> compares key elements using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;difference&#95;by&#95;key</code> to compute the set difference of two sets of integers sorted in ascending order with their values using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {0, 1, 3, 4, 5, 6, 9};
int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

int B_keys[5] = {1, 3, 5, 7, 9};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[3];
int vals_result[3];

thrust::pair<int*,int*> end = thrust::set_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
// keys_result is now {0, 4, 6}
// vals_result is now {0, 0, 0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-difference-by-key">
Function <code>thrust::set&#95;difference&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_difference_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>set&#95;difference&#95;by&#95;key</code> performs a key-value difference operation from set theory. <code>set&#95;difference&#95;by&#95;key</code> constructs a sorted range that is the difference of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;difference&#95;by&#95;key</code> performs the "difference" operation from set theory: the keys output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code> and not contained in <code>[keys&#95;first2, keys&#95;last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys&#95;first2, keys&#95;last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[keys&#95;first1, keys&#95;last1)</code> range shall be copied to the output range.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;difference&#95;by&#95;key</code> compares key elements using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>set&#95;difference&#95;by&#95;key</code> to compute the set difference of two sets of integers sorted in ascending order with their values.



```cpp
#include <thrust/set_operations.h>
...
int A_keys[6] = {0, 1, 3, 4, 5, 6, 9};
int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

int B_keys[5] = {1, 3, 5, 7, 9};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[3];
int vals_result[3];

thrust::pair<int*,int*> end = thrust::set_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
// keys_result is now {0, 4, 6}
// vals_result is now {0, 0, 0}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-difference-by-key">
Function <code>thrust::set&#95;difference&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_difference_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;difference&#95;by&#95;key</code> performs a key-value difference operation from set theory. <code>set&#95;difference&#95;by&#95;key</code> constructs a sorted range that is the difference of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;difference&#95;by&#95;key</code> performs the "difference" operation from set theory: the keys output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code> and not contained in <code>[keys&#95;first2, keys&#95;last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys&#95;first2, keys&#95;last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[keys&#95;first1, keys&#95;last1)</code> range shall be copied to the output range.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;difference&#95;by&#95;key</code> compares key elements using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;difference&#95;by&#95;key</code> to compute the set difference of two sets of integers sorted in descending order with their values using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {9, 6, 5, 4, 3, 1, 0};
int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

int B_keys[5] = {9, 7, 5, 3, 1};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[3];
int vals_result[3];

thrust::pair<int*,int*> end = thrust::set_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());
// keys_result is now {0, 4, 6}
// vals_result is now {0, 0, 0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-difference-by-key">
Function <code>thrust::set&#95;difference&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_difference_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;difference&#95;by&#95;key</code> performs a key-value difference operation from set theory. <code>set&#95;difference&#95;by&#95;key</code> constructs a sorted range that is the difference of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;difference&#95;by&#95;key</code> performs the "difference" operation from set theory: the keys output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code> and not contained in <code>[keys&#95;first2, keys&#95;last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys&#95;first2, keys&#95;last2)</code> contains <code>n</code> elements that are equivalent to them, the last <code>max(m-n,0)</code> elements from <code>[keys&#95;first1, keys&#95;last1)</code> range shall be copied to the output range.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;difference&#95;by&#95;key</code> compares key elements using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>set&#95;difference&#95;by&#95;key</code> to compute the set difference of two sets of integers sorted in descending order with their values.



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
...
int A_keys[6] = {9, 6, 5, 4, 3, 1, 0};
int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

int B_keys[5] = {9, 7, 5, 3, 1};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[3];
int vals_result[3];

thrust::pair<int*,int*> end = thrust::set_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());
// keys_result is now {0, 4, 6}
// vals_result is now {0, 0, 0}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-intersection-by-key">
Function <code>thrust::set&#95;intersection&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_intersection_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>set&#95;intersection&#95;by&#95;key</code> performs a key-value intersection operation from set theory. <code>set&#95;intersection&#95;by&#95;key</code> constructs a sorted range that is the intersection of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;intersection&#95;by&#95;key</code> performs the "intersection" operation from set theory: the keys output range contains a copy of every element that is contained in both <code>[keys&#95;first1, keys&#95;last1)</code><code>[keys&#95;first2, keys&#95;last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if an element appears <code>m</code> times in <code>[keys&#95;first1, keys&#95;last1)</code> and <code>n</code> times in <code>[keys&#95;first2, keys&#95;last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the keys output range. <code>set&#95;intersection&#95;by&#95;key</code> is stable, meaning both that elements are copied from the first input range rather than the second, and that the relative order of elements in the output range is the same as the first input range.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> to the keys output range, the corresponding value element is copied from <code>[values&#95;first1, values&#95;last1)</code> to the values output range.

This version of <code>set&#95;intersection&#95;by&#95;key</code> compares objects using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;intersection&#95;by&#95;key</code> to compute the set intersection of two sets of integers sorted in ascending order with their values using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {1, 3, 5, 7, 9, 11};
int A_vals[6] = {0, 0, 0, 0, 0,  0};

int B_keys[7] = {1, 1, 2, 3, 5,  8, 13};

int keys_result[7];
int vals_result[7];

thrust::pair<int*,int*> end = thrust::set_intersection_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result);

// keys_result is now {1, 3, 5}
// vals_result is now {0, 0, 0}
```

**Note**:
Unlike the other key-value set operations, <code>set&#95;intersection&#95;by&#95;key</code> is unique in that it has no <code>values&#95;first2</code> parameter because elements from the second input range are never copied to the output range.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-intersection-by-key">
Function <code>thrust::set&#95;intersection&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_intersection_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>set&#95;intersection&#95;by&#95;key</code> performs a key-value intersection operation from set theory. <code>set&#95;intersection&#95;by&#95;key</code> constructs a sorted range that is the intersection of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;intersection&#95;by&#95;key</code> performs the "intersection" operation from set theory: the keys output range contains a copy of every element that is contained in both <code>[keys&#95;first1, keys&#95;last1)</code><code>[keys&#95;first2, keys&#95;last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if an element appears <code>m</code> times in <code>[keys&#95;first1, keys&#95;last1)</code> and <code>n</code> times in <code>[keys&#95;first2, keys&#95;last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the keys output range. <code>set&#95;intersection&#95;by&#95;key</code> is stable, meaning both that elements are copied from the first input range rather than the second, and that the relative order of elements in the output range is the same as the first input range.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> to the keys output range, the corresponding value element is copied from <code>[values&#95;first1, values&#95;last1)</code> to the values output range.

This version of <code>set&#95;intersection&#95;by&#95;key</code> compares objects using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>set&#95;intersection&#95;by&#95;key</code> to compute the set intersection of two sets of integers sorted in ascending order with their values.



```cpp
#include <thrust/set_operations.h>
...
int A_keys[6] = {1, 3, 5, 7, 9, 11};
int A_vals[6] = {0, 0, 0, 0, 0,  0};

int B_keys[7] = {1, 1, 2, 3, 5,  8, 13};

int keys_result[7];
int vals_result[7];

thrust::pair<int*,int*> end = thrust::set_intersection_by_key(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result);

// keys_result is now {1, 3, 5}
// vals_result is now {0, 0, 0}
```

**Note**:
Unlike the other key-value set operations, <code>set&#95;intersection&#95;by&#95;key</code> is unique in that it has no <code>values&#95;first2</code> parameter because elements from the second input range are never copied to the output range.

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-intersection-by-key">
Function <code>thrust::set&#95;intersection&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_intersection_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;intersection&#95;by&#95;key</code> performs a key-value intersection operation from set theory. <code>set&#95;intersection&#95;by&#95;key</code> constructs a sorted range that is the intersection of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;intersection&#95;by&#95;key</code> performs the "intersection" operation from set theory: the keys output range contains a copy of every element that is contained in both <code>[keys&#95;first1, keys&#95;last1)</code><code>[keys&#95;first2, keys&#95;last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if an element appears <code>m</code> times in <code>[keys&#95;first1, keys&#95;last1)</code> and <code>n</code> times in <code>[keys&#95;first2, keys&#95;last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the keys output range. <code>set&#95;intersection&#95;by&#95;key</code> is stable, meaning both that elements are copied from the first input range rather than the second, and that the relative order of elements in the output range is the same as the first input range.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> to the keys output range, the corresponding value element is copied from <code>[values&#95;first1, values&#95;last1)</code> to the values output range.

This version of <code>set&#95;intersection&#95;by&#95;key</code> compares objects using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;intersection&#95;by&#95;key</code> to compute the set intersection of two sets of integers sorted in descending order with their values using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {11, 9, 7, 5, 3, 1};
int A_vals[6] = { 0, 0, 0, 0, 0, 0};

int B_keys[7] = {13, 8, 5, 3, 2, 1, 1};

int keys_result[7];
int vals_result[7];

thrust::pair<int*,int*> end = thrust::set_intersection_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result, thrust::greater<int>());

// keys_result is now {5, 3, 1}
// vals_result is now {0, 0, 0}
```

**Note**:
Unlike the other key-value set operations, <code>set&#95;intersection&#95;by&#95;key</code> is unique in that it has no <code>values&#95;first2</code> parameter because elements from the second input range are never copied to the output range.

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-intersection-by-key">
Function <code>thrust::set&#95;intersection&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_intersection_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;intersection&#95;by&#95;key</code> performs a key-value intersection operation from set theory. <code>set&#95;intersection&#95;by&#95;key</code> constructs a sorted range that is the intersection of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;intersection&#95;by&#95;key</code> performs the "intersection" operation from set theory: the keys output range contains a copy of every element that is contained in both <code>[keys&#95;first1, keys&#95;last1)</code><code>[keys&#95;first2, keys&#95;last2)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if an element appears <code>m</code> times in <code>[keys&#95;first1, keys&#95;last1)</code> and <code>n</code> times in <code>[keys&#95;first2, keys&#95;last2)</code> (where <code>m</code> may be zero), then it appears <code>min(m,n)</code> times in the keys output range. <code>set&#95;intersection&#95;by&#95;key</code> is stable, meaning both that elements are copied from the first input range rather than the second, and that the relative order of elements in the output range is the same as the first input range.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> to the keys output range, the corresponding value element is copied from <code>[values&#95;first1, values&#95;last1)</code> to the values output range.

This version of <code>set&#95;intersection&#95;by&#95;key</code> compares objects using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>set&#95;intersection&#95;by&#95;key</code> to compute the set intersection of two sets of integers sorted in descending order with their values.



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
...
int A_keys[6] = {11, 9, 7, 5, 3, 1};
int A_vals[6] = { 0, 0, 0, 0, 0, 0};

int B_keys[7] = {13, 8, 5, 3, 2, 1, 1};

int keys_result[7];
int vals_result[7];

thrust::pair<int*,int*> end = thrust::set_intersection_by_key(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result, thrust::greater<int>());

// keys_result is now {5, 3, 1}
// vals_result is now {0, 0, 0}
```

**Note**:
Unlike the other key-value set operations, <code>set&#95;intersection&#95;by&#95;key</code> is unique in that it has no <code>values&#95;first2</code> parameter because elements from the second input range are never copied to the output range.

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-symmetric-difference-by-key">
Function <code>thrust::set&#95;symmetric&#95;difference&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_symmetric_difference_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> performs a key-value symmetric difference operation from set theory. <code>set&#95;difference&#95;by&#95;key</code> constructs a sorted range that is the symmetric difference of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code> but not <code>[keys&#95;first2, keys&#95;last1)</code>, and a copy of every element that is contained in <code>[keys&#95;first2, keys&#95;last2)</code> but not <code>[keys&#95;first1, keys&#95;last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[keys&#95;first2, keys&#95;last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[keys&#95;first1, keys&#95;last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[keys&#95;first2, keys&#95;last2)</code> if <code>m &lt; n</code>.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> compares key elements using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> to compute the symmetric difference of two sets of integers sorted in ascending order with their values using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {0, 1, 2, 2, 4, 6, 7};
int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

int B_keys[5] = {1, 1, 2, 5, 8};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[6];
int vals_result[6];

thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
// keys_result is now {0, 4, 5, 6, 7, 8}
// vals_result is now {0, 0, 1, 0, 0, 1}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-symmetric-difference-by-key">
Function <code>thrust::set&#95;symmetric&#95;difference&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_symmetric_difference_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> performs a key-value symmetric difference operation from set theory. <code>set&#95;difference&#95;by&#95;key</code> constructs a sorted range that is the symmetric difference of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code> but not <code>[keys&#95;first2, keys&#95;last1)</code>, and a copy of every element that is contained in <code>[keys&#95;first2, keys&#95;last2)</code> but not <code>[keys&#95;first1, keys&#95;last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[keys&#95;first2, keys&#95;last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[keys&#95;first1, keys&#95;last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[keys&#95;first2, keys&#95;last2)</code> if <code>m &lt; n</code>.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> compares key elements using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> to compute the symmetric difference of two sets of integers sorted in ascending order with their values.



```cpp
#include <thrust/set_operations.h>
...
int A_keys[6] = {0, 1, 2, 2, 4, 6, 7};
int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

int B_keys[5] = {1, 1, 2, 5, 8};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[6];
int vals_result[6];

thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
// keys_result is now {0, 4, 5, 6, 7, 8}
// vals_result is now {0, 0, 1, 0, 0, 1}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-symmetric-difference-by-key">
Function <code>thrust::set&#95;symmetric&#95;difference&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_symmetric_difference_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> performs a key-value symmetric difference operation from set theory. <code>set&#95;difference&#95;by&#95;key</code> constructs a sorted range that is the symmetric difference of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code> but not <code>[keys&#95;first2, keys&#95;last1)</code>, and a copy of every element that is contained in <code>[keys&#95;first2, keys&#95;last2)</code> but not <code>[keys&#95;first1, keys&#95;last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[keys&#95;first2, keys&#95;last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[keys&#95;first1, keys&#95;last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[keys&#95;first2, keys&#95;last2)</code> if <code>m &lt; n</code>.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> compares key elements using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> to compute the symmetric difference of two sets of integers sorted in descending order with their values using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {7, 6, 4, 2, 2, 1, 0};
int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

int B_keys[5] = {8, 5, 2, 1, 1};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[6];
int vals_result[6];

thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
// keys_result is now {8, 7, 6, 5, 4, 0}
// vals_result is now {1, 0, 0, 1, 0, 0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-symmetric-difference-by-key">
Function <code>thrust::set&#95;symmetric&#95;difference&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_symmetric_difference_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> performs a key-value symmetric difference operation from set theory. <code>set&#95;difference&#95;by&#95;key</code> constructs a sorted range that is the symmetric difference of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> performs a set theoretic calculation: it constructs the union of the two sets A - B and B - A, where A and B are the two input ranges. That is, the output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code> but not <code>[keys&#95;first2, keys&#95;last1)</code>, and a copy of every element that is contained in <code>[keys&#95;first2, keys&#95;last2)</code> but not <code>[keys&#95;first1, keys&#95;last1)</code>. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and <code>[keys&#95;first2, keys&#95;last1)</code> contains <code>n</code> elements that are equivalent to them, then <code>|m - n|</code> of those elements shall be copied to the output range: the last <code>m - n</code> elements from <code>[keys&#95;first1, keys&#95;last1)</code> if <code>m &gt; n</code>, and the last <code>n - m</code> of these elements from <code>[keys&#95;first2, keys&#95;last2)</code> if <code>m &lt; n</code>.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> compares key elements using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> to compute the symmetric difference of two sets of integers sorted in descending order with their values.



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
...
int A_keys[6] = {7, 6, 4, 2, 2, 1, 0};
int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

int B_keys[5] = {8, 5, 2, 1, 1};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[6];
int vals_result[6];

thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
// keys_result is now {8, 7, 6, 5, 4, 0}
// vals_result is now {1, 0, 0, 1, 0, 0}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;union&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-union-by-key">
Function <code>thrust::set&#95;union&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_union_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>set&#95;union&#95;by&#95;key</code> performs a key-value union operation from set theory. <code>set&#95;union&#95;by&#95;key</code> constructs a sorted range that is the union of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;union&#95;by&#95;key</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code>, <code>[keys&#95;first2, keys&#95;last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys&#95;first2, keys&#95;last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;union&#95;by&#95;key</code> compares key elements using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> to compute the symmetric difference of two sets of integers sorted in ascending order with their values using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {0, 2, 4, 6, 8, 10, 12};
int A_vals[6] = {0, 0, 0, 0, 0,  0,  0};

int B_keys[5] = {1, 3, 5, 7, 9};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[11];
int vals_result[11];

thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
// keys_result is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}
// vals_result is now {0, 1, 0, 1, 0, 1, 0, 1, 0, 1,  0,  0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-union-by-key">
Function <code>thrust::set&#95;union&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_union_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>set&#95;union&#95;by&#95;key</code> performs a key-value union operation from set theory. <code>set&#95;union&#95;by&#95;key</code> constructs a sorted range that is the union of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;union&#95;by&#95;key</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code>, <code>[keys&#95;first2, keys&#95;last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys&#95;first2, keys&#95;last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;union&#95;by&#95;key</code> compares key elements using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> to compute the symmetric difference of two sets of integers sorted in ascending order with their values.



```cpp
#include <thrust/set_operations.h>
...
int A_keys[6] = {0, 2, 4, 6, 8, 10, 12};
int A_vals[6] = {0, 0, 0, 0, 0,  0,  0};

int B_keys[5] = {1, 3, 5, 7, 9};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[11];
int vals_result[11];

thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
// keys_result is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}
// vals_result is now {0, 1, 0, 1, 0, 1, 0, 1, 0, 1,  0,  0}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>operator&lt;</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-union-by-key">
Function <code>thrust::set&#95;union&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_union_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;union&#95;by&#95;key</code> performs a key-value union operation from set theory. <code>set&#95;union&#95;by&#95;key</code> constructs a sorted range that is the union of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;union&#95;by&#95;key</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code>, <code>[keys&#95;first2, keys&#95;last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys&#95;first2, keys&#95;last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;union&#95;by&#95;key</code> compares key elements using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> to compute the symmetric difference of two sets of integers sorted in descending order with their values using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
int A_keys[6] = {12, 10, 8, 6, 4, 2, 0};
int A_vals[6] = { 0,  0, 0, 0, 0, 0, 0};

int B_keys[5] = {9, 7, 5, 3, 1};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[11];
int vals_result[11];

thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());
// keys_result is now {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
// vals_result is now { 0,  1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-set-union-by-key">
Function <code>thrust::set&#95;union&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename InputIterator4,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakCompare&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>set_union_by_key</b>(InputIterator1 keys_first1,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last1,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_first2,</span>
<span>&nbsp;&nbsp;InputIterator2 keys_last2,</span>
<span>&nbsp;&nbsp;InputIterator3 values_first1,</span>
<span>&nbsp;&nbsp;InputIterator4 values_first2,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;StrictWeakCompare comp);</span></code>
<code>set&#95;union&#95;by&#95;key</code> performs a key-value union operation from set theory. <code>set&#95;union&#95;by&#95;key</code> constructs a sorted range that is the union of the sorted ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code>. Associated with each element from the input and output key ranges is a value element. The associated input value ranges need not be sorted.

In the simplest case, <code>set&#95;union&#95;by&#95;key</code> performs the "union" operation from set theory: the output range contains a copy of every element that is contained in <code>[keys&#95;first1, keys&#95;last1)</code>, <code>[keys&#95;first2, keys&#95;last1)</code>, or both. The general case is more complicated, because the input ranges may contain duplicate elements. The generalization is that if <code>[keys&#95;first1, keys&#95;last1)</code> contains <code>m</code> elements that are equivalent to each other and if <code>[keys&#95;first2, keys&#95;last2)</code> contains <code>n</code> elements that are equivalent to them, then all <code>m</code> elements from the first range shall be copied to the output range, in order, and then <code>max(n - m, 0)</code> elements from the second range shall be copied to the output, in order.

Each time a key element is copied from <code>[keys&#95;first1, keys&#95;last1)</code> or <code>[keys&#95;first2, keys&#95;last2)</code> is copied to the keys output range, the corresponding value element is copied from the corresponding values input range (beginning at <code>values&#95;first1</code> or <code>values&#95;first2</code>) to the values output range.

This version of <code>set&#95;union&#95;by&#95;key</code> compares key elements using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code> to compute the symmetric difference of two sets of integers sorted in descending order with their values.



```cpp
#include <thrust/set_operations.h>
#include <thrust/functional.h>
...
int A_keys[6] = {12, 10, 8, 6, 4, 2, 0};
int A_vals[6] = { 0,  0, 0, 0, 0, 0, 0};

int B_keys[5] = {9, 7, 5, 3, 1};
int B_vals[5] = {1, 1, 1, 1, 1};

int keys_result[11];
int vals_result[11];

thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());
// keys_result is now {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
// vals_result is now { 0,  1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator1</code> and <code>InputIterator2</code> have the same <code>value&#95;type</code>, <code>InputIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator1's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator1's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, <code>InputIterator2</code> and <code>InputIterator1</code> have the same <code>value&#95;type</code>, <code>InputIterator2's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, the ordering on <code>InputIterator2's</code><code>value&#95;type</code> is a strict weak ordering, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements, and <code>InputIterator2's</code><code>value&#95;type</code> is convertable to a type in <code>OutputIterator's</code> set of <code>value&#95;types</code>. 
* **`InputIterator3`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator3's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`InputIterator4`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator4's</code><code>value&#95;type</code> is convertible to a type in <code>OutputIterator2's</code> set of <code>value&#95;types</code>. 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`StrictWeakCompare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`keys_first1`** The beginning of the first input range of keys. 
* **`keys_last1`** The end of the first input range of keys. 
* **`keys_first2`** The beginning of the second input range of keys. 
* **`keys_last2`** The end of the second input range of keys. 
* **`values_first1`** The beginning of the first input range of values. 
* **`values_first2`** The beginning of the first input range of values. 
* **`keys_result`** The beginning of the output range of keys. 
* **`values_result`** The beginning of the output range of values. 
* **`comp`** Comparison operator. 

**Preconditions**:
* The ranges <code>[keys&#95;first1, keys&#95;last1)</code> and <code>[keys&#95;first2, keys&#95;last2)</code> shall be sorted with respect to <code>comp</code>. 
* The resulting ranges shall not overlap with any input range.

**Returns**:
A <code>pair</code><code>p</code> such that <code>p.first</code> is the end of the output range of keys, and such that <code>p.second</code> is the end of the output range of values.

**See**:
* <code>set&#95;symmetric&#95;difference&#95;by&#95;key</code>
* <code>set&#95;intersection&#95;by&#95;key</code>
* <code>set&#95;difference&#95;by&#95;key</code>
* <code>sort&#95;by&#95;key</code>
* <code>is&#95;sorted</code>

<h3 id="function-shuffle">
Function <code>thrust::shuffle</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomIterator,</span>
<span>&nbsp;&nbsp;typename URBG&gt;</span>
<span>__host__ __device__ void </span><span><b>shuffle</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomIterator first,</span>
<span>&nbsp;&nbsp;RandomIterator last,</span>
<span>&nbsp;&nbsp;URBG && g);</span></code>
<code>shuffle</code> reorders the elements <code>[first, last)</code> by a uniform pseudorandom permutation, defined by random engine <code>g</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>shuffle</code> to create a random permutation using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/shuffle.h>
#include <thrust/random.h>
#include <thrust/execution_policy.h>
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::default_random_engine g;
thrust::shuffle(thrust::host, A, A + N, g);
// A is now {6, 5, 8, 7, 2, 1, 4, 3, 10, 9}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomIterator`** is a random access iterator 
* **`URBG`** is a uniform random bit generator

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to shuffle. 
* **`last`** The end of the sequence to shuffle. 
* **`g`** A UniformRandomBitGenerator

**See**:
<code>shuffle&#95;copy</code>

<h3 id="function-shuffle">
Function <code>thrust::shuffle</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomIterator,</span>
<span>&nbsp;&nbsp;typename URBG&gt;</span>
<span>__host__ __device__ void </span><span><b>shuffle</b>(RandomIterator first,</span>
<span>&nbsp;&nbsp;RandomIterator last,</span>
<span>&nbsp;&nbsp;URBG && g);</span></code>
<code>shuffle</code> reorders the elements <code>[first, last)</code> by a uniform pseudorandom permutation, defined by random engine <code>g</code>.


The following code snippet demonstrates how to use <code>shuffle</code> to create a random permutation.



```cpp
#include <thrust/shuffle.h>
#include <thrust/random.h>
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
const int N = sizeof(A)/sizeof(int);
thrust::default_random_engine g;
thrust::shuffle(A, A + N, g);
// A is now {6, 5, 8, 7, 2, 1, 4, 3, 10, 9}
```

**Template Parameters**:
* **`RandomIterator`** is a random access iterator 
* **`URBG`** is a uniform random bit generator

**Function Parameters**:
* **`first`** The beginning of the sequence to shuffle. 
* **`last`** The end of the sequence to shuffle. 
* **`g`** A UniformRandomBitGenerator

**See**:
<code>shuffle&#95;copy</code>

<h3 id="function-shuffle-copy">
Function <code>thrust::shuffle&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename URBG&gt;</span>
<span>__host__ __device__ void </span><span><b>shuffle_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomIterator first,</span>
<span>&nbsp;&nbsp;RandomIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;URBG && g);</span></code>
shuffle_copy differs from shuffle only in that the reordered sequence is written to different output sequences, rather than in place. <code>shuffle&#95;copy</code> reorders the elements <code>[first, last)</code> by a uniform pseudorandom permutation, defined by random engine <code>g</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>shuffle&#95;copy</code> to create a random permutation.



```cpp
#include <thrust/shuffle.h>
#include <thrust/random.h>
#include <thrust/execution_policy.h>
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int result[10];
const int N = sizeof(A)/sizeof(int);
thrust::default_random_engine g;
thrust::shuffle_copy(thrust::host, A, A + N, result, g);
// result is now {6, 5, 8, 7, 2, 1, 4, 3, 10, 9}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomIterator`** is a random access iterator 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`URBG`** is a uniform random bit generator

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence to shuffle. 
* **`last`** The end of the sequence to shuffle. 
* **`result`** Destination of shuffled sequence 
* **`g`** A UniformRandomBitGenerator

**See**:
<code>shuffle</code>

<h3 id="function-shuffle-copy">
Function <code>thrust::shuffle&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename URBG&gt;</span>
<span>__host__ __device__ void </span><span><b>shuffle_copy</b>(RandomIterator first,</span>
<span>&nbsp;&nbsp;RandomIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;URBG && g);</span></code>
shuffle_copy differs from shuffle only in that the reordered sequence is written to different output sequences, rather than in place. <code>shuffle&#95;copy</code> reorders the elements <code>[first, last)</code> by a uniform pseudorandom permutation, defined by random engine <code>g</code>.


The following code snippet demonstrates how to use <code>shuffle&#95;copy</code> to create a random permutation.



```cpp
#include <thrust/shuffle.h>
#include <thrust/random.h>
int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int result[10];
const int N = sizeof(A)/sizeof(int);
thrust::default_random_engine g;
thrust::shuffle_copy(A, A + N, result, g);
// result is now {6, 5, 8, 7, 2, 1, 4, 3, 10, 9}
```

**Template Parameters**:
* **`RandomIterator`** is a random access iterator 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`URBG`** is a uniform random bit generator

**Function Parameters**:
* **`first`** The beginning of the sequence to shuffle. 
* **`last`** The end of the sequence to shuffle. 
* **`result`** Destination of shuffled sequence 
* **`g`** A UniformRandomBitGenerator

**See**:
<code>shuffle</code>

<h3 id="function-sort">
Function <code>thrust::sort</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>__host__ __device__ void </span><span><b>sort</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last);</span></code>
<code>sort</code> sorts the elements in <code>[first, last)</code> into ascending order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[first, last)</code> such that <code>i</code> precedes <code>j</code>, then <code>&#42;j</code> is not less than <code>&#42;i</code>. Note: <code>sort</code> is not guaranteed to be stable. That is, suppose that <code>&#42;i</code> and <code>&#42;j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by <code>sort</code>.

This version of <code>sort</code> compares objects using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>sort</code> to sort a sequence of integers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
thrust::sort(thrust::host, A, A + N);
// A is now {1, 2, 4, 5, 7, 8}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomAccessIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator</code> is mutable, and <code>RandomAccessIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering relation on <code>RandomAccessIterator's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>stable&#95;sort</code>
* <code>sort&#95;by&#95;key</code>

<h3 id="function-sort">
Function <code>thrust::sort</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomAccessIterator&gt;</span>
<span>void </span><span><b>sort</b>(RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last);</span></code>
<code>sort</code> sorts the elements in <code>[first, last)</code> into ascending order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[first, last)</code> such that <code>i</code> precedes <code>j</code>, then <code>&#42;j</code> is not less than <code>&#42;i</code>. Note: <code>sort</code> is not guaranteed to be stable. That is, suppose that <code>&#42;i</code> and <code>&#42;j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by <code>sort</code>.

This version of <code>sort</code> compares objects using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>sort</code> to sort a sequence of integers.



```cpp
#include <thrust/sort.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
thrust::sort(A, A + N);
// A is now {1, 2, 4, 5, 7, 8}
```

**Template Parameters**:
**`RandomAccessIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator</code> is mutable, and <code>RandomAccessIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering relation on <code>RandomAccessIterator's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>stable&#95;sort</code>
* <code>sort&#95;by&#95;key</code>

<h3 id="function-sort">
Function <code>thrust::sort</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b>sort</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>sort</code> sorts the elements in <code>[first, last)</code> into ascending order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[first, last)</code> such that <code>i</code> precedes <code>j</code>, then <code>&#42;j</code> is not less than <code>&#42;i</code>. Note: <code>sort</code> is not guaranteed to be stable. That is, suppose that <code>&#42;i</code> and <code>&#42;j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by <code>sort</code>.

This version of <code>sort</code> compares objects using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code demonstrates how to sort integers in descending order using the greater<int> comparison operator using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
thrust::sort(thrust::host, A, A + N, thrust::greater<int>());
// A is now {8, 7, 5, 4, 2, 1};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomAccessIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator</code> is mutable, and <code>RandomAccessIterator's</code><code>value&#95;type</code> is convertible to <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** Comparison operator.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>stable&#95;sort</code>
* <code>sort&#95;by&#95;key</code>

<h3 id="function-sort">
Function <code>thrust::sort</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b>sort</b>(RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>sort</code> sorts the elements in <code>[first, last)</code> into ascending order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[first, last)</code> such that <code>i</code> precedes <code>j</code>, then <code>&#42;j</code> is not less than <code>&#42;i</code>. Note: <code>sort</code> is not guaranteed to be stable. That is, suppose that <code>&#42;i</code> and <code>&#42;j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by <code>sort</code>.

This version of <code>sort</code> compares objects using a function object <code>comp</code>.


The following code demonstrates how to sort integers in descending order using the greater<int> comparison operator.



```cpp
#include <thrust/sort.h>
#include <thrust/functional.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
thrust::sort(A, A + N, thrust::greater<int>());
// A is now {8, 7, 5, 4, 2, 1};
```

**Template Parameters**:
* **`RandomAccessIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator</code> is mutable, and <code>RandomAccessIterator's</code><code>value&#95;type</code> is convertible to <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** Comparison operator.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>stable&#95;sort</code>
* <code>sort&#95;by&#95;key</code>

<h3 id="function-stable-sort">
Function <code>thrust::stable&#95;sort</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator&gt;</span>
<span>__host__ __device__ void </span><span><b>stable_sort</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last);</span></code>
<code>stable&#95;sort</code> is much like <code>sort:</code> it sorts the elements in <code>[first, last)</code> into ascending order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[first, last)</code> such that <code>i</code> precedes <code>j</code>, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

As the name suggests, <code>stable&#95;sort</code> is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code> such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of <code>stable&#95;sort</code> is that <code>x</code> still precedes <code>y</code>.

This version of <code>stable&#95;sort</code> compares objects using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>sort</code> to sort a sequence of integers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
thrust::stable_sort(thrust::host, A, A + N);
// A is now {1, 2, 4, 5, 7, 8}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomAccessIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator</code> is mutable, and <code>RandomAccessIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering relation on <code>RandomAccessIterator's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/stable_sort">https://en.cppreference.com/w/cpp/algorithm/stable_sort</a>
* <code>sort</code>
* <code>stable&#95;sort&#95;by&#95;key</code>

<h3 id="function-stable-sort">
Function <code>thrust::stable&#95;sort</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomAccessIterator&gt;</span>
<span>void </span><span><b>stable_sort</b>(RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last);</span></code>
<code>stable&#95;sort</code> is much like <code>sort:</code> it sorts the elements in <code>[first, last)</code> into ascending order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[first, last)</code> such that <code>i</code> precedes <code>j</code>, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

As the name suggests, <code>stable&#95;sort</code> is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code> such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of <code>stable&#95;sort</code> is that <code>x</code> still precedes <code>y</code>.

This version of <code>stable&#95;sort</code> compares objects using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>sort</code> to sort a sequence of integers.



```cpp
#include <thrust/sort.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
thrust::stable_sort(A, A + N);
// A is now {1, 2, 4, 5, 7, 8}
```

**Template Parameters**:
**`RandomAccessIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator</code> is mutable, and <code>RandomAccessIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering relation on <code>RandomAccessIterator's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/stable_sort">https://en.cppreference.com/w/cpp/algorithm/stable_sort</a>
* <code>sort</code>
* <code>stable&#95;sort&#95;by&#95;key</code>

<h3 id="function-stable-sort">
Function <code>thrust::stable&#95;sort</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b>stable_sort</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>stable&#95;sort</code> is much like <code>sort:</code> it sorts the elements in <code>[first, last)</code> into ascending order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[first, last)</code> such that <code>i</code> precedes <code>j</code>, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

As the name suggests, <code>stable&#95;sort</code> is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code> such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of <code>stable&#95;sort</code> is that <code>x</code> still precedes <code>y</code>.

This version of <code>stable&#95;sort</code> compares objects using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code demonstrates how to sort integers in descending order using the greater<int> comparison operator using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
thrust::sort(A, A + N, thrust::greater<int>());
// A is now {8, 7, 5, 4, 2, 1};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomAccessIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator</code> is mutable, and <code>RandomAccessIterator's</code><code>value&#95;type</code> is convertible to <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** Comparison operator.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/stable_sort">https://en.cppreference.com/w/cpp/algorithm/stable_sort</a>
* <code>sort</code>
* <code>stable&#95;sort&#95;by&#95;key</code>

<h3 id="function-stable-sort">
Function <code>thrust::stable&#95;sort</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomAccessIterator,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>void </span><span><b>stable_sort</b>(RandomAccessIterator first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator last,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>stable&#95;sort</code> is much like <code>sort:</code> it sorts the elements in <code>[first, last)</code> into ascending order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[first, last)</code> such that <code>i</code> precedes <code>j</code>, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

As the name suggests, <code>stable&#95;sort</code> is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements in <code>[first, last)</code> such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of <code>stable&#95;sort</code> is that <code>x</code> still precedes <code>y</code>.

This version of <code>stable&#95;sort</code> compares objects using a function object <code>comp</code>.


The following code demonstrates how to sort integers in descending order using the greater<int> comparison operator.



```cpp
#include <thrust/sort.h>
#include <thrust/functional.h>
...
const int N = 6;
int A[N] = {1, 4, 2, 8, 5, 7};
thrust::sort(A, A + N, thrust::greater<int>());
// A is now {8, 7, 5, 4, 2, 1};
```

**Template Parameters**:
* **`RandomAccessIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator</code> is mutable, and <code>RandomAccessIterator's</code><code>value&#95;type</code> is convertible to <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** Comparison operator.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/stable_sort">https://en.cppreference.com/w/cpp/algorithm/stable_sort</a>
* <code>sort</code>
* <code>stable&#95;sort&#95;by&#95;key</code>

<h3 id="function-sort-by-key">
Function <code>thrust::sort&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2&gt;</span>
<span>__host__ __device__ void </span><span><b>sort_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first);</span></code>
<code>sort&#95;by&#95;key</code> performs a key-value sort. That is, <code>sort&#95;by&#95;key</code> sorts the elements in <code>[keys&#95;first, keys&#95;last)</code> and <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> into ascending key order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[keys&#95;first, keys&#95;last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

Note: <code>sort&#95;by&#95;key</code> is not guaranteed to be stable. That is, suppose that <code>&#42;i</code> and <code>&#42;j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two keys or the relative order of their corresponding values will be preserved by <code>sort&#95;by&#95;key</code>.

This version of <code>sort&#95;by&#95;key</code> compares key objects using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>sort&#95;by&#95;key</code> to sort an array of character values using integers as sorting keys using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int    keys[N] = {  1,   4,   2,   8,   5,   7};
char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
thrust::sort_by_key(thrust::host, keys, keys + N, values);
// keys is now   {  1,   2,   4,   5,   7,   8}
// values is now {'a', 'c', 'b', 'e', 'f', 'd'}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomAccessIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator1</code> is mutable, and <code>RandomAccessIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering relation on <code>RandomAccessIterator1's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements. 
* **`RandomAccessIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">Random Access Iterator</a>, and <code>RandomAccessIterator2</code> is mutable.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the key sequence. 
* **`keys_last`** The end of the key sequence. 
* **`values_first`** The beginning of the value sequence.

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last))</code> shall not overlap the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>stable&#95;sort&#95;by&#95;key</code>
* <code>sort</code>

<h3 id="function-sort-by-key">
Function <code>thrust::sort&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2&gt;</span>
<span>void </span><span><b>sort_by_key</b>(RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first);</span></code>
<code>sort&#95;by&#95;key</code> performs a key-value sort. That is, <code>sort&#95;by&#95;key</code> sorts the elements in <code>[keys&#95;first, keys&#95;last)</code> and <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> into ascending key order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[keys&#95;first, keys&#95;last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

Note: <code>sort&#95;by&#95;key</code> is not guaranteed to be stable. That is, suppose that <code>&#42;i</code> and <code>&#42;j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two keys or the relative order of their corresponding values will be preserved by <code>sort&#95;by&#95;key</code>.

This version of <code>sort&#95;by&#95;key</code> compares key objects using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>sort&#95;by&#95;key</code> to sort an array of character values using integers as sorting keys.



```cpp
#include <thrust/sort.h>
...
const int N = 6;
int    keys[N] = {  1,   4,   2,   8,   5,   7};
char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
thrust::sort_by_key(keys, keys + N, values);
// keys is now   {  1,   2,   4,   5,   7,   8}
// values is now {'a', 'c', 'b', 'e', 'f', 'd'}
```

**Template Parameters**:
* **`RandomAccessIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator1</code> is mutable, and <code>RandomAccessIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering relation on <code>RandomAccessIterator1's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements. 
* **`RandomAccessIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">Random Access Iterator</a>, and <code>RandomAccessIterator2</code> is mutable.

**Function Parameters**:
* **`keys_first`** The beginning of the key sequence. 
* **`keys_last`** The end of the key sequence. 
* **`values_first`** The beginning of the value sequence.

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last))</code> shall not overlap the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>stable&#95;sort&#95;by&#95;key</code>
* <code>sort</code>

<h3 id="function-sort-by-key">
Function <code>thrust::sort&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b>sort_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>sort&#95;by&#95;key</code> performs a key-value sort. That is, <code>sort&#95;by&#95;key</code> sorts the elements in <code>[keys&#95;first, keys&#95;last)</code> and <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> into ascending key order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[keys&#95;first, keys&#95;last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

Note: <code>sort&#95;by&#95;key</code> is not guaranteed to be stable. That is, suppose that <code>&#42;i</code> and <code>&#42;j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two keys or the relative order of their corresponding values will be preserved by <code>sort&#95;by&#95;key</code>.

This version of <code>sort&#95;by&#95;key</code> compares key objects using a function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>sort&#95;by&#95;key</code> to sort an array of character values using integers as sorting keys using the <code>thrust::host</code> execution policy for parallelization.The keys are sorted in descending order using the <code>greater&lt;int&gt;</code> comparison operator.



```cpp
#include <thrust/sort.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int    keys[N] = {  1,   4,   2,   8,   5,   7};
char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
thrust::sort_by_key(thrust::host, keys, keys + N, values, thrust::greater<int>());
// keys is now   {  8,   7,   5,   4,   2,   1}
// values is now {'d', 'f', 'e', 'b', 'c', 'a'}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomAccessIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator1</code> is mutable, and <code>RandomAccessIterator1's</code><code>value&#95;type</code> is convertible to <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`RandomAccessIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">Random Access Iterator</a>, and <code>RandomAccessIterator2</code> is mutable. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the key sequence. 
* **`keys_last`** The end of the key sequence. 
* **`values_first`** The beginning of the value sequence. 
* **`comp`** Comparison operator.

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last))</code> shall not overlap the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>stable&#95;sort&#95;by&#95;key</code>
* <code>sort</code>

<h3 id="function-sort-by-key">
Function <code>thrust::sort&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>void </span><span><b>sort_by_key</b>(RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>sort&#95;by&#95;key</code> performs a key-value sort. That is, <code>sort&#95;by&#95;key</code> sorts the elements in <code>[keys&#95;first, keys&#95;last)</code> and <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> into ascending key order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[keys&#95;first, keys&#95;last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

Note: <code>sort&#95;by&#95;key</code> is not guaranteed to be stable. That is, suppose that <code>&#42;i</code> and <code>&#42;j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two keys or the relative order of their corresponding values will be preserved by <code>sort&#95;by&#95;key</code>.

This version of <code>sort&#95;by&#95;key</code> compares key objects using a function object <code>comp</code>.


The following code snippet demonstrates how to use <code>sort&#95;by&#95;key</code> to sort an array of character values using integers as sorting keys. The keys are sorted in descending order using the greater<int> comparison operator.



```cpp
#include <thrust/sort.h>
...
const int N = 6;
int    keys[N] = {  1,   4,   2,   8,   5,   7};
char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
thrust::sort_by_key(keys, keys + N, values, thrust::greater<int>());
// keys is now   {  8,   7,   5,   4,   2,   1}
// values is now {'d', 'f', 'e', 'b', 'c', 'a'}
```

**Template Parameters**:
* **`RandomAccessIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator1</code> is mutable, and <code>RandomAccessIterator1's</code><code>value&#95;type</code> is convertible to <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`RandomAccessIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">Random Access Iterator</a>, and <code>RandomAccessIterator2</code> is mutable. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`keys_first`** The beginning of the key sequence. 
* **`keys_last`** The end of the key sequence. 
* **`values_first`** The beginning of the value sequence. 
* **`comp`** Comparison operator.

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last))</code> shall not overlap the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>stable&#95;sort&#95;by&#95;key</code>
* <code>sort</code>

<h3 id="function-stable-sort-by-key">
Function <code>thrust::stable&#95;sort&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2&gt;</span>
<span>__host__ __device__ void </span><span><b>stable_sort_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first);</span></code>
<code>stable&#95;sort&#95;by&#95;key</code> performs a key-value sort. That is, <code>stable&#95;sort&#95;by&#95;key</code> sorts the elements in <code>[keys&#95;first, keys&#95;last)</code> and <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> into ascending key order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[keys&#95;first, keys&#95;last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

As the name suggests, <code>stable&#95;sort&#95;by&#95;key</code> is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements in <code>[keys&#95;first, keys&#95;last)</code> such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of <code>stable&#95;sort&#95;by&#95;key</code> is that <code>x</code> still precedes <code>y</code>.

This version of <code>stable&#95;sort&#95;by&#95;key</code> compares key objects using <code>operator&lt;</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>stable&#95;sort&#95;by&#95;key</code> to sort an array of characters using integers as sorting keys using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int    keys[N] = {  1,   4,   2,   8,   5,   7};
char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
thrust::stable_sort_by_key(thrust::host, keys, keys + N, values);
// keys is now   {  1,   2,   4,   5,   7,   8}
// values is now {'a', 'c', 'b', 'e', 'f', 'd'}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomAccessIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator1</code> is mutable, and <code>RandomAccessIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering relation on <code>RandomAccessIterator1's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements. 
* **`RandomAccessIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">Random Access Iterator</a>, and <code>RandomAccessIterator2</code> is mutable.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the key sequence. 
* **`keys_last`** The end of the key sequence. 
* **`values_first`** The beginning of the value sequence.

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last))</code> shall not overlap the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>sort&#95;by&#95;key</code>
* <code>stable&#95;sort</code>

<h3 id="function-stable-sort-by-key">
Function <code>thrust::stable&#95;sort&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2&gt;</span>
<span>void </span><span><b>stable_sort_by_key</b>(RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first);</span></code>
<code>stable&#95;sort&#95;by&#95;key</code> performs a key-value sort. That is, <code>stable&#95;sort&#95;by&#95;key</code> sorts the elements in <code>[keys&#95;first, keys&#95;last)</code> and <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> into ascending key order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[keys&#95;first, keys&#95;last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

As the name suggests, <code>stable&#95;sort&#95;by&#95;key</code> is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements in <code>[keys&#95;first, keys&#95;last)</code> such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of <code>stable&#95;sort&#95;by&#95;key</code> is that <code>x</code> still precedes <code>y</code>.

This version of <code>stable&#95;sort&#95;by&#95;key</code> compares key objects using <code>operator&lt;</code>.


The following code snippet demonstrates how to use <code>stable&#95;sort&#95;by&#95;key</code> to sort an array of characters using integers as sorting keys.



```cpp
#include <thrust/sort.h>
...
const int N = 6;
int    keys[N] = {  1,   4,   2,   8,   5,   7};
char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
thrust::stable_sort_by_key(keys, keys + N, values);
// keys is now   {  1,   2,   4,   5,   7,   8}
// values is now {'a', 'c', 'b', 'e', 'f', 'd'}
```

**Template Parameters**:
* **`RandomAccessIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator1</code> is mutable, and <code>RandomAccessIterator1's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering relation on <code>RandomAccessIterator1's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements. 
* **`RandomAccessIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">Random Access Iterator</a>, and <code>RandomAccessIterator2</code> is mutable.

**Function Parameters**:
* **`keys_first`** The beginning of the key sequence. 
* **`keys_last`** The end of the key sequence. 
* **`values_first`** The beginning of the value sequence.

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last))</code> shall not overlap the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>sort&#95;by&#95;key</code>
* <code>stable&#95;sort</code>

<h3 id="function-stable-sort-by-key">
Function <code>thrust::stable&#95;sort&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>__host__ __device__ void </span><span><b>stable_sort_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>stable&#95;sort&#95;by&#95;key</code> performs a key-value sort. That is, <code>stable&#95;sort&#95;by&#95;key</code> sorts the elements in <code>[keys&#95;first, keys&#95;last)</code> and <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> into ascending key order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[keys&#95;first, keys&#95;last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

As the name suggests, <code>stable&#95;sort&#95;by&#95;key</code> is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements in <code>[keys&#95;first, keys&#95;last)</code> such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of <code>stable&#95;sort&#95;by&#95;key</code> is that <code>x</code> still precedes <code>y</code>.

This version of <code>stable&#95;sort&#95;by&#95;key</code> compares key objects using the function object <code>comp</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>sort&#95;by&#95;key</code> to sort an array of character values using integers as sorting keys using the <code>thrust::host</code> execution policy for parallelization. The keys are sorted in descending order using the <code>greater&lt;int&gt;</code> comparison operator.



```cpp
#include <thrust/sort.h>
#include <thrust/execution_policy.h>
...
const int N = 6;
int    keys[N] = {  1,   4,   2,   8,   5,   7};
char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
thrust::stable_sort_by_key(thrust::host, keys, keys + N, values, thrust::greater<int>());
// keys is now   {  8,   7,   5,   4,   2,   1}
// values is now {'d', 'f', 'e', 'b', 'c', 'a'}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`RandomAccessIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator1</code> is mutable, and <code>RandomAccessIterator1's</code><code>value&#95;type</code> is convertible to <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`RandomAccessIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">Random Access Iterator</a>, and <code>RandomAccessIterator2</code> is mutable. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the key sequence. 
* **`keys_last`** The end of the key sequence. 
* **`values_first`** The beginning of the value sequence. 
* **`comp`** Comparison operator.

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last))</code> shall not overlap the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>sort&#95;by&#95;key</code>
* <code>stable&#95;sort</code>

<h3 id="function-stable-sort-by-key">
Function <code>thrust::stable&#95;sort&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename RandomAccessIterator1,</span>
<span>&nbsp;&nbsp;typename RandomAccessIterator2,</span>
<span>&nbsp;&nbsp;typename StrictWeakOrdering&gt;</span>
<span>void </span><span><b>stable_sort_by_key</b>(RandomAccessIterator1 keys_first,</span>
<span>&nbsp;&nbsp;RandomAccessIterator1 keys_last,</span>
<span>&nbsp;&nbsp;RandomAccessIterator2 values_first,</span>
<span>&nbsp;&nbsp;StrictWeakOrdering comp);</span></code>
<code>stable&#95;sort&#95;by&#95;key</code> performs a key-value sort. That is, <code>stable&#95;sort&#95;by&#95;key</code> sorts the elements in <code>[keys&#95;first, keys&#95;last)</code> and <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> into ascending key order, meaning that if <code>i</code> and <code>j</code> are any two valid iterators in <code>[keys&#95;first, keys&#95;last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>&#42;j</code> is not less than <code>&#42;i</code>.

As the name suggests, <code>stable&#95;sort&#95;by&#95;key</code> is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements in <code>[keys&#95;first, keys&#95;last)</code> such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of <code>stable&#95;sort&#95;by&#95;key</code> is that <code>x</code> still precedes <code>y</code>.

This version of <code>stable&#95;sort&#95;by&#95;key</code> compares key objects using the function object <code>comp</code>.


The following code snippet demonstrates how to use <code>sort&#95;by&#95;key</code> to sort an array of character values using integers as sorting keys. The keys are sorted in descending order using the greater<int> comparison operator.



```cpp
#include <thrust/sort.h>
...
const int N = 6;
int    keys[N] = {  1,   4,   2,   8,   5,   7};
char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
thrust::stable_sort_by_key(keys, keys + N, values, thrust::greater<int>());
// keys is now   {  8,   7,   5,   4,   2,   1}
// values is now {'d', 'f', 'e', 'b', 'c', 'a'}
```

**Template Parameters**:
* **`RandomAccessIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator">Random Access Iterator</a>, <code>RandomAccessIterator1</code> is mutable, and <code>RandomAccessIterator1's</code><code>value&#95;type</code> is convertible to <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`RandomAccessIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">Random Access Iterator</a>, and <code>RandomAccessIterator2</code> is mutable. 
* **`StrictWeakOrdering`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`keys_first`** The beginning of the key sequence. 
* **`keys_last`** The end of the key sequence. 
* **`values_first`** The beginning of the value sequence. 
* **`comp`** Comparison operator.

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last))</code> shall not overlap the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/sort">https://en.cppreference.com/w/cpp/algorithm/sort</a>
* <code>sort&#95;by&#95;key</code>
* <code>stable&#95;sort</code>

<h3 id="function-is-sorted">
Function <code>thrust::is&#95;sorted</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ bool </span><span><b>is_sorted</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>is&#95;sorted</code> returns <code>true</code> if the range <code>[first, last)</code> is sorted in ascending order, and <code>false</code> otherwise.

Specifically, this version of <code>is&#95;sorted</code> returns <code>false</code> if for some iterator <code>i</code> in the range <code>[first, last - 1)</code> the expression <code>&#42;(i + 1) &lt; &#42;i</code> is <code>true</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code demonstrates how to use <code>is&#95;sorted</code> to test whether the contents of a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> are stored in ascending order using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/device_vector.h>
#include <thrust/sort.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> v(6);
v[0] = 1;
v[1] = 4;
v[2] = 2;
v[3] = 8;
v[4] = 5;
v[5] = 7;

bool result = thrust::is_sorted(thrust::device, v.begin(), v.end());

// result == false

thrust::sort(v.begin(), v.end());
result = thrust::is_sorted(thrust::device, v.begin(), v.end());

// result == true
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering on objects of <code>ForwardIterator's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
<code>true</code>, if the sequence is sorted; <code>false</code>, otherwise.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/is_sorted">https://en.cppreference.com/w/cpp/algorithm/is_sorted</a>
* is_sorted_until 
* <code>sort</code>
* <code>stable&#95;sort</code>
* <code>less&lt;T&gt;</code>

<h3 id="function-is-sorted">
Function <code>thrust::is&#95;sorted</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator&gt;</span>
<span>bool </span><span><b>is_sorted</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>is&#95;sorted</code> returns <code>true</code> if the range <code>[first, last)</code> is sorted in ascending order, and <code>false</code> otherwise.

Specifically, this version of <code>is&#95;sorted</code> returns <code>false</code> if for some iterator <code>i</code> in the range <code>[first, last - 1)</code> the expression <code>&#42;(i + 1) &lt; &#42;i</code> is <code>true</code>.


The following code demonstrates how to use <code>is&#95;sorted</code> to test whether the contents of a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> are stored in ascending order.



```cpp
#include <thrust/sort.h>
#include <thrust/device_vector.h>
#include <thrust/sort.h>
...
thrust::device_vector<int> v(6);
v[0] = 1;
v[1] = 4;
v[2] = 2;
v[3] = 8;
v[4] = 5;
v[5] = 7;

bool result = thrust::is_sorted(v.begin(), v.end());

// result == false

thrust::sort(v.begin(), v.end());
result = thrust::is_sorted(v.begin(), v.end());

// result == true
```

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>, and the ordering on objects of <code>ForwardIterator's</code><code>value&#95;type</code> is a _strict weak ordering_, as defined in the <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a> requirements.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 

**Returns**:
<code>true</code>, if the sequence is sorted; <code>false</code>, otherwise.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/is_sorted">https://en.cppreference.com/w/cpp/algorithm/is_sorted</a>
* is_sorted_until 
* <code>sort</code>
* <code>stable&#95;sort</code>
* <code>less&lt;T&gt;</code>

<h3 id="function-is-sorted">
Function <code>thrust::is&#95;sorted</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>__host__ __device__ bool </span><span><b>is_sorted</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Compare comp);</span></code>
<code>is&#95;sorted</code> returns <code>true</code> if the range <code>[first, last)</code> is sorted in ascending order accoring to a user-defined comparison operation, and <code>false</code> otherwise.

Specifically, this version of <code>is&#95;sorted</code> returns <code>false</code> if for some iterator <code>i</code> in the range <code>[first, last - 1)</code> the expression <code>comp(&#42;(i + 1), &#42;i)</code> is <code>true</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>is&#95;sorted</code> to test whether the contents of a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> are stored in descending order using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/functional.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> v(6);
v[0] = 1;
v[1] = 4;
v[2] = 2;
v[3] = 8;
v[4] = 5;
v[5] = 7;

thrust::greater<int> comp;
bool result = thrust::is_sorted(thrust::device, v.begin(), v.end(), comp);

// result == false

thrust::sort(v.begin(), v.end(), comp);
result = thrust::is_sorted(thrust::device, v.begin(), v.end(), comp);

// result == true
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to both <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`Compare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** Comparison operator. 

**Returns**:
<code>true</code>, if the sequence is sorted according to comp; <code>false</code>, otherwise.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/is_sorted">https://en.cppreference.com/w/cpp/algorithm/is_sorted</a>
* <code>sort</code>
* <code>stable&#95;sort</code>
* <code>less&lt;T&gt;</code>

<h3 id="function-is-sorted">
Function <code>thrust::is&#95;sorted</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>bool </span><span><b>is_sorted</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Compare comp);</span></code>
<code>is&#95;sorted</code> returns <code>true</code> if the range <code>[first, last)</code> is sorted in ascending order accoring to a user-defined comparison operation, and <code>false</code> otherwise.

Specifically, this version of <code>is&#95;sorted</code> returns <code>false</code> if for some iterator <code>i</code> in the range <code>[first, last - 1)</code> the expression <code>comp(&#42;(i + 1), &#42;i)</code> is <code>true</code>.


The following code snippet demonstrates how to use <code>is&#95;sorted</code> to test whether the contents of a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1device__vector.html">device&#95;vector</a></code> are stored in descending order.



```cpp
#include <thrust/sort.h>
#include <thrust/functional.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> v(6);
v[0] = 1;
v[1] = 4;
v[2] = 2;
v[3] = 8;
v[4] = 5;
v[5] = 7;

thrust::greater<int> comp;
bool result = thrust::is_sorted(v.begin(), v.end(), comp);

// result == false

thrust::sort(v.begin(), v.end(), comp);
result = thrust::is_sorted(v.begin(), v.end(), comp);

// result == true
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to both <code>StrictWeakOrdering's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`Compare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`comp`** Comparison operator. 

**Returns**:
<code>true</code>, if the sequence is sorted according to comp; <code>false</code>, otherwise.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/is_sorted">https://en.cppreference.com/w/cpp/algorithm/is_sorted</a>
* <code>sort</code>
* <code>stable&#95;sort</code>
* <code>less&lt;T&gt;</code>

<h3 id="function-is-sorted-until">
Function <code>thrust::is&#95;sorted&#95;until</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>is_sorted_until</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
This version of <code>is&#95;sorted&#95;until</code> returns the last iterator <code>i</code> in <code>[first,last]</code> for which the range <code>[first,last)</code> is sorted using <code>operator&lt;</code>. If <code>distance(first,last) &lt; 2</code>, <code>is&#95;sorted&#95;until</code> simply returns <code>last</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>is&#95;sorted&#95;until</code> to find the first position in an array where the data becomes unsorted using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/execution_policy.h>

...
 
int A[8] = {0, 1, 2, 3, 0, 1, 2, 3};

int * B = thrust::is_sorted_until(thrust::host, A, A + 8);

// B - A is 4
// [A, B) is sorted
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a> and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 

**Returns**:
The last iterator in the input range for which it is sorted.

**See**:
* <code>is&#95;sorted</code>
* <code>sort</code>
* <code>sort&#95;by&#95;key</code>
* <code>stable&#95;sort</code>
* <code>stable&#95;sort&#95;by&#95;key</code>

<h3 id="function-is-sorted-until">
Function <code>thrust::is&#95;sorted&#95;until</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b>is_sorted_until</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
This version of <code>is&#95;sorted&#95;until</code> returns the last iterator <code>i</code> in <code>[first,last]</code> for which the range <code>[first,last)</code> is sorted using <code>operator&lt;</code>. If <code>distance(first,last) &lt; 2</code>, <code>is&#95;sorted&#95;until</code> simply returns <code>last</code>.


The following code snippet demonstrates how to use <code>is&#95;sorted&#95;until</code> to find the first position in an array where the data becomes unsorted:



```cpp
#include <thrust/sort.h>

...
 
int A[8] = {0, 1, 2, 3, 0, 1, 2, 3};

int * B = thrust::is_sorted_until(A, A + 8);

// B - A is 4
// [A, B) is sorted
```

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a> and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">LessThan Comparable</a>.

**Function Parameters**:
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 

**Returns**:
The last iterator in the input range for which it is sorted.

**See**:
* <code>is&#95;sorted</code>
* <code>sort</code>
* <code>sort&#95;by&#95;key</code>
* <code>stable&#95;sort</code>
* <code>stable&#95;sort&#95;by&#95;key</code>

<h3 id="function-is-sorted-until">
Function <code>thrust::is&#95;sorted&#95;until</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>is_sorted_until</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Compare comp);</span></code>
This version of <code>is&#95;sorted&#95;until</code> returns the last iterator <code>i</code> in <code>[first,last]</code> for which the range <code>[first,last)</code> is sorted using the function object <code>comp</code>. If <code>distance(first,last) &lt; 2</code>, <code>is&#95;sorted&#95;until</code> simply returns <code>last</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>is&#95;sorted&#95;until</code> to find the first position in an array where the data becomes unsorted in descending order using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/sort.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>

...
 
int A[8] = {3, 2, 1, 0, 3, 2, 1, 0};

thrust::greater<int> comp;
int * B = thrust::is_sorted_until(thrust::host, A, A + 8, comp);

// B - A is 4
// [A, B) is sorted in descending order
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a> and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Compare's</code><code>argument&#95;type</code>. 
* **`Compare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization: 
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`comp`** The function object to use for comparison. 

**Returns**:
The last iterator in the input range for which it is sorted.

**See**:
* <code>is&#95;sorted</code>
* <code>sort</code>
* <code>sort&#95;by&#95;key</code>
* <code>stable&#95;sort</code>
* <code>stable&#95;sort&#95;by&#95;key</code>

<h3 id="function-is-sorted-until">
Function <code>thrust::is&#95;sorted&#95;until</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Compare&gt;</span>
<span>ForwardIterator </span><span><b>is_sorted_until</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;Compare comp);</span></code>
This version of <code>is&#95;sorted&#95;until</code> returns the last iterator <code>i</code> in <code>[first,last]</code> for which the range <code>[first,last)</code> is sorted using the function object <code>comp</code>. If <code>distance(first,last) &lt; 2</code>, <code>is&#95;sorted&#95;until</code> simply returns <code>last</code>.


The following code snippet demonstrates how to use <code>is&#95;sorted&#95;until</code> to find the first position in an array where the data becomes unsorted in descending order:



```cpp
#include <thrust/sort.h>
#include <thrust/functional.h>

...
 
int A[8] = {3, 2, 1, 0, 3, 2, 1, 0};

thrust::greater<int> comp;
int * B = thrust::is_sorted_until(A, A + 8, comp);

// B - A is 4
// [A, B) is sorted in descending order
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a> and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>Compare's</code><code>argument&#95;type</code>. 
* **`Compare`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/strict_weak_order">Strict Weak Ordering</a>.

**Function Parameters**:
* **`first`** The beginning of the range of interest. 
* **`last`** The end of the range of interest. 
* **`comp`** The function object to use for comparison. 

**Returns**:
The last iterator in the input range for which it is sorted.

**See**:
* <code>is&#95;sorted</code>
* <code>sort</code>
* <code>sort&#95;by&#95;key</code>
* <code>stable&#95;sort</code>
* <code>stable&#95;sort&#95;by&#95;key</code>

<h3 id="function-swap">
Function <code>thrust::swap</code>
</h3>

<code class="doxybook">
<span>template &lt;typename Assignable1,</span>
<span>&nbsp;&nbsp;typename Assignable2&gt;</span>
<span>__host__ __device__ void </span><span><b>swap</b>(Assignable1 & a,</span>
<span>&nbsp;&nbsp;Assignable2 & b);</span></code>
<code>swap</code> assigns the contents of <code>a</code> to <code>b</code> and the contents of <code>b</code> to <code>a</code>. This is used as a primitive operation by many other algorithms.


The following code snippet demonstrates how to use <code>swap</code> to swap the contents of two variables.



```cpp
#include <thrust/swap.h>
...
int x = 1;
int y = 2;
thrust::swap(x,h);

// x == 2, y == 1
```

**Template Parameters**:
**`Assignable`**: is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>.

**Function Parameters**:
* **`a`** The first value of interest. After completion, the value of b will be returned here. 
* **`b`** The second value of interest. After completion, the value of a will be returned here.

<h3 id="function-swap-ranges">
Function <code>thrust::swap&#95;ranges</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2&gt;</span>
<span>__host__ __device__ ForwardIterator2 </span><span><b>swap_ranges</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator1 first1,</span>
<span>&nbsp;&nbsp;ForwardIterator1 last1,</span>
<span>&nbsp;&nbsp;ForwardIterator2 first2);</span></code>
<code>swap&#95;ranges</code> swaps each of the elements in the range <code>[first1, last1)</code> with the corresponding element in the range <code>[first2, first2 + (last1 - first1))</code>. That is, for each integer <code>n</code> such that <code>0 &lt;= n &lt; (last1 - first1)</code>, it swaps <code>&#42;(first1 + n)</code> and <code>&#42;(first2 + n)</code>. The return value is <code>first2 + (last1 - first1)</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>swap&#95;ranges</code> to swap the contents of two <code>thrust::device&#95;vectors</code> using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/swap.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
...
thrust::device_vector<int> v1(2), v2(2);
v1[0] = 1;
v1[1] = 2;
v2[0] = 3;
v2[1] = 4;

thrust::swap_ranges(thrust::device, v1.begin(), v1.end(), v2.begin());

// v1[0] == 3, v1[1] == 4, v2[0] == 1, v2[1] == 2
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator1's</code><code>value&#95;type</code> must be convertible to <code>ForwardIterator2's</code><code>value&#95;type</code>. 
* **`ForwardIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator2's</code><code>value&#95;type</code> must be convertible to <code>ForwardIterator1's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first sequence to swap. 
* **`last1`** One position past the last element of the first sequence to swap. 
* **`first2`** The beginning of the second sequence to swap. 

**Preconditions**:
<code>first1</code> may equal <code>first2</code>, but the range <code>[first1, last1)</code> shall not overlap the range <code>[first2, first2 + (last1 - first1))</code> otherwise.

**Returns**:
An iterator pointing to one position past the last element of the second sequence to swap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/swap_ranges">https://en.cppreference.com/w/cpp/algorithm/swap_ranges</a>
* <code><a href="{{ site.baseurl }}/api/groups/group__swap.html">Swap</a></code>

<h3 id="function-swap-ranges">
Function <code>thrust::swap&#95;ranges</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2&gt;</span>
<span>ForwardIterator2 </span><span><b>swap_ranges</b>(ForwardIterator1 first1,</span>
<span>&nbsp;&nbsp;ForwardIterator1 last1,</span>
<span>&nbsp;&nbsp;ForwardIterator2 first2);</span></code>
<code>swap&#95;ranges</code> swaps each of the elements in the range <code>[first1, last1)</code> with the corresponding element in the range <code>[first2, first2 + (last1 - first1))</code>. That is, for each integer <code>n</code> such that <code>0 &lt;= n &lt; (last1 - first1)</code>, it swaps <code>&#42;(first1 + n)</code> and <code>&#42;(first2 + n)</code>. The return value is <code>first2 + (last1 - first1)</code>.


The following code snippet demonstrates how to use <code>swap&#95;ranges</code> to swap the contents of two <code>thrust::device&#95;vectors</code>.



```cpp
#include <thrust/swap.h>
#include <thrust/device_vector.h>
...
thrust::device_vector<int> v1(2), v2(2);
v1[0] = 1;
v1[1] = 2;
v2[0] = 3;
v2[1] = 4;

thrust::swap_ranges(v1.begin(), v1.end(), v2.begin());

// v1[0] == 3, v1[1] == 4, v2[0] == 1, v2[1] == 2
```

**Template Parameters**:
* **`ForwardIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator1's</code><code>value&#95;type</code> must be convertible to <code>ForwardIterator2's</code><code>value&#95;type</code>. 
* **`ForwardIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator2's</code><code>value&#95;type</code> must be convertible to <code>ForwardIterator1's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first1`** The beginning of the first sequence to swap. 
* **`last1`** One position past the last element of the first sequence to swap. 
* **`first2`** The beginning of the second sequence to swap. 

**Preconditions**:
<code>first1</code> may equal <code>first2</code>, but the range <code>[first1, last1)</code> shall not overlap the range <code>[first2, first2 + (last1 - first1))</code> otherwise.

**Returns**:
An iterator pointing to one position past the last element of the second sequence to swap.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/swap_ranges">https://en.cppreference.com/w/cpp/algorithm/swap_ranges</a>
* <code><a href="{{ site.baseurl }}/api/groups/group__swap.html">Swap</a></code>

<h3 id="function-unique-eager-event-type">
Function <code>thrust::unique&#95;eager&#95;event&#95;type</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy&gt;</span>
<span>__host__ thrust::cuda::unique_eager_event </span><span><b>unique_eager_event_type</b>(thrust::cuda::execution_policy< DerivedPolicy > const &);</span></code>
<h3 id="function-unique-eager-future-type">
Function <code>thrust::unique&#95;eager&#95;future&#95;type</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T,</span>
<span>&nbsp;&nbsp;typename DerivedPolicy&gt;</span>
<span>__host__ thrust::cuda::unique_eager_future< T > </span><span><b>unique_eager_future_type</b>(thrust::cuda::execution_policy< DerivedPolicy > const &);</span></code>
<h3 id="function-tabulate">
Function <code>thrust::tabulate</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryOperation&gt;</span>
<span>__host__ __device__ void </span><span><b>tabulate</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;UnaryOperation unary_op);</span></code>
<code>tabulate</code> fills the range <code>[first, last)</code> with the value of a function applied to each element's index.

For each iterator <code>i</code> in the range <code>[first, last)</code>, <code>tabulate</code> performs the assignment <code>&#42;i = unary&#95;op(i - first)</code>.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>tabulate</code> to generate the first <code>n</code> non-positive integers using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/tabulate.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...
const int N = 10;
int A[N];
thrust::tabulate(thrust::host, A, A + 10, thrust::negate<int>());
// A is now {0, -1, -2, -3, -4, -5, -6, -7, -8, -9}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and if <code>x</code> and <code>y</code> are objects of <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined, and if <code>T</code> is <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined. 
* **`UnaryOperation`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the range. 
* **`last`** The end of the range. 
* **`unary_op`** The unary operation to apply.

**See**:
* thrust::fill 
* thrust::generate 
* thrust::sequence 

<h3 id="function-tabulate">
Function <code>thrust::tabulate</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryOperation&gt;</span>
<span>void </span><span><b>tabulate</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;UnaryOperation unary_op);</span></code>
<code>tabulate</code> fills the range <code>[first, last)</code> with the value of a function applied to each element's index.

For each iterator <code>i</code> in the range <code>[first, last)</code>, <code>tabulate</code> performs the assignment <code>&#42;i = unary&#95;op(i - first)</code>.


The following code snippet demonstrates how to use <code>tabulate</code> to generate the first <code>n</code> non-positive integers:



```cpp
#include <thrust/tabulate.h>
#include <thrust/functional.h>
...
const int N = 10;
int A[N];
thrust::tabulate(A, A + 10, thrust::negate<int>());
// A is now {0, -1, -2, -3, -4, -5, -6, -7, -8, -9}
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and if <code>x</code> and <code>y</code> are objects of <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>x + y</code> is defined, and if <code>T</code> is <code>ForwardIterator's</code><code>value&#95;type</code>, then <code>T(0)</code> is defined. 
* **`UnaryOperation`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the range. 
* **`last`** The end of the range. 
* **`unary_op`** The unary operation to apply.

**See**:
* thrust::fill 
* thrust::generate 
* thrust::sequence 

<h3 id="function-transform">
Function <code>thrust::transform</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>transform</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op);</span></code>
This version of <code>transform</code> applies a unary function to each element of an input sequence and stores the result in the corresponding position in an output sequence. Specifically, for each iterator <code>i</code> in the range [<code>first</code>, <code>last</code>) the operation <code>op(&#42;i)</code> is performed and the result is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range [<code>result</code>, <code>result</code> + (<code>last</code> - <code>first</code>) ). The input and output sequences may coincide, resulting in an in-place transformation.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>transform</code> to negate a range in-place using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

thrust::negate<int> op;

thrust::transform(thrust::host, data, data + 10, data, op); // in-place transformation

// data is now {5, 0, -2, 3, -2, -4, 0, 1, -2, -8};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`op`** The transformation operation. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a>

<h3 id="function-transform">
Function <code>thrust::transform</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction&gt;</span>
<span>OutputIterator </span><span><b>transform</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op);</span></code>
This version of <code>transform</code> applies a unary function to each element of an input sequence and stores the result in the corresponding position in an output sequence. Specifically, for each iterator <code>i</code> in the range [<code>first</code>, <code>last</code>) the operation <code>op(&#42;i)</code> is performed and the result is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range [<code>result</code>, <code>result</code> + (<code>last</code> - <code>first</code>) ). The input and output sequences may coincide, resulting in an in-place transformation.


The following code snippet demonstrates how to use <code>transform</code>



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>

int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

thrust::negate<int> op;

thrust::transform(data, data + 10, data, op); // in-place transformation

// data is now {5, 0, -2, 3, -2, -4, 0, 1, -2, -8};
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`op`** The tranformation operation. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a>

<h3 id="function-transform">
Function <code>thrust::transform</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>transform</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction op);</span></code>
This version of <code>transform</code> applies a binary function to each pair of elements from two input sequences and stores the result in the corresponding position in an output sequence. Specifically, for each iterator <code>i</code> in the range [<code>first1</code>, <code>last1</code>) and <code>j = first + (i - first1)</code> in the range [<code>first2</code>, <code>last2</code>) the operation <code>op(&#42;i,&#42;j)</code> is performed and the result is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range [<code>result</code>, <code>result</code> + (<code>last</code> - <code>first</code>) ). The input and output sequences may coincide, resulting in an in-place transformation.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>transform</code> to compute the sum of two ranges using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int input1[6] = {-5,  0,  2,  3,  2,  4};
int input2[6] = { 3,  6, -2,  1,  2,  3};
int output[6];

thrust::plus<int> op;

thrust::transform(thrust::host, input1, input1 + 6, input2, output, op);

// output is now {-2,  6,  0,  4,  4,  7};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>second&#95;argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input sequence. 
* **`last1`** The end of the first input sequence. 
* **`first2`** The beginning of the second input sequence. 
* **`result`** The beginning of the output sequence. 
* **`op`** The tranformation operation. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code>, but the range <code>[first1, last1)</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise. 
* <code>first2</code> may equal <code>result</code>, but the range <code>[first2, first2 + (last1 - first1))</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a>

<h3 id="function-transform">
Function <code>thrust::transform</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>OutputIterator </span><span><b>transform</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction op);</span></code>
This version of <code>transform</code> applies a binary function to each pair of elements from two input sequences and stores the result in the corresponding position in an output sequence. Specifically, for each iterator <code>i</code> in the range [<code>first1</code>, <code>last1</code>) and <code>j = first + (i - first1)</code> in the range [<code>first2</code>, <code>last2</code>) the operation <code>op(&#42;i,&#42;j)</code> is performed and the result is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range [<code>result</code>, <code>result</code> + (<code>last</code> - <code>first</code>) ). The input and output sequences may coincide, resulting in an in-place transformation.


The following code snippet demonstrates how to use <code>transform</code>



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>

int input1[6] = {-5,  0,  2,  3,  2,  4};
int input2[6] = { 3,  6, -2,  1,  2,  3};
int output[6];

thrust::plus<int> op;

thrust::transform(input1, input1 + 6, input2, output, op);

// output is now {-2,  6,  0,  4,  4,  7};
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>second&#95;argument&#95;type</code>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first1`** The beginning of the first input sequence. 
* **`last1`** The end of the first input sequence. 
* **`first2`** The beginning of the second input sequence. 
* **`result`** The beginning of the output sequence. 
* **`op`** The tranformation operation. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code>, but the range <code>[first1, last1)</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise. 
* <code>first2</code> may equal <code>result</code>, but the range <code>[first2, first2 + (last1 - first1))</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
<a href="https://en.cppreference.com/w/cpp/algorithm/transform">https://en.cppreference.com/w/cpp/algorithm/transform</a>

<h3 id="function-transform-if">
Function <code>thrust::transform&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>transform_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>transform&#95;if</code> conditionally applies a unary function to each element of an input sequence and stores the result in the corresponding position in an output sequence if the corresponding position in the input sequence satifies a predicate. Otherwise, the corresponding position in the output sequence is not modified.

Specifically, for each iterator <code>i</code> in the range <code>[first, last)</code> the predicate <code>pred(&#42;i)</code> is evaluated. If this predicate evaluates to <code>true</code>, the result of <code>op(&#42;i)</code> is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range <code>[result, result + (last - first) )</code>. Otherwise, <code>op(&#42;i)</code> is not evaluated and no assignment occurs. The input and output sequences may coincide, resulting in an in-place transformation.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>transform&#95;if</code> to negate the odd-valued elements of a range using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int data[10]    = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

struct is_odd
{
  __host__ __device__
  bool operator()(int x)
  {
    return x % 2;
  }
};

thrust::negate<int> op;
thrust::identity<int> identity;

// negate odd elements
thrust::transform_if(thrust::host, data, data + 10, data, op, is_odd()); // in-place transformation

// data is now {5, 0, 2, 3, 2, 4, 0, 1, 2, 8};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`op`** The tranformation operation. 
* **`pred`** The predicate operation. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
thrust::transform 

<h3 id="function-transform-if">
Function <code>thrust::transform&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>transform_if</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>transform&#95;if</code> conditionally applies a unary function to each element of an input sequence and stores the result in the corresponding position in an output sequence if the corresponding position in the input sequence satifies a predicate. Otherwise, the corresponding position in the output sequence is not modified.

Specifically, for each iterator <code>i</code> in the range <code>[first, last)</code> the predicate <code>pred(&#42;i)</code> is evaluated. If this predicate evaluates to <code>true</code>, the result of <code>op(&#42;i)</code> is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range <code>[result, result + (last - first) )</code>. Otherwise, <code>op(&#42;i)</code> is not evaluated and no assignment occurs. The input and output sequences may coincide, resulting in an in-place transformation.


The following code snippet demonstrates how to use <code>transform&#95;if:</code>



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>

int data[10]    = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

struct is_odd
{
  __host__ __device__
  bool operator()(int x)
  {
    return x % 2;
  }
};

thrust::negate<int> op;
thrust::identity<int> identity;

// negate odd elements
thrust::transform_if(data, data + 10, data, op, is_odd()); // in-place transformation

// data is now {5, 0, 2, 3, 2, 4, 0, 1, 2, 8};
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`op`** The tranformation operation. 
* **`pred`** The predicate operation. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
thrust::transform 

<h3 id="function-transform-if">
Function <code>thrust::transform&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>transform_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>transform&#95;if</code> conditionally applies a unary function to each element of an input sequence and stores the result in the corresponding position in an output sequence if the corresponding position in a stencil sequence satisfies a predicate. Otherwise, the corresponding position in the output sequence is not modified.

Specifically, for each iterator <code>i</code> in the range <code>[first, last)</code> the predicate <code>pred(&#42;s)</code> is evaluated, where <code>s</code> is the corresponding input iterator in the range <code>[stencil, stencil + (last - first) )</code>. If this predicate evaluates to <code>true</code>, the result of <code>op(&#42;i)</code> is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range <code>[result, result + (last - first) )</code>. Otherwise, <code>op(&#42;i)</code> is not evaluated and no assignment occurs. The input and output sequences may coincide, resulting in an in-place transformation.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>transform&#95;if</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int data[10]    = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};
int stencil[10] = { 1, 0, 1,  0, 1, 0, 1,  0, 1, 0};

thrust::negate<int> op;
thrust::identity<int> identity;

thrust::transform_if(thrust::host, data, data + 10, stencil, data, op, identity); // in-place transformation

// data is now {5, 0, -2, -3, -2,  4, 0, -1, -2,  8};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The beginning of the output sequence. 
* **`op`** The tranformation operation. 
* **`pred`** The predicate operation. 

**Preconditions**:
* <code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code> otherwise. 
* <code>stencil</code> may equal <code>result</code>, but the range <code>[stencil, stencil + (last - first))</code> shall not overlap the range <code>[result, result + (last - first))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
thrust::transform 

<h3 id="function-transform-if">
Function <code>thrust::transform&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>transform_if</b>(InputIterator1 first,</span>
<span>&nbsp;&nbsp;InputIterator1 last,</span>
<span>&nbsp;&nbsp;InputIterator2 stencil,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>transform&#95;if</code> conditionally applies a unary function to each element of an input sequence and stores the result in the corresponding position in an output sequence if the corresponding position in a stencil sequence satisfies a predicate. Otherwise, the corresponding position in the output sequence is not modified.

Specifically, for each iterator <code>i</code> in the range <code>[first, last)</code> the predicate <code>pred(&#42;s)</code> is evaluated, where <code>s</code> is the corresponding input iterator in the range <code>[stencil, stencil + (last - first) )</code>. If this predicate evaluates to <code>true</code>, the result of <code>op(&#42;i)</code> is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range <code>[result, result + (last - first) )</code>. Otherwise, <code>op(&#42;i)</code> is not evaluated and no assignment occurs. The input and output sequences may coincide, resulting in an in-place transformation.


The following code snippet demonstrates how to use <code>transform&#95;if:</code>



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>

int data[10]    = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};
int stencil[10] = { 1, 0, 1,  0, 1, 0, 1,  0, 1, 0};

thrust::negate<int> op;
thrust::identity<int> identity;

thrust::transform_if(data, data + 10, stencil, data, op, identity); // in-place transformation

// data is now {5, 0, -2, -3, -2,  4, 0, -1, -2,  8};
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>Predicate's</code><code>argument&#95;type</code>. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The beginning of the output sequence. 
* **`op`** The tranformation operation. 
* **`pred`** The predicate operation. 

**Preconditions**:
* <code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> shall not overlap the range <code>[result, result + (last - first))</code> otherwise. 
* <code>stencil</code> may equal <code>result</code>, but the range <code>[stencil, stencil + (last - first))</code> shall not overlap the range <code>[result, result + (last - first))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
thrust::transform 

<h3 id="function-transform-if">
Function <code>thrust::transform&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>transform_if</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>transform&#95;if</code> conditionally applies a binary function to each pair of elements from two input sequences and stores the result in the corresponding position in an output sequence if the corresponding position in a stencil sequence satifies a predicate. Otherwise, the corresponding position in the output sequence is not modified.

Specifically, for each iterator <code>i</code> in the range <code>[first1, last1)</code> and <code>j = first2 + (i - first1)</code> in the range <code>[first2, first2 + (last1 - first1) )</code>, the predicate <code>pred(&#42;s)</code> is evaluated, where <code>s</code> is the corresponding input iterator in the range <code>[stencil, stencil + (last1 - first1) )</code>. If this predicate evaluates to <code>true</code>, the result of <code>binary&#95;op(&#42;i,&#42;j)</code> is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range <code>[result, result + (last1 - first1) )</code>. Otherwise, <code>binary&#95;op(&#42;i,&#42;j)</code> is not evaluated and no assignment occurs. The input and output sequences may coincide, resulting in an in-place transformation.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>transform&#95;if</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>
...

int input1[6]  = {-5,  0,  2,  3,  2,  4};
int input2[6]  = { 3,  6, -2,  1,  2,  3};
int stencil[8] = { 1,  0,  1,  0,  1,  0};
int output[6];

thrust::plus<int> op;
thrust::identity<int> identity;

thrust::transform_if(thrust::host, input1, input1 + 6, input2, stencil, output, op, identity);

// output is now {-2,  0,  0,  3,  4,  4};
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>second&#95;argument&#95;type</code>. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first1`** The beginning of the first input sequence. 
* **`last1`** The end of the first input sequence. 
* **`first2`** The beginning of the second input sequence. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The beginning of the output sequence. 
* **`binary_op`** The transformation operation. 
* **`pred`** The predicate operation. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code>, but the range <code>[first1, last1)</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise. 
* <code>first2</code> may equal <code>result</code>, but the range <code>[first2, first2 + (last1 - first1))</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise. 
* <code>stencil</code> may equal <code>result</code>, but the range <code>[stencil, stencil + (last1 - first1))</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
thrust::transform 

<h3 id="function-transform-if">
Function <code>thrust::transform&#95;if</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename InputIterator3,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryFunction,</span>
<span>&nbsp;&nbsp;typename Predicate&gt;</span>
<span>ForwardIterator </span><span><b>transform_if</b>(InputIterator1 first1,</span>
<span>&nbsp;&nbsp;InputIterator1 last1,</span>
<span>&nbsp;&nbsp;InputIterator2 first2,</span>
<span>&nbsp;&nbsp;InputIterator3 stencil,</span>
<span>&nbsp;&nbsp;ForwardIterator result,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op,</span>
<span>&nbsp;&nbsp;Predicate pred);</span></code>
This version of <code>transform&#95;if</code> conditionally applies a binary function to each pair of elements from two input sequences and stores the result in the corresponding position in an output sequence if the corresponding position in a stencil sequence satifies a predicate. Otherwise, the corresponding position in the output sequence is not modified.

Specifically, for each iterator <code>i</code> in the range <code>[first1, last1)</code> and <code>j = first2 + (i - first1)</code> in the range <code>[first2, first2 + (last1 - first1) )</code>, the predicate <code>pred(&#42;s)</code> is evaluated, where <code>s</code> is the corresponding input iterator in the range <code>[stencil, stencil + (last1 - first1) )</code>. If this predicate evaluates to <code>true</code>, the result of <code>binary&#95;op(&#42;i,&#42;j)</code> is assigned to <code>&#42;o</code>, where <code>o</code> is the corresponding output iterator in the range <code>[result, result + (last1 - first1) )</code>. Otherwise, <code>binary&#95;op(&#42;i,&#42;j)</code> is not evaluated and no assignment occurs. The input and output sequences may coincide, resulting in an in-place transformation.


The following code snippet demonstrates how to use <code>transform&#95;if:</code>



```cpp
#include <thrust/transform.h>
#include <thrust/functional.h>

int input1[6]  = {-5,  0,  2,  3,  2,  4};
int input2[6]  = { 3,  6, -2,  1,  2,  3};
int stencil[8] = { 1,  0,  1,  0,  1,  0};
int output[6];

thrust::plus<int> op;
thrust::identity<int> identity;

thrust::transform_if(input1, input1 + 6, input2, stencil, output, op, identity);

// output is now {-2,  0,  0,  3,  4,  4};
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code>. 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>BinaryFunction's</code><code>second&#95;argument&#95;type</code>. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`Predicate`** is a model of <a href="https://en.cppreference.com/w/cpp/concepts/predicate">Predicate</a>.

**Function Parameters**:
* **`first1`** The beginning of the first input sequence. 
* **`last1`** The end of the first input sequence. 
* **`first2`** The beginning of the second input sequence. 
* **`stencil`** The beginning of the stencil sequence. 
* **`result`** The beginning of the output sequence. 
* **`binary_op`** The transformation operation. 
* **`pred`** The predicate operation. 

**Preconditions**:
* <code>first1</code> may equal <code>result</code>, but the range <code>[first1, last1)</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise. 
* <code>first2</code> may equal <code>result</code>, but the range <code>[first2, first2 + (last1 - first1))</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise. 
* <code>stencil</code> may equal <code>result</code>, but the range <code>[stencil, stencil + (last1 - first1))</code> shall not overlap the range <code>[result, result + (last1 - first1))</code> otherwise.

**Returns**:
The end of the output sequence.

**See**:
thrust::transform 

<h3 id="function-transform-reduce">
Function <code>thrust::transform&#95;reduce</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename OutputType,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>__host__ __device__ OutputType </span><span><b>transform_reduce</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;OutputType init,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span></code>
<code>transform&#95;reduce</code> fuses the <code>transform</code> and <code>reduce</code> operations. <code>transform&#95;reduce</code> is equivalent to performing a transformation defined by <code>unary&#95;op</code> into a temporary sequence and then performing <code>reduce</code> on the transformed sequence. In most cases, fusing these two operations together is more efficient, since fewer memory reads and writes are required.

<code>transform&#95;reduce</code> performs a reduction on the transformation of the sequence <code>[first, last)</code> according to <code>unary&#95;op</code>. Specifically, <code>unary&#95;op</code> is applied to each element of the sequence and then the result is reduced to a single value with <code>binary&#95;op</code> using the initial value <code>init</code>. Note that the transformation <code>unary&#95;op</code> is not applied to the initial value <code>init</code>. The order of reduction is not specified, so <code>binary&#95;op</code> must be both commutative and associative.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>transform&#95;reduce</code> to compute the maximum value of the absolute value of the elements of a range using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/transform_reduce.h>
#include <thrust/functional.h>
#include <thrust/execution_policy.h>

template<typename T>
struct absolute_value : public unary_function<T,T>
{
  __host__ __device__ T operator()(const T &x) const
  {
    return x < T(0) ? -x : x;
  }
};

...

int data[6] = {-1, 0, -2, -2, 1, -3};
int result = thrust::transform_reduce(thrust::host,
                                      data, data + 6,
                                      absolute_value<int>(),
                                      0,
                                      thrust::maximum<int>());
// result == 3
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a>, and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputType</code>. 
* **`OutputType`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a>, and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputType</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`unary_op`** The function to apply to each element of the input sequence. 
* **`init`** The result is initialized to this value. 
* **`binary_op`** The reduction operation. 

**Returns**:
The result of the transformed reduction.

**See**:
* <code>transform</code>
* <code>reduce</code>

<h3 id="function-transform-reduce">
Function <code>thrust::transform&#95;reduce</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename OutputType,</span>
<span>&nbsp;&nbsp;typename BinaryFunction&gt;</span>
<span>OutputType </span><span><b>transform_reduce</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;OutputType init,</span>
<span>&nbsp;&nbsp;BinaryFunction binary_op);</span></code>
<code>transform&#95;reduce</code> fuses the <code>transform</code> and <code>reduce</code> operations. <code>transform&#95;reduce</code> is equivalent to performing a transformation defined by <code>unary&#95;op</code> into a temporary sequence and then performing <code>reduce</code> on the transformed sequence. In most cases, fusing these two operations together is more efficient, since fewer memory reads and writes are required.

<code>transform&#95;reduce</code> performs a reduction on the transformation of the sequence <code>[first, last)</code> according to <code>unary&#95;op</code>. Specifically, <code>unary&#95;op</code> is applied to each element of the sequence and then the result is reduced to a single value with <code>binary&#95;op</code> using the initial value <code>init</code>. Note that the transformation <code>unary&#95;op</code> is not applied to the initial value <code>init</code>. The order of reduction is not specified, so <code>binary&#95;op</code> must be both commutative and associative.


The following code snippet demonstrates how to use <code>transform&#95;reduce</code> to compute the maximum value of the absolute value of the elements of a range.



```cpp
#include <thrust/transform_reduce.h>
#include <thrust/functional.h>

template<typename T>
struct absolute_value : public unary_function<T,T>
{
  __host__ __device__ T operator()(const T &x) const
  {
    return x < T(0) ? -x : x;
  }
};

...

int data[6] = {-1, 0, -2, -2, 1, -3};
int result = thrust::transform_reduce(data, data + 6,
                                      absolute_value<int>(),
                                      0,
                                      thrust::maximum<int>());
// result == 3
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>UnaryFunction's</code><code>argument&#95;type</code>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a>, and <code>UnaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputType</code>. 
* **`OutputType`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable">Assignable</a>, and is convertible to <code>BinaryFunction's</code><code>first&#95;argument&#95;type</code> and <code>second&#95;argument&#95;type</code>. 
* **`BinaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a>, and <code>BinaryFunction's</code><code>result&#95;type</code> is convertible to <code>OutputType</code>.

**Function Parameters**:
* **`first`** The beginning of the sequence. 
* **`last`** The end of the sequence. 
* **`unary_op`** The function to apply to each element of the input sequence. 
* **`init`** The result is initialized to this value. 
* **`binary_op`** The reduction operation. 

**Returns**:
The result of the transformed reduction.

**See**:
* <code>transform</code>
* <code>reduce</code>

<h3 id="function-transform-inclusive-scan">
Function <code>thrust::transform&#95;inclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>transform_inclusive_scan</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>transform&#95;inclusive&#95;scan</code> fuses the <code>transform</code> and <code>inclusive&#95;scan</code> operations. <code>transform&#95;inclusive&#95;scan</code> is equivalent to performing a tranformation defined by <code>unary&#95;op</code> into a temporary sequence and then performing an <code>inclusive&#95;scan</code> on the tranformed sequence. In most cases, fusing these two operations together is more efficient, since fewer memory reads and writes are required. In <code>transform&#95;inclusive&#95;scan</code>, <code>unary&#95;op(&#42;first)</code> is assigned to <code>&#42;result</code> and the result of <code>binary&#95;op(unary&#95;op(&#42;first), unary&#95;op(&#42;(first + 1)))</code> is assigned to <code>&#42;(result + 1)</code>, and so on. The transform scan operation is permitted to be in-place.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>transform&#95;inclusive&#95;scan</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/transform_scan.h>
#include <thrust/execution_policy.h>
...

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::negate<int> unary_op;
thrust::plus<int> binary_op;

thrust::transform_inclusive_scan(thrust::host, data, data + 6, data, unary_op, binary_op); // in-place scan

// data is now {-1, -1, -3, -5, -6, -9}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>unary&#95;op's</code> input type. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and accepts inputs of <code>InputIterator's</code><code>value&#95;type</code>. <code>UnaryFunction's</code> result_type is convertable to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`unary_op`** The function used to tranform the input sequence. 
* **`binary_op`** The associatve operator used to 'sum' transformed values. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* <code>transform</code>
* <code>inclusive&#95;scan</code>

<h3 id="function-transform-inclusive-scan">
Function <code>thrust::transform&#95;inclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b>transform_inclusive_scan</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>transform&#95;inclusive&#95;scan</code> fuses the <code>transform</code> and <code>inclusive&#95;scan</code> operations. <code>transform&#95;inclusive&#95;scan</code> is equivalent to performing a tranformation defined by <code>unary&#95;op</code> into a temporary sequence and then performing an <code>inclusive&#95;scan</code> on the tranformed sequence. In most cases, fusing these two operations together is more efficient, since fewer memory reads and writes are required. In <code>transform&#95;inclusive&#95;scan</code>, <code>unary&#95;op(&#42;first)</code> is assigned to <code>&#42;result</code> and the result of <code>binary&#95;op(unary&#95;op(&#42;first), unary&#95;op(&#42;(first + 1)))</code> is assigned to <code>&#42;(result + 1)</code>, and so on. The transform scan operation is permitted to be in-place.


The following code snippet demonstrates how to use <code>transform&#95;inclusive&#95;scan</code>



```cpp
#include <thrust/transform_scan.h>

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::negate<int> unary_op;
thrust::plus<int> binary_op;

thrust::transform_inclusive_scan(data, data + 6, data, unary_op, binary_op); // in-place scan

// data is now {-1, -1, -3, -5, -6, -9}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>unary&#95;op's</code> input type. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and accepts inputs of <code>InputIterator's</code><code>value&#95;type</code>. <code>UnaryFunction's</code> result_type is convertable to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`unary_op`** The function used to tranform the input sequence. 
* **`binary_op`** The associatve operator used to 'sum' transformed values. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* <code>transform</code>
* <code>inclusive&#95;scan</code>

<h3 id="function-transform-exclusive-scan">
Function <code>thrust::transform&#95;exclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>transform_exclusive_scan</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>transform&#95;exclusive&#95;scan</code> fuses the <code>transform</code> and <code>exclusive&#95;scan</code> operations. <code>transform&#95;exclusive&#95;scan</code> is equivalent to performing a tranformation defined by <code>unary&#95;op</code> into a temporary sequence and then performing an <code>exclusive&#95;scan</code> on the tranformed sequence. In most cases, fusing these two operations together is more efficient, since fewer memory reads and writes are required. In <code>transform&#95;exclusive&#95;scan</code>, <code>init</code> is assigned to <code>&#42;result</code> and the result of <code>binary&#95;op(init, unary&#95;op(&#42;first))</code> is assigned to <code>&#42;(result + 1)</code>, and so on. The transform scan operation is permitted to be in-place.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>transform&#95;exclusive&#95;scan</code> using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/transform_scan.h>
#include <thrust/execution_policy.h>
...

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::negate<int> unary_op;
thrust::plus<int> binary_op;

thrust::transform_exclusive_scan(thrust::host, data, data + 6, data, unary_op, 4, binary_op); // in-place scan

// data is now {4, 3, 3, 1, -1, -2}
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>unary&#95;op's</code> input type. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and accepts inputs of <code>InputIterator's</code><code>value&#95;type</code>. <code>UnaryFunction's</code> result_type is convertable to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`T`** is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`unary_op`** The function used to tranform the input sequence. 
* **`init`** The initial value of the <code>exclusive&#95;scan</code>
* **`binary_op`** The associatve operator used to 'sum' transformed values. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* <code>transform</code>
* <code>exclusive&#95;scan</code>

<h3 id="function-transform-exclusive-scan">
Function <code>thrust::transform&#95;exclusive&#95;scan</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename UnaryFunction,</span>
<span>&nbsp;&nbsp;typename T,</span>
<span>&nbsp;&nbsp;typename AssociativeOperator&gt;</span>
<span>OutputIterator </span><span><b>transform_exclusive_scan</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;UnaryFunction unary_op,</span>
<span>&nbsp;&nbsp;T init,</span>
<span>&nbsp;&nbsp;AssociativeOperator binary_op);</span></code>
<code>transform&#95;exclusive&#95;scan</code> fuses the <code>transform</code> and <code>exclusive&#95;scan</code> operations. <code>transform&#95;exclusive&#95;scan</code> is equivalent to performing a tranformation defined by <code>unary&#95;op</code> into a temporary sequence and then performing an <code>exclusive&#95;scan</code> on the tranformed sequence. In most cases, fusing these two operations together is more efficient, since fewer memory reads and writes are required. In <code>transform&#95;exclusive&#95;scan</code>, <code>init</code> is assigned to <code>&#42;result</code> and the result of <code>binary&#95;op(init, unary&#95;op(&#42;first))</code> is assigned to <code>&#42;(result + 1)</code>, and so on. The transform scan operation is permitted to be in-place.


The following code snippet demonstrates how to use <code>transform&#95;exclusive&#95;scan</code>



```cpp
#include <thrust/transform_scan.h>

int data[6] = {1, 0, 2, 2, 1, 3};

thrust::negate<int> unary_op;
thrust::plus<int> binary_op;

thrust::transform_exclusive_scan(data, data + 6, data, unary_op, 4, binary_op); // in-place scan

// data is now {4, 3, 3, 1, -1, -2}
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a> and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>unary&#95;op's</code> input type. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a>. 
* **`UnaryFunction`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/unary_function">Unary Function</a> and accepts inputs of <code>InputIterator's</code><code>value&#95;type</code>. <code>UnaryFunction's</code> result_type is convertable to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`T`** is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`AssociativeOperator`** is a model of <a href="https://en.cppreference.com/w/cpp/utility/functional/binary_function">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the input sequence. 
* **`last`** The end of the input sequence. 
* **`result`** The beginning of the output sequence. 
* **`unary_op`** The function used to tranform the input sequence. 
* **`init`** The initial value of the <code>exclusive&#95;scan</code>
* **`binary_op`** The associatve operator used to 'sum' transformed values. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
The end of the output sequence.

**See**:
* <code>transform</code>
* <code>exclusive&#95;scan</code>

<h3 id="function-get">
Function <code>thrust::get</code>
</h3>

<code class="doxybook">
<span>template &lt;int N,</span>
<span>&nbsp;&nbsp;class HT,</span>
<span>&nbsp;&nbsp;class TT&gt;</span>
<span>__host__ __device__ access_traits< typenametuple_element< N, detail::cons< HT, TT > >::type >::non_const_type </span><span><b>get</b>(detail::cons< HT, TT > & t);</span></code>
The <code>get</code> function returns a reference to a <code>tuple</code> element of interest.


The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.



```cpp
#include <thrust/tuple.h>
#include <iostream>
...
thrust::tuple<int, const char *> t(13, "thrust");

std::cout << "The 1st value of t is " << thrust::get<0>(t) << std::endl;
```

**Template Parameters**:
**`N`**: The index of the element of interest.

**Function Parameters**:
**`t`**: A reference to a <code>tuple</code> of interest. 

**Returns**:
A reference to <code>t's</code><code>N</code>th element.

**See**:
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>
* <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>

<h3 id="function-get">
Function <code>thrust::get</code>
</h3>

<code class="doxybook">
<span>template &lt;int N,</span>
<span>&nbsp;&nbsp;class HT,</span>
<span>&nbsp;&nbsp;class TT&gt;</span>
<span>__host__ __device__ access_traits< typenametuple_element< N, detail::cons< HT, TT > >::type >::const_type </span><span><b>get</b>(const detail::cons< HT, TT > & t);</span></code>
The <code>get</code> function returns a <code>const</code> reference to a <code>tuple</code> element of interest.


The following code snippet demonstrates how to use <code>get</code> to print the value of a <code>tuple</code> element.



```cpp
#include <thrust/tuple.h>
#include <iostream>
...
thrust::tuple<int, const char *> t(13, "thrust");

std::cout << "The 1st value of t is " << thrust::get<0>(t) << std::endl;
```

**Template Parameters**:
**`N`**: The index of the element of interest.

**Function Parameters**:
**`t`**: A reference to a <code>tuple</code> of interest. 

**Returns**:
A <code>const</code> reference to <code>t's</code><code>N</code>th element.

**See**:
* <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">pair</a>
* <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>

<h3 id="function-make-tuple">
Function <code>thrust::make&#95;tuple</code>
</h3>

<code class="doxybook">
<span>template &lt;class T0&gt;</span>
<span>__host__ __device__ detail::make_tuple_mapper< T0 >::type </span><span><b>make_tuple</b>(const T0 & t0);</span></code>
This version of <code>make&#95;tuple</code> creates a new <code>tuple</code> object from a single object.

**Function Parameters**:
**`t0`**: The object to copy from. 

**Returns**:
A <code>tuple</code> object with a single member which is a copy of <code>t0</code>. 

<h3 id="function-make-tuple">
Function <code>thrust::make&#95;tuple</code>
</h3>

<code class="doxybook">
<span>template &lt;class T0,</span>
<span>&nbsp;&nbsp;class T1&gt;</span>
<span>__host__ __device__ detail::make_tuple_mapper< T0, T1 >::type </span><span><b>make_tuple</b>(const T0 & t0,</span>
<span>&nbsp;&nbsp;const T1 & t1);</span></code>
This version of <code>make&#95;tuple</code> creates a new <code>tuple</code> object from two objects.

**Note**:
<code>make&#95;tuple</code> has ten variants, the rest of which are omitted here for brevity. 

**Function Parameters**:
* **`t0`** The first object to copy from. 
* **`t1`** The second object to copy from. 

**Returns**:
A <code>tuple</code> object with two members which are copies of <code>t0</code> and <code>t1</code>.

<h3 id="function-tie">
Function <code>thrust::tie</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>< T0 & > </span><span><b>tie</b>(T0 & t0);</span></code>
This version of <code>tie</code> creates a new <code>tuple</code> whose single element is a reference which refers to this function's argument.

**Function Parameters**:
**`t0`**: The object to reference. 

**Returns**:
A <code>tuple</code> object with one member which is a reference to <code>t0</code>. 

<h3 id="function-tie">
Function <code>thrust::tie</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>< T0 &, T1 & > </span><span><b>tie</b>(T0 & t0,</span>
<span>&nbsp;&nbsp;T1 & t1);</span></code>
This version of <code>tie</code> creates a new <code>tuple</code> of references object which refers to this function's arguments.

**Note**:
<code>tie</code> has ten variants, the rest of which are omitted here for brevity. 

**Function Parameters**:
* **`t0`** The first object to reference. 
* **`t1`** The second object to reference. 

**Returns**:
A <code>tuple</code> object with two members which are references to <code>t0</code> and <code>t1</code>.

<h3 id="function-swap">
Function <code>thrust::swap</code>
</h3>

<code class="doxybook">
<span>template &lt;typename T0,</span>
<span>&nbsp;&nbsp;typename T1,</span>
<span>&nbsp;&nbsp;typename T2,</span>
<span>&nbsp;&nbsp;typename T3,</span>
<span>&nbsp;&nbsp;typename T4,</span>
<span>&nbsp;&nbsp;typename T5,</span>
<span>&nbsp;&nbsp;typename T6,</span>
<span>&nbsp;&nbsp;typename T7,</span>
<span>&nbsp;&nbsp;typename T8,</span>
<span>&nbsp;&nbsp;typename T9,</span>
<span>&nbsp;&nbsp;typename U0,</span>
<span>&nbsp;&nbsp;typename U1,</span>
<span>&nbsp;&nbsp;typename U2,</span>
<span>&nbsp;&nbsp;typename U3,</span>
<span>&nbsp;&nbsp;typename U4,</span>
<span>&nbsp;&nbsp;typename U5,</span>
<span>&nbsp;&nbsp;typename U6,</span>
<span>&nbsp;&nbsp;typename U7,</span>
<span>&nbsp;&nbsp;typename U8,</span>
<span>&nbsp;&nbsp;typename U9&gt;</span>
<span>__host__ __device__ void </span><span><b>swap</b>(<a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9 > & x,</span>
<span>&nbsp;&nbsp;<a href="{{ site.baseurl }}/api/classes/classthrust_1_1tuple.html">tuple</a>< U0, U1, U2, U3, U4, U5, U6, U7, U8, U9 > & y);</span></code>
<code>swap</code> swaps the contents of two <code>tuple</code>s.

**Function Parameters**:
* **`x`** The first <code>tuple</code> to swap. 
* **`y`** The second <code>tuple</code> to swap. 

<h3 id="function-uninitialized-copy">
Function <code>thrust::uninitialized&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>uninitialized_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;ForwardIterator result);</span></code>
In <code>thrust</code>, the function <code>thrust::device&#95;new</code> allocates memory for an object and then creates an object at that location by calling a constructor. Occasionally, however, it is useful to separate those two operations. If each iterator in the range <code>[result, result + (last - first))</code> points to uninitialized memory, then <code>uninitialized&#95;copy</code> creates a copy of <code>[first, last)</code> in that range. That is, for each iterator <code>i</code> in the input, <code>uninitialized&#95;copy</code> creates a copy of <code>&#42;i</code> in the location pointed to by the corresponding iterator in the output range by <code>ForwardIterator's</code><code>value&#95;type's</code> copy constructor with *i as its argument.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>uninitialized&#95;copy</code> to initialize a range of uninitialized memory using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/uninitialized_copy.h>
#include <thrust/device_malloc.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>

struct Int
{
  __host__ __device__
  Int(int x) : val(x) {}
  int val;
};  
...
const int N = 137;

Int val(46);
thrust::device_vector<Int> input(N, val);
thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
thrust::uninitialized_copy(thrust::device, input.begin(), input.end(), array);

// Int x = array[i];
// x.val == 46 for all 0 <= i < N
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> has a constructor that takes a single argument whose type is <code>InputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element of the input range to copy from. 
* **`last`** The last element of the input range to copy from. 
* **`result`** The first element of the output range to copy to. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
An iterator pointing to the last element of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_copy">https://en.cppreference.com/w/cpp/memory/uninitialized_copy</a>
* <code>copy</code>
* <code>uninitialized&#95;fill</code>
* <code>device&#95;new</code>
* <code>device&#95;malloc</code>

<h3 id="function-uninitialized-copy">
Function <code>thrust::uninitialized&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b>uninitialized_copy</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;ForwardIterator result);</span></code>
In <code>thrust</code>, the function <code>thrust::device&#95;new</code> allocates memory for an object and then creates an object at that location by calling a constructor. Occasionally, however, it is useful to separate those two operations. If each iterator in the range <code>[result, result + (last - first))</code> points to uninitialized memory, then <code>uninitialized&#95;copy</code> creates a copy of <code>[first, last)</code> in that range. That is, for each iterator <code>i</code> in the input, <code>uninitialized&#95;copy</code> creates a copy of <code>&#42;i</code> in the location pointed to by the corresponding iterator in the output range by <code>ForwardIterator's</code><code>value&#95;type's</code> copy constructor with *i as its argument.


The following code snippet demonstrates how to use <code>uninitialized&#95;copy</code> to initialize a range of uninitialized memory.



```cpp
#include <thrust/uninitialized_copy.h>
#include <thrust/device_malloc.h>
#include <thrust/device_vector.h>

struct Int
{
  __host__ __device__
  Int(int x) : val(x) {}
  int val;
};  
...
const int N = 137;

Int val(46);
thrust::device_vector<Int> input(N, val);
thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
thrust::uninitialized_copy(input.begin(), input.end(), array);

// Int x = array[i];
// x.val == 46 for all 0 <= i < N
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> has a constructor that takes a single argument whose type is <code>InputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The first element of the input range to copy from. 
* **`last`** The last element of the input range to copy from. 
* **`result`** The first element of the output range to copy to. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap otherwise.

**Returns**:
An iterator pointing to the last element of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_copy">https://en.cppreference.com/w/cpp/memory/uninitialized_copy</a>
* <code>copy</code>
* <code>uninitialized&#95;fill</code>
* <code>device&#95;new</code>
* <code>device&#95;malloc</code>

<h3 id="function-uninitialized-copy-n">
Function <code>thrust::uninitialized&#95;copy&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>uninitialized_copy_n</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;ForwardIterator result);</span></code>
In <code>thrust</code>, the function <code>thrust::device&#95;new</code> allocates memory for an object and then creates an object at that location by calling a constructor. Occasionally, however, it is useful to separate those two operations. If each iterator in the range <code>[result, result + n)</code> points to uninitialized memory, then <code>uninitialized&#95;copy&#95;n</code> creates a copy of <code>[first, first + n)</code> in that range. That is, for each iterator <code>i</code> in the input, <code>uninitialized&#95;copy&#95;n</code> creates a copy of <code>&#42;i</code> in the location pointed to by the corresponding iterator in the output range by <code>InputIterator's</code><code>value&#95;type's</code> copy constructor with *i as its argument.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>uninitialized&#95;copy</code> to initialize a range of uninitialized memory using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/uninitialized_copy.h>
#include <thrust/device_malloc.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>

struct Int
{
  __host__ __device__
  Int(int x) : val(x) {}
  int val;
};  
...
const int N = 137;

Int val(46);
thrust::device_vector<Int> input(N, val);
thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
thrust::uninitialized_copy_n(thrust::device, input.begin(), N, array);

// Int x = array[i];
// x.val == 46 for all 0 <= i < N
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`Size`** is an integral type. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> has a constructor that takes a single argument whose type is <code>InputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element of the input range to copy from. 
* **`n`** The number of elements to copy. 
* **`result`** The first element of the output range to copy to. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, first + n)</code> and the range <code>[result, result + n)</code> shall not overlap otherwise.

**Returns**:
An iterator pointing to the last element of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_copy">https://en.cppreference.com/w/cpp/memory/uninitialized_copy</a>
* <code>uninitialized&#95;copy</code>
* <code>copy</code>
* <code>uninitialized&#95;fill</code>
* <code>device&#95;new</code>
* <code>device&#95;malloc</code>

<h3 id="function-uninitialized-copy-n">
Function <code>thrust::uninitialized&#95;copy&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b>uninitialized_copy_n</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;ForwardIterator result);</span></code>
In <code>thrust</code>, the function <code>thrust::device&#95;new</code> allocates memory for an object and then creates an object at that location by calling a constructor. Occasionally, however, it is useful to separate those two operations. If each iterator in the range <code>[result, result + n)</code> points to uninitialized memory, then <code>uninitialized&#95;copy&#95;n</code> creates a copy of <code>[first, first + n)</code> in that range. That is, for each iterator <code>i</code> in the input, <code>uninitialized&#95;copy&#95;n</code> creates a copy of <code>&#42;i</code> in the location pointed to by the corresponding iterator in the output range by <code>InputIterator's</code><code>value&#95;type's</code> copy constructor with *i as its argument.


The following code snippet demonstrates how to use <code>uninitialized&#95;copy</code> to initialize a range of uninitialized memory.



```cpp
#include <thrust/uninitialized_copy.h>
#include <thrust/device_malloc.h>
#include <thrust/device_vector.h>

struct Int
{
  __host__ __device__
  Int(int x) : val(x) {}
  int val;
};  
...
const int N = 137;

Int val(46);
thrust::device_vector<Int> input(N, val);
thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
thrust::uninitialized_copy_n(input.begin(), N, array);

// Int x = array[i];
// x.val == 46 for all 0 <= i < N
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>. 
* **`Size`** is an integral type. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> has a constructor that takes a single argument whose type is <code>InputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The first element of the input range to copy from. 
* **`n`** The number of elements to copy. 
* **`result`** The first element of the output range to copy to. 

**Preconditions**:
<code>first</code> may equal <code>result</code>, but the range <code>[first, first + n)</code> and the range <code>[result, result + n)</code> shall not overlap otherwise.

**Returns**:
An iterator pointing to the last element of the output range.

**See**:
* <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_copy">https://en.cppreference.com/w/cpp/memory/uninitialized_copy</a>
* <code>uninitialized&#95;copy</code>
* <code>copy</code>
* <code>uninitialized&#95;fill</code>
* <code>device&#95;new</code>
* <code>device&#95;malloc</code>

<h3 id="function-uninitialized-fill">
Function <code>thrust::uninitialized&#95;fill</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ void </span><span><b>uninitialized_fill</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & x);</span></code>
In <code>thrust</code>, the function <code>thrust::device&#95;new</code> allocates memory for an object and then creates an object at that location by calling a constructor. Occasionally, however, it is useful to separate those two operations. If each iterator in the range <code>[first, last)</code> points to uninitialized memory, then <code>uninitialized&#95;fill</code> creates copies of <code>x</code> in that range. That is, for each iterator <code>i</code> in the range <code>[first, last)</code>, <code>uninitialized&#95;fill</code> creates a copy of <code>x</code> in the location pointed to <code>i</code> by calling <code>ForwardIterator's</code><code>value&#95;type's</code> copy constructor.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>uninitialized&#95;fill</code> to initialize a range of uninitialized memory using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/uninitialized_fill.h>
#include <thrust/device_malloc.h>
#include <thrust/execution_policy.h>

struct Int
{
  __host__ __device__
  Int(int x) : val(x) {}
  int val;
};  
...
const int N = 137;

Int val(46);
thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
thrust::uninitialized_fill(thrust::device, array, array + N, val);

// Int x = array[i];
// x.val == 46 for all 0 <= i < N
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> has a constructor that takes a single argument of type <code>T</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element of the range of interest. 
* **`last`** The last element of the range of interest. 
* **`x`** The value to use as the exemplar of the copy constructor.

**See**:
* <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_fill">https://en.cppreference.com/w/cpp/memory/uninitialized_fill</a>
* <code>uninitialized&#95;fill&#95;n</code>
* <code>fill</code>
* <code>uninitialized&#95;copy</code>
* <code>device&#95;new</code>
* <code>device&#95;malloc</code>

<h3 id="function-uninitialized-fill">
Function <code>thrust::uninitialized&#95;fill</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>void </span><span><b>uninitialized_fill</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;const T & x);</span></code>
In <code>thrust</code>, the function <code>thrust::device&#95;new</code> allocates memory for an object and then creates an object at that location by calling a constructor. Occasionally, however, it is useful to separate those two operations. If each iterator in the range <code>[first, last)</code> points to uninitialized memory, then <code>uninitialized&#95;fill</code> creates copies of <code>x</code> in that range. That is, for each iterator <code>i</code> in the range <code>[first, last)</code>, <code>uninitialized&#95;fill</code> creates a copy of <code>x</code> in the location pointed to <code>i</code> by calling <code>ForwardIterator's</code><code>value&#95;type's</code> copy constructor.


The following code snippet demonstrates how to use <code>uninitialized&#95;fill</code> to initialize a range of uninitialized memory.



```cpp
#include <thrust/uninitialized_fill.h>
#include <thrust/device_malloc.h>

struct Int
{
  __host__ __device__
  Int(int x) : val(x) {}
  int val;
};  
...
const int N = 137;

Int val(46);
thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
thrust::uninitialized_fill(array, array + N, val);

// Int x = array[i];
// x.val == 46 for all 0 <= i < N
```

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> has a constructor that takes a single argument of type <code>T</code>.

**Function Parameters**:
* **`first`** The first element of the range of interest. 
* **`last`** The last element of the range of interest. 
* **`x`** The value to use as the exemplar of the copy constructor.

**See**:
* <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_fill">https://en.cppreference.com/w/cpp/memory/uninitialized_fill</a>
* <code>uninitialized&#95;fill&#95;n</code>
* <code>fill</code>
* <code>uninitialized&#95;copy</code>
* <code>device&#95;new</code>
* <code>device&#95;malloc</code>

<h3 id="function-uninitialized-fill-n">
Function <code>thrust::uninitialized&#95;fill&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>uninitialized_fill_n</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;const T & x);</span></code>
In <code>thrust</code>, the function <code>thrust::device&#95;new</code> allocates memory for an object and then creates an object at that location by calling a constructor. Occasionally, however, it is useful to separate those two operations. If each iterator in the range <code>[first, first+n)</code> points to uninitialized memory, then <code>uninitialized&#95;fill</code> creates copies of <code>x</code> in that range. That is, for each iterator <code>i</code> in the range <code>[first, first+n)</code>, <code>uninitialized&#95;fill</code> creates a copy of <code>x</code> in the location pointed to <code>i</code> by calling <code>ForwardIterator's</code><code>value&#95;type's</code> copy constructor.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>uninitialized&#95;fill</code> to initialize a range of uninitialized memory using the <code>thrust::device</code> execution policy for parallelization:



```cpp
#include <thrust/uninitialized_fill.h>
#include <thrust/device_malloc.h>
#include <thrust/execution_policy.h>

struct Int
{
  __host__ __device__
  Int(int x) : val(x) {}
  int val;
};  
...
const int N = 137;

Int val(46);
thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
thrust::uninitialized_fill_n(thrust::device, array, N, val);

// Int x = array[i];
// x.val == 46 for all 0 <= i < N
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> has a constructor that takes a single argument of type <code>T</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The first element of the range of interest. 
* **`n`** The size of the range of interest. 
* **`x`** The value to use as the exemplar of the copy constructor. 

**Returns**:
<code>first+n</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_fill">https://en.cppreference.com/w/cpp/memory/uninitialized_fill</a>
* <code>uninitialized&#95;fill</code>
* <code>fill</code>
* <code>uninitialized&#95;copy&#95;n</code>
* <code>device&#95;new</code>
* <code>device&#95;malloc</code>

<h3 id="function-uninitialized-fill-n">
Function <code>thrust::uninitialized&#95;fill&#95;n</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename Size,</span>
<span>&nbsp;&nbsp;typename T&gt;</span>
<span>ForwardIterator </span><span><b>uninitialized_fill_n</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;Size n,</span>
<span>&nbsp;&nbsp;const T & x);</span></code>
In <code>thrust</code>, the function <code>thrust::device&#95;new</code> allocates memory for an object and then creates an object at that location by calling a constructor. Occasionally, however, it is useful to separate those two operations. If each iterator in the range <code>[first, first+n)</code> points to uninitialized memory, then <code>uninitialized&#95;fill</code> creates copies of <code>x</code> in that range. That is, for each iterator <code>i</code> in the range <code>[first, first+n)</code>, <code>uninitialized&#95;fill</code> creates a copy of <code>x</code> in the location pointed to <code>i</code> by calling <code>ForwardIterator's</code><code>value&#95;type's</code> copy constructor.


The following code snippet demonstrates how to use <code>uninitialized&#95;fill</code> to initialize a range of uninitialized memory.



```cpp
#include <thrust/uninitialized_fill.h>
#include <thrust/device_malloc.h>

struct Int
{
  __host__ __device__
  Int(int x) : val(x) {}
  int val;
};  
...
const int N = 137;

Int val(46);
thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
thrust::uninitialized_fill_n(array, N, val);

// Int x = array[i];
// x.val == 46 for all 0 <= i < N
```

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> has a constructor that takes a single argument of type <code>T</code>.

**Function Parameters**:
* **`first`** The first element of the range of interest. 
* **`n`** The size of the range of interest. 
* **`x`** The value to use as the exemplar of the copy constructor. 

**Returns**:
<code>first+n</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/memory/uninitialized_fill">https://en.cppreference.com/w/cpp/memory/uninitialized_fill</a>
* <code>uninitialized&#95;fill</code>
* <code>fill</code>
* <code>uninitialized&#95;copy&#95;n</code>
* <code>device&#95;new</code>
* <code>device&#95;malloc</code>

<h3 id="function-unique">
Function <code>thrust::unique</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>unique</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
For each group of consecutive elements in the range <code>[first, last)</code> with the same value, <code>unique</code> removes all but the first element of the group. The return value is an iterator <code>new&#95;last</code> such that no two consecutive elements in the range <code>[first, new&#95;last)</code> are equal. The iterators in the range <code>[new&#95;last, last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>unique</code> is stable, meaning that the relative order of elements that are not removed is unchanged.

This version of <code>unique</code> uses <code>operator==</code> to test for equality.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique</code> to compact a sequence of numbers to remove consecutive duplicates using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int *new_end = thrust::unique(thrust::host, A, A + N);
// The first four values of A are now {1, 3, 2, 1}
// Values beyond new_end are unspecified.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 

**Returns**:
The end of the unique range <code>[first, new&#95;last)</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/unique">https://en.cppreference.com/w/cpp/algorithm/unique</a>
* unique_copy 

<h3 id="function-unique">
Function <code>thrust::unique</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator&gt;</span>
<span>ForwardIterator </span><span><b>unique</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
For each group of consecutive elements in the range <code>[first, last)</code> with the same value, <code>unique</code> removes all but the first element of the group. The return value is an iterator <code>new&#95;last</code> such that no two consecutive elements in the range <code>[first, new&#95;last)</code> are equal. The iterators in the range <code>[new&#95;last, last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>unique</code> is stable, meaning that the relative order of elements that are not removed is unchanged.

This version of <code>unique</code> uses <code>operator==</code> to test for equality.


The following code snippet demonstrates how to use <code>unique</code> to compact a sequence of numbers to remove consecutive duplicates.



```cpp
#include <thrust/unique.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int *new_end = thrust::unique(A, A + N);
// The first four values of A are now {1, 3, 2, 1}
// Values beyond new_end are unspecified.
```

**Template Parameters**:
**`ForwardIterator`**: is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>.

**Function Parameters**:
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 

**Returns**:
The end of the unique range <code>[first, new&#95;last)</code>.

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/unique">https://en.cppreference.com/w/cpp/algorithm/unique</a>
* unique_copy 

<h3 id="function-unique">
Function <code>thrust::unique</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ ForwardIterator </span><span><b>unique</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
For each group of consecutive elements in the range <code>[first, last)</code> with the same value, <code>unique</code> removes all but the first element of the group. The return value is an iterator <code>new&#95;last</code> such that no two consecutive elements in the range <code>[first, new&#95;last)</code> are equal. The iterators in the range <code>[new&#95;last, last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>unique</code> is stable, meaning that the relative order of elements that are not removed is unchanged.

This version of <code>unique</code> uses the function object <code>binary&#95;pred</code> to test for equality.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique</code> to compact a sequence of numbers to remove consecutive duplicates using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int *new_end = thrust::unique(thrust::host, A, A + N, thrust::equal_to<int>());
// The first four values of A are now {1, 3, 2, 1}
// Values beyond new_end are unspecified.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>first&#95;argument&#95;type</code> and to <code>BinaryPredicate's</code><code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Returns**:
The end of the unique range <code>[first, new&#95;last)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/unique">https://en.cppreference.com/w/cpp/algorithm/unique</a>
* unique_copy 

<h3 id="function-unique">
Function <code>thrust::unique</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>ForwardIterator </span><span><b>unique</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
For each group of consecutive elements in the range <code>[first, last)</code> with the same value, <code>unique</code> removes all but the first element of the group. The return value is an iterator <code>new&#95;last</code> such that no two consecutive elements in the range <code>[first, new&#95;last)</code> are equal. The iterators in the range <code>[new&#95;last, last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>unique</code> is stable, meaning that the relative order of elements that are not removed is unchanged.

This version of <code>unique</code> uses the function object <code>binary&#95;pred</code> to test for equality.


The following code snippet demonstrates how to use <code>unique</code> to compact a sequence of numbers to remove consecutive duplicates.



```cpp
#include <thrust/unique.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int *new_end = thrust::unique(A, A + N, thrust::equal_to<int>());
// The first four values of A are now {1, 3, 2, 1}
// Values beyond new_end are unspecified.
```

**Template Parameters**:
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>first&#95;argument&#95;type</code> and to <code>BinaryPredicate's</code><code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Returns**:
The end of the unique range <code>[first, new&#95;last)</code>

**See**:
* <a href="https://en.cppreference.com/w/cpp/algorithm/unique">https://en.cppreference.com/w/cpp/algorithm/unique</a>
* unique_copy 

<h3 id="function-unique-copy">
Function <code>thrust::unique&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>unique_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>unique&#95;copy</code> copies elements from the range <code>[first, last)</code> to a range beginning with <code>result</code>, except that in a consecutive group of duplicate elements only the first one is copied. The return value is the end of the range to which the elements are copied.

The reason there are two different versions of unique_copy is that there are two different definitions of what it means for a consecutive group of elements to be duplicates. In the first version, the test is simple equality: the elements in a range <code>[f, l)</code> are duplicates if, for every iterator <code>i</code> in the range, either <code>i == f</code> or else <code>&#42;i == &#42;(i-1)</code>. In the second, the test is an arbitrary <code>BinaryPredicate</code><code>binary&#95;pred:</code> the elements in <code>[f, l)</code> are duplicates if, for every iterator <code>i</code> in the range, either <code>i == f</code> or else <code>binary&#95;pred(&#42;i, &#42;(i-1))</code> is <code>true</code>.

This version of <code>unique&#95;copy</code> uses <code>operator==</code> to test for equality.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique&#95;copy</code> to compact a sequence of numbers to remove consecutive duplicates using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int B[N];
int *result_end = thrust::unique_copy(thrust::host, A, A + N, B);
// The first four values of B are now {1, 3, 2, 1} and (result_end - B) is 4
// Values beyond result_end are unspecified
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
The range <code>[first,last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap.

**Returns**:
The end of the unique range <code>[result, result&#95;end)</code>.

**See**:
* unique 
* <a href="https://en.cppreference.com/w/cpp/algorithm/unique_copy">https://en.cppreference.com/w/cpp/algorithm/unique_copy</a>

<h3 id="function-unique-copy">
Function <code>thrust::unique&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator&gt;</span>
<span>OutputIterator </span><span><b>unique_copy</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result);</span></code>
<code>unique&#95;copy</code> copies elements from the range <code>[first, last)</code> to a range beginning with <code>result</code>, except that in a consecutive group of duplicate elements only the first one is copied. The return value is the end of the range to which the elements are copied.

The reason there are two different versions of unique_copy is that there are two different definitions of what it means for a consecutive group of elements to be duplicates. In the first version, the test is simple equality: the elements in a range <code>[f, l)</code> are duplicates if, for every iterator <code>i</code> in the range, either <code>i == f</code> or else <code>&#42;i == &#42;(i-1)</code>. In the second, the test is an arbitrary <code>BinaryPredicate</code><code>binary&#95;pred:</code> the elements in <code>[f, l)</code> are duplicates if, for every iterator <code>i</code> in the range, either <code>i == f</code> or else <code>binary&#95;pred(&#42;i, &#42;(i-1))</code> is <code>true</code>.

This version of <code>unique&#95;copy</code> uses <code>operator==</code> to test for equality.


The following code snippet demonstrates how to use <code>unique&#95;copy</code> to compact a sequence of numbers to remove consecutive duplicates.



```cpp
#include <thrust/unique.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int B[N];
int *result_end = thrust::unique_copy(A, A + N, B);
// The first four values of B are now {1, 3, 2, 1} and (result_end - B) is 4
// Values beyond result_end are unspecified
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`result`** The beginning of the output range. 

**Preconditions**:
The range <code>[first,last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap.

**Returns**:
The end of the unique range <code>[result, result&#95;end)</code>.

**See**:
* unique 
* <a href="https://en.cppreference.com/w/cpp/algorithm/unique_copy">https://en.cppreference.com/w/cpp/algorithm/unique_copy</a>

<h3 id="function-unique-copy">
Function <code>thrust::unique&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ OutputIterator </span><span><b>unique_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>unique&#95;copy</code> copies elements from the range <code>[first, last)</code> to a range beginning with <code>result</code>, except that in a consecutive group of duplicate elements only the first one is copied. The return value is the end of the range to which the elements are copied.

This version of <code>unique&#95;copy</code> uses the function object <code>binary&#95;pred</code> to test for equality.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique&#95;copy</code> to compact a sequence of numbers to remove consecutive duplicates using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int B[N];
int *result_end = thrust::unique_copy(thrust::host, A, A + N, B, thrust::equal_to<int>());
// The first four values of B are now {1, 3, 2, 1} and (result_end - B) is 4
// Values beyond result_end are unspecified.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`result`** The beginning of the output range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Preconditions**:
The range <code>[first,last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap.

**Returns**:
The end of the unique range <code>[result, result&#95;end)</code>.

**See**:
* unique 
* <a href="https://en.cppreference.com/w/cpp/algorithm/unique_copy">https://en.cppreference.com/w/cpp/algorithm/unique_copy</a>

<h3 id="function-unique-copy">
Function <code>thrust::unique&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator,</span>
<span>&nbsp;&nbsp;typename OutputIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>OutputIterator </span><span><b>unique_copy</b>(InputIterator first,</span>
<span>&nbsp;&nbsp;InputIterator last,</span>
<span>&nbsp;&nbsp;OutputIterator result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>unique&#95;copy</code> copies elements from the range <code>[first, last)</code> to a range beginning with <code>result</code>, except that in a consecutive group of duplicate elements only the first one is copied. The return value is the end of the range to which the elements are copied.

This version of <code>unique&#95;copy</code> uses the function object <code>binary&#95;pred</code> to test for equality.


The following code snippet demonstrates how to use <code>unique&#95;copy</code> to compact a sequence of numbers to remove consecutive duplicates.



```cpp
#include <thrust/unique.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int B[N];
int *result_end = thrust::unique_copy(A, A + N, B, thrust::equal_to<int>());
// The first four values of B are now {1, 3, 2, 1} and (result_end - B) is 4
// Values beyond result_end are unspecified.
```

**Template Parameters**:
* **`InputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, and <code>InputIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`OutputIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`result`** The beginning of the output range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Preconditions**:
The range <code>[first,last)</code> and the range <code>[result, result + (last - first))</code> shall not overlap.

**Returns**:
The end of the unique range <code>[result, result&#95;end)</code>.

**See**:
* unique 
* <a href="https://en.cppreference.com/w/cpp/algorithm/unique_copy">https://en.cppreference.com/w/cpp/algorithm/unique_copy</a>

<h3 id="function-unique-by-key">
Function <code>thrust::unique&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator1, ForwardIterator2 > </span><span><b>unique_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_first,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_last,</span>
<span>&nbsp;&nbsp;ForwardIterator2 values_first);</span></code>
<code>unique&#95;by&#95;key</code> is a generalization of <code>unique</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>unique&#95;by&#95;key</code> removes all but the first element of the group. Similarly, the corresponding values in the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> are also removed.

The return value is a <code>pair</code> of iterators <code>(new&#95;keys&#95;last,new&#95;values&#95;last)</code> such that no two consecutive elements in the range <code>[keys&#95;first, new&#95;keys&#95;last)</code> are equal.

This version of <code>unique&#95;by&#95;key</code> uses <code>operator==</code> to test for equality and <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique&#95;by&#95;key</code> to compact a sequence of key/value pairs to remove consecutive duplicates using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // values

thrust::pair<int*,int*> new_end;
new_end = thrust::unique_by_key(thrust::host, A, A + N, B);

// The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.
// The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator1</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`ForwardIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator2</code> is mutable.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the key range. 
* **`keys_last`** The end of the key range. 
* **`values_first`** The beginning of the value range. 

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last)</code> and the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> shall not overlap.

**Returns**:
A pair of iterators at end of the ranges <code>[key&#95;first, keys&#95;new&#95;last)</code> and <code>[values&#95;first, values&#95;new&#95;last)</code>.

**See**:
* unique 
* unique_by_key_copy 
* reduce_by_key 

<h3 id="function-unique-by-key">
Function <code>thrust::unique&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator1, ForwardIterator2 > </span><span><b>unique_by_key</b>(ForwardIterator1 keys_first,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_last,</span>
<span>&nbsp;&nbsp;ForwardIterator2 values_first);</span></code>
<code>unique&#95;by&#95;key</code> is a generalization of <code>unique</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>unique&#95;by&#95;key</code> removes all but the first element of the group. Similarly, the corresponding values in the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> are also removed.

The return value is a <code>pair</code> of iterators <code>(new&#95;keys&#95;last,new&#95;values&#95;last)</code> such that no two consecutive elements in the range <code>[keys&#95;first, new&#95;keys&#95;last)</code> are equal.

This version of <code>unique&#95;by&#95;key</code> uses <code>operator==</code> to test for equality and <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.


The following code snippet demonstrates how to use <code>unique&#95;by&#95;key</code> to compact a sequence of key/value pairs to remove consecutive duplicates.



```cpp
#include <thrust/unique.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // values

thrust::pair<int*,int*> new_end;
new_end = thrust::unique_by_key(A, A + N, B);

// The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.
// The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.
```

**Template Parameters**:
* **`ForwardIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator1</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`ForwardIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator2</code> is mutable.

**Function Parameters**:
* **`keys_first`** The beginning of the key range. 
* **`keys_last`** The end of the key range. 
* **`values_first`** The beginning of the value range. 

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last)</code> and the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> shall not overlap.

**Returns**:
A pair of iterators at end of the ranges <code>[key&#95;first, keys&#95;new&#95;last)</code> and <code>[values&#95;first, values&#95;new&#95;last)</code>.

**See**:
* unique 
* unique_by_key_copy 
* reduce_by_key 

<h3 id="function-unique-by-key">
Function <code>thrust::unique&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator1, ForwardIterator2 > </span><span><b>unique_by_key</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_first,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_last,</span>
<span>&nbsp;&nbsp;ForwardIterator2 values_first,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>unique&#95;by&#95;key</code> is a generalization of <code>unique</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>unique&#95;by&#95;key</code> removes all but the first element of the group. Similarly, the corresponding values in the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> are also removed.

This version of <code>unique&#95;by&#95;key</code> uses the function object <code>binary&#95;pred</code> to test for equality and <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique&#95;by&#95;key</code> to compact a sequence of key/value pairs to remove consecutive duplicates using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // values

thrust::pair<int*,int*> new_end;
thrust::equal_to<int> binary_pred;
new_end = thrust::unique_by_key(thrust::host, keys, keys + N, values, binary_pred);

// The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.
// The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator1</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`ForwardIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator2</code> is mutable. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the key range. 
* **`keys_last`** The end of the key range. 
* **`values_first`** The beginning of the value range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last)</code> and the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> shall not overlap.

**Returns**:
The end of the unique range <code>[first, new&#95;last)</code>.

**See**:
* unique 
* unique_by_key_copy 
* reduce_by_key 

<h3 id="function-unique-by-key">
Function <code>thrust::unique&#95;by&#95;key</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator1,</span>
<span>&nbsp;&nbsp;typename ForwardIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< ForwardIterator1, ForwardIterator2 > </span><span><b>unique_by_key</b>(ForwardIterator1 keys_first,</span>
<span>&nbsp;&nbsp;ForwardIterator1 keys_last,</span>
<span>&nbsp;&nbsp;ForwardIterator2 values_first,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>unique&#95;by&#95;key</code> is a generalization of <code>unique</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>unique&#95;by&#95;key</code> removes all but the first element of the group. Similarly, the corresponding values in the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> are also removed.

This version of <code>unique&#95;by&#95;key</code> uses the function object <code>binary&#95;pred</code> to test for equality and <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.


The following code snippet demonstrates how to use <code>unique&#95;by&#95;key</code> to compact a sequence of key/value pairs to remove consecutive duplicates.



```cpp
#include <thrust/unique.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // values

thrust::pair<int*,int*> new_end;
thrust::equal_to<int> binary_pred;
new_end = thrust::unique_by_key(keys, keys + N, values, binary_pred);

// The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.
// The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.
```

**Template Parameters**:
* **`ForwardIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator1</code> is mutable, and <code>ForwardIterator's</code><code>value&#95;type</code> is a model of <a href="https://en.cppreference.com/w/cpp/concepts/equality_comparable">Equality Comparable</a>. 
* **`ForwardIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator2</code> is mutable. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`keys_first`** The beginning of the key range. 
* **`keys_last`** The end of the key range. 
* **`values_first`** The beginning of the value range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Preconditions**:
The range <code>[keys&#95;first, keys&#95;last)</code> and the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> shall not overlap.

**Returns**:
The end of the unique range <code>[first, new&#95;last)</code>.

**See**:
* unique 
* unique_by_key_copy 
* reduce_by_key 

<h3 id="function-unique-by-key-copy">
Function <code>thrust::unique&#95;by&#95;key&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>unique_by_key_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>unique&#95;by&#95;key&#95;copy</code> is a generalization of <code>unique&#95;copy</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>unique&#95;by&#95;key&#95;copy</code> copies the first element of the group to a range beginning with <code>keys&#95;result</code> and the corresponding values from the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> are copied to a range beginning with <code>values&#95;result</code>.

This version of <code>unique&#95;by&#95;key&#95;copy</code> uses <code>operator==</code> to test for equality and <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique&#95;by&#95;key&#95;copy</code> to compact a sequence of key/value pairs and with equal keys using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
new_end = thrust::unique_by_key_copy(thrust::host, A, A + N, B, C, D);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_result`** The beginning of the output key range. 
* **`values_result`** The beginning of the output value range. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;result, keys&#95;result&#95;last)</code> and <code>[values&#95;result, values&#95;result&#95;last)</code>.

**See**:
* unique_copy 
* unique_by_key 
* reduce_by_key 

<h3 id="function-unique-by-key-copy">
Function <code>thrust::unique&#95;by&#95;key&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>unique_by_key_copy</b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result);</span></code>
<code>unique&#95;by&#95;key&#95;copy</code> is a generalization of <code>unique&#95;copy</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>unique&#95;by&#95;key&#95;copy</code> copies the first element of the group to a range beginning with <code>keys&#95;result</code> and the corresponding values from the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> are copied to a range beginning with <code>values&#95;result</code>.

This version of <code>unique&#95;by&#95;key&#95;copy</code> uses <code>operator==</code> to test for equality and <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.


The following code snippet demonstrates how to use <code>unique&#95;by&#95;key&#95;copy</code> to compact a sequence of key/value pairs and with equal keys.



```cpp
#include <thrust/unique.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
new_end = thrust::unique_by_key_copy(A, A + N, B, C, D);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>.

**Function Parameters**:
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_result`** The beginning of the output key range. 
* **`values_result`** The beginning of the output value range. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;result, keys&#95;result&#95;last)</code> and <code>[values&#95;result, values&#95;result&#95;last)</code>.

**See**:
* unique_copy 
* unique_by_key 
* reduce_by_key 

<h3 id="function-unique-by-key-copy">
Function <code>thrust::unique&#95;by&#95;key&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>unique_by_key_copy</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>unique&#95;by&#95;key&#95;copy</code> is a generalization of <code>unique&#95;copy</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>unique&#95;by&#95;key&#95;copy</code> copies the first element of the group to a range beginning with <code>keys&#95;result</code> and the corresponding values from the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> are copied to a range beginning with <code>values&#95;result</code>.

This version of <code>unique&#95;by&#95;key&#95;copy</code> uses the function object <code>binary&#95;pred</code> to test for equality and <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique&#95;by&#95;key&#95;copy</code> to compact a sequence of key/value pairs and with equal keys using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
thrust::equal_to<int> binary_pred;
new_end = thrust::unique_by_key_copy(thrust::host, A, A + N, B, C, D, binary_pred);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_result`** The beginning of the output key range. 
* **`values_result`** The beginning of the output value range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;result, keys&#95;result&#95;last)</code> and <code>[values&#95;result, values&#95;result&#95;last)</code>.

**See**:
* unique_copy 
* unique_by_key 
* reduce_by_key 

<h3 id="function-unique-by-key-copy">
Function <code>thrust::unique&#95;by&#95;key&#95;copy</code>
</h3>

<code class="doxybook">
<span>template &lt;typename InputIterator1,</span>
<span>&nbsp;&nbsp;typename InputIterator2,</span>
<span>&nbsp;&nbsp;typename OutputIterator1,</span>
<span>&nbsp;&nbsp;typename OutputIterator2,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span><a href="{{ site.baseurl }}/api/classes/structthrust_1_1pair.html">thrust::pair</a>< OutputIterator1, OutputIterator2 > </span><span><b>unique_by_key_copy</b>(InputIterator1 keys_first,</span>
<span>&nbsp;&nbsp;InputIterator1 keys_last,</span>
<span>&nbsp;&nbsp;InputIterator2 values_first,</span>
<span>&nbsp;&nbsp;OutputIterator1 keys_result,</span>
<span>&nbsp;&nbsp;OutputIterator2 values_result,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>unique&#95;by&#95;key&#95;copy</code> is a generalization of <code>unique&#95;copy</code> to key-value pairs. For each group of consecutive keys in the range <code>[keys&#95;first, keys&#95;last)</code> that are equal, <code>unique&#95;by&#95;key&#95;copy</code> copies the first element of the group to a range beginning with <code>keys&#95;result</code> and the corresponding values from the range <code>[values&#95;first, values&#95;first + (keys&#95;last - keys&#95;first))</code> are copied to a range beginning with <code>values&#95;result</code>.

This version of <code>unique&#95;by&#95;key&#95;copy</code> uses the function object <code>binary&#95;pred</code> to test for equality and <code><a href="{{ site.baseurl }}/api/classes/structthrust_1_1project1st.html">project1st</a></code> to reduce values with equal keys.


The following code snippet demonstrates how to use <code>unique&#95;by&#95;key&#95;copy</code> to compact a sequence of key/value pairs and with equal keys.



```cpp
#include <thrust/unique.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
int C[N];                         // output keys
int D[N];                         // output values

thrust::pair<int*,int*> new_end;
thrust::equal_to<int> binary_pred;
new_end = thrust::unique_by_key_copy(A, A + N, B, C, D, binary_pred);

// The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
// The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.
```

**Template Parameters**:
* **`InputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`InputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/input_iterator">Input Iterator</a>, 
* **`OutputIterator1`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator1's</code><code>value&#95;type</code> is convertible to <code>OutputIterator1's</code><code>value&#95;type</code>. 
* **`OutputIterator2`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/output_iterator">Output Iterator</a> and and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator2's</code><code>value&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`keys_first`** The beginning of the input key range. 
* **`keys_last`** The end of the input key range. 
* **`values_first`** The beginning of the input value range. 
* **`keys_result`** The beginning of the output key range. 
* **`values_result`** The beginning of the output value range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Preconditions**:
The input ranges shall not overlap either output range.

**Returns**:
A pair of iterators at end of the ranges <code>[keys&#95;result, keys&#95;result&#95;last)</code> and <code>[values&#95;result, values&#95;result&#95;last)</code>.

**See**:
* unique_copy 
* unique_by_key 
* reduce_by_key 

<h3 id="function-unique-count">
Function <code>thrust::unique&#95;count</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< ForwardIterator >::difference_type </span><span><b>unique_count</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>unique&#95;count</code> counts runs of equal elements in the range <code>[first, last)</code> with the same value,

This version of <code>unique&#95;count</code> uses the function object <code>binary&#95;pred</code> to test for equality.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique&#95;count</code> to determine a number of runs of equal elements using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int count = thrust::unique_count(thrust::host, A, A + N, thrust::equal_to<int>());
// count is now 4
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>first&#95;argument&#95;type</code> and to <code>BinaryPredicate's</code><code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Returns**:
The number of runs of equal elements in <code>[first, new&#95;last)</code>

**See**:
* unique_copy 
* unique_by_key_copy 
* reduce_by_key_copy 

<h3 id="function-unique-count">
Function <code>thrust::unique&#95;count</code>
</h3>

<code class="doxybook">
<span>template &lt;typename DerivedPolicy,</span>
<span>&nbsp;&nbsp;typename ForwardIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< ForwardIterator >::difference_type </span><span><b>unique_count</b>(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,</span>
<span>&nbsp;&nbsp;ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>unique&#95;count</code> counts runs of equal elements in the range <code>[first, last)</code> with the same value,

This version of <code>unique&#95;count</code> uses <code>operator==</code> to test for equality.

The algorithm's execution is parallelized as determined by <code>exec</code>.


The following code snippet demonstrates how to use <code>unique&#95;count</code> to determine the number of runs of equal elements using the <code>thrust::host</code> execution policy for parallelization:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int count = thrust::unique_count(thrust::host, A, A + N);
// count is now 4
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>first&#95;argument&#95;type</code> and to <code>BinaryPredicate's</code><code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Returns**:
The number of runs of equal elements in <code>[first, new&#95;last)</code>

**See**:
* unique_copy 
* unique_by_key_copy 
* reduce_by_key_copy 

<h3 id="function-unique-count">
Function <code>thrust::unique&#95;count</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator,</span>
<span>&nbsp;&nbsp;typename BinaryPredicate&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< ForwardIterator >::difference_type </span><span><b>unique_count</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last,</span>
<span>&nbsp;&nbsp;BinaryPredicate binary_pred);</span></code>
<code>unique&#95;count</code> counts runs of equal elements in the range <code>[first, last)</code> with the same value,

This version of <code>unique&#95;count</code> uses the function object <code>binary&#95;pred</code> to test for equality.


The following code snippet demonstrates how to use <code>unique&#95;count</code> to determine the number of runs of equal elements:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int count = thrust::unique_count(A, A + N, thrust::equal_to<int>());
// count is now 4
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>first&#95;argument&#95;type</code> and to <code>BinaryPredicate's</code><code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Returns**:
The number of runs of equal elements in <code>[first, new&#95;last)</code>

**See**:
* unique_copy 
* unique_by_key_copy 
* reduce_by_key_copy 

<h3 id="function-unique-count">
Function <code>thrust::unique&#95;count</code>
</h3>

<code class="doxybook">
<span>template &lt;typename ForwardIterator&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/structthrust_1_1iterator__traits.html">thrust::iterator_traits</a>< ForwardIterator >::difference_type </span><span><b>unique_count</b>(ForwardIterator first,</span>
<span>&nbsp;&nbsp;ForwardIterator last);</span></code>
<code>unique&#95;count</code> counts runs of equal elements in the range <code>[first, last)</code> with the same value,

This version of <code>unique&#95;count</code> uses <code>operator==</code> to test for equality.


The following code snippet demonstrates how to use <code>unique&#95;count</code> to determine the number of runs of equal elements:



```cpp
#include <thrust/unique.h>
#include <thrust/execution_policy.h>
...
const int N = 7;
int A[N] = {1, 3, 3, 3, 2, 2, 1};
int count = thrust::unique_count(thrust::host, A, A + N);
// count is now 4
```

**Template Parameters**:
* **`DerivedPolicy`** The name of the derived execution policy. 
* **`ForwardIterator`** is a model of <a href="https://en.cppreference.com/w/cpp/iterator/forward_iterator">Forward Iterator</a>, and <code>ForwardIterator's</code><code>value&#95;type</code> is convertible to <code>BinaryPredicate's</code><code>first&#95;argument&#95;type</code> and to <code>BinaryPredicate's</code><code>second&#95;argument&#95;type</code>. 
* **`BinaryPredicate`** is a model of <a href="https://en.cppreference.com/w/cpp/named_req/BinaryPredicate">Binary Predicate</a>.

**Function Parameters**:
* **`exec`** The execution policy to use for parallelization. 
* **`first`** The beginning of the input range. 
* **`last`** The end of the input range. 
* **`binary_pred`** The binary predicate used to determine equality. 

**Returns**:
The number of runs of equal elements in <code>[first, new&#95;last)</code>

**See**:
* unique_copy 
* unique_by_key_copy 
* reduce_by_key_copy 

<h3 id="function-make-zip-function">
Function <code>thrust::make&#95;zip&#95;function</code>
</h3>

<code class="doxybook">
<span>template &lt;typename Function&gt;</span>
<span>__host__ __device__ <a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__function.html">zip_function</a>< typename std::decay< Function >::type > </span><span><b>make_zip_function</b>(Function && fun);</span></code>
<code>make&#95;zip&#95;function</code> creates a <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__function.html">zip&#95;function</a></code> from a function object.

**Function Parameters**:
**`fun`**: The N-ary function object. 

**Returns**:
A <code><a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__function.html">zip&#95;function</a></code> that takes a N-tuple.

**See**:
<a href="{{ site.baseurl }}/api/classes/classthrust_1_1zip__function.html">zip_function</a>


