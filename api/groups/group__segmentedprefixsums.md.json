{
  "abstract": false,
  "anchor": "",
  "category": "modules",
  "const": false,
  "definition": "",
  "explicit": false,
  "fullname": "segmentedprefixsums",
  "hasAdditionalMembers": false,
  "hasDetails": false,
  "inline": false,
  "kind": "group",
  "language": "",
  "module": {
    "anchor": "",
    "category": "modules",
    "fullname": "prefixsums",
    "kind": "group",
    "language": "",
    "name": "prefixsums",
    "qualifiedname": "prefixsums",
    "refid": "group__prefixsums",
    "title": "Prefix Sums",
    "url": "{{ site.baseurl }}/api/groups/group__prefixsums.html",
    "visibility": "public"
  },
  "moduleBreadcrumbs": [
    {
      "anchor": "",
      "category": "modules",
      "fullname": "algorithms",
      "kind": "group",
      "language": "",
      "name": "algorithms",
      "qualifiedname": "algorithms",
      "refid": "group__algorithms",
      "title": "Algorithms",
      "url": "{{ site.baseurl }}/api/groups/group__algorithms.html",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "modules",
      "fullname": "prefixsums",
      "kind": "group",
      "language": "",
      "name": "prefixsums",
      "qualifiedname": "prefixsums",
      "refid": "group__prefixsums",
      "title": "Prefix Sums",
      "url": "{{ site.baseurl }}/api/groups/group__prefixsums.html",
      "visibility": "public"
    }
  ],
  "name": "segmentedprefixsums",
  "override": false,
  "parent": {
    "anchor": "",
    "category": "modules",
    "fullname": "prefixsums",
    "kind": "group",
    "language": "",
    "name": "prefixsums",
    "qualifiedname": "prefixsums",
    "refid": "group__prefixsums",
    "title": "Prefix Sums",
    "url": "{{ site.baseurl }}/api/groups/group__prefixsums.html",
    "visibility": "public"
  },
  "parentBreadcrumbs": [
    {
      "anchor": "",
      "category": "modules",
      "fullname": "algorithms",
      "kind": "group",
      "language": "",
      "name": "algorithms",
      "qualifiedname": "algorithms",
      "refid": "group__algorithms",
      "title": "Algorithms",
      "url": "{{ site.baseurl }}/api/groups/group__algorithms.html",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "modules",
      "fullname": "prefixsums",
      "kind": "group",
      "language": "",
      "name": "prefixsums",
      "qualifiedname": "prefixsums",
      "refid": "group__prefixsums",
      "title": "Prefix Sums",
      "url": "{{ site.baseurl }}/api/groups/group__prefixsums.html",
      "visibility": "public"
    }
  ],
  "publicFunctions": [
    {
      "abstract": false,
      "anchor": "#function-inclusive-scan-by-key",
      "argsString": "(const thrust::detail::execution_policy_base< DerivedPolicy > &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "__host__ __device__ OutputIterator thrust::inclusive_scan_by_key",
      "deleted": false,
      "details": "<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code><a href=\"{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html\">equal&#95;to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>&#42;i == &#42;(i+1)</code>, and belong to different segments otherwise.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\nThe algorithm's execution is parallelized as determined by <code>exec</code>.\n\n\nThe following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/execution_policy.h>\n...\n\nint data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\n\nthrust::inclusive_scan_by_key(thrust::host, keys, keys + 10, data, data); // in-place scan\n\n// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::inclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 710
      },
      "name": "inclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "exec",
          "text": "The execution policy to use for parallelization. "
        },
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        }
      ],
      "params": [
        {
          "name": "exec",
          "type": "const thrust::detail::execution_policy_base< DerivedPolicy > &",
          "typePlain": "const thrust::detail::execution_policy_base< DerivedPolicy > &"
        },
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::inclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1gae84dddc63b198eb91cdf28e19cd2effc",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "inclusive_scan ",
        "exclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename DerivedPolicy",
          "typePlain": "typename DerivedPolicy"
        },
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        }
      ],
      "templateParamsList": [
        {
          "name": "DerivedPolicy",
          "text": "The name of the derived execution policy. "
        },
        {
          "name": "InputIterator1",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a>"
        },
        {
          "name": "InputIterator2",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "OutputIterator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/output_iterator\">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined."
        }
      ],
      "title": "inclusive_scan_by_key",
      "type": "__host__ __device__ OutputIterator",
      "typePlain": "__host__ __device__ OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-inclusive-scan-by-key",
      "argsString": "(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "OutputIterator thrust::inclusive_scan_by_key",
      "deleted": false,
      "details": "<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code><a href=\"{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html\">equal&#95;to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>&#42;i == &#42;(i+1)</code>, and belong to different segments otherwise.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\n\nThe following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code>\n\n\n\n```cpp\n#include <thrust/scan.h>\n\nint data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\n\nthrust::inclusive_scan_by_key(keys, keys + 10, data, data); // in-place scan\n\n// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::inclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 774
      },
      "name": "inclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        }
      ],
      "params": [
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::inclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga61acb0c313f9375211f186b86075ce54",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "inclusive_scan ",
        "exclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        }
      ],
      "templateParamsList": [
        {
          "name": "InputIterator1",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a>"
        },
        {
          "name": "InputIterator2",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "OutputIterator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/output_iterator\">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined."
        }
      ],
      "title": "inclusive_scan_by_key",
      "type": "OutputIterator",
      "typePlain": "OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-inclusive-scan-by-key",
      "argsString": "(const thrust::detail::execution_policy_base< DerivedPolicy > &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "__host__ __device__ OutputIterator thrust::inclusive_scan_by_key",
      "deleted": false,
      "details": "<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\nThe algorithm's execution is parallelized as determined by <code>exec</code>.\n\n\nThe following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n#include <thrust/execution_policy.h>\n...\n\nint data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\n\nthrust::equal_to<int> binary_pred;\n\nthrust::inclusive_scan_by_key(thrust::host, keys, keys + 10, data, data, binary_pred); // in-place scan\n\n// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::inclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 852
      },
      "name": "inclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "exec",
          "text": "The execution policy to use for parallelization. "
        },
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "binary_pred",
          "text": "The binary predicate used to determine equality of keys. "
        }
      ],
      "params": [
        {
          "name": "exec",
          "type": "const thrust::detail::execution_policy_base< DerivedPolicy > &",
          "typePlain": "const thrust::detail::execution_policy_base< DerivedPolicy > &"
        },
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "binary_pred",
          "type": "BinaryPredicate",
          "typePlain": "BinaryPredicate"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::inclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga634dbb556c019c0f3a9c641f59dfbd8c",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "inclusive_scan ",
        "exclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename DerivedPolicy",
          "typePlain": "typename DerivedPolicy"
        },
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename BinaryPredicate",
          "typePlain": "typename BinaryPredicate"
        }
      ],
      "templateParamsList": [
        {
          "name": "DerivedPolicy",
          "text": "The name of the derived execution policy. "
        },
        {
          "name": "InputIterator1",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a>"
        },
        {
          "name": "InputIterator2",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "OutputIterator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/output_iterator\">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. "
        },
        {
          "name": "BinaryPredicate",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/named_req/BinaryPredicate\">Binary Predicate</a>."
        }
      ],
      "title": "inclusive_scan_by_key",
      "type": "__host__ __device__ OutputIterator",
      "typePlain": "__host__ __device__ OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-inclusive-scan-by-key",
      "argsString": "(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "OutputIterator thrust::inclusive_scan_by_key",
      "deleted": false,
      "details": "<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\n\nThe following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code>\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n\nint data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\n\nthrust::equal_to<int> binary_pred;\n\nthrust::inclusive_scan_by_key(keys, keys + 10, data, data, binary_pred); // in-place scan\n\n// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::inclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 923
      },
      "name": "inclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "binary_pred",
          "text": "The binary predicate used to determine equality of keys. "
        }
      ],
      "params": [
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "binary_pred",
          "type": "BinaryPredicate",
          "typePlain": "BinaryPredicate"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::inclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga7294e99fe824bcbb542a3a9567280dd7",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "inclusive_scan ",
        "exclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename BinaryPredicate",
          "typePlain": "typename BinaryPredicate"
        }
      ],
      "templateParamsList": [
        {
          "name": "InputIterator1",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a>"
        },
        {
          "name": "InputIterator2",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "OutputIterator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/output_iterator\">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. "
        },
        {
          "name": "BinaryPredicate",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/named_req/BinaryPredicate\">Binary Predicate</a>."
        }
      ],
      "title": "inclusive_scan_by_key",
      "type": "OutputIterator",
      "typePlain": "OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-inclusive-scan-by-key",
      "argsString": "(const thrust::detail::execution_policy_base< DerivedPolicy > &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "__host__ __device__ OutputIterator thrust::inclusive_scan_by_key",
      "deleted": false,
      "details": "<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the associative operator <code>binary&#95;op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\nThe algorithm's execution is parallelized as determined by <code>exec</code>.\n\n\nThe following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n#include <thrust/execution_policy.h>\n...\n\nint data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\n\nthrust::equal_to<int> binary_pred;\nthrust::plus<int>     binary_op;\n\nthrust::inclusive_scan_by_key(thrust::host, keys, keys + 10, data, data, binary_pred, binary_op); // in-place scan\n\n// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::inclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1008
      },
      "name": "inclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "exec",
          "text": "The execution policy to use for parallelization. "
        },
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "binary_pred",
          "text": "The binary predicate used to determine equality of keys. "
        },
        {
          "name": "binary_op",
          "text": "The associatve operator used to 'sum' values. "
        }
      ],
      "params": [
        {
          "name": "exec",
          "type": "const thrust::detail::execution_policy_base< DerivedPolicy > &",
          "typePlain": "const thrust::detail::execution_policy_base< DerivedPolicy > &"
        },
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "binary_pred",
          "type": "BinaryPredicate",
          "typePlain": "BinaryPredicate"
        },
        {
          "name": "binary_op",
          "type": "AssociativeOperator",
          "typePlain": "AssociativeOperator"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::inclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga4440c418b802df3a25ff2bf4131d2306",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "inclusive_scan ",
        "exclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename DerivedPolicy",
          "typePlain": "typename DerivedPolicy"
        },
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename BinaryPredicate",
          "typePlain": "typename BinaryPredicate"
        },
        {
          "name": "",
          "type": "typename AssociativeOperator",
          "typePlain": "typename AssociativeOperator"
        }
      ],
      "templateParamsList": [
        {
          "name": "DerivedPolicy",
          "text": "The name of the derived execution policy. "
        },
        {
          "name": "InputIterator1",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a>"
        },
        {
          "name": "InputIterator2",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "OutputIterator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/output_iterator\">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. "
        },
        {
          "name": "BinaryPredicate",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/named_req/BinaryPredicate\">Binary Predicate</a>. "
        },
        {
          "name": "AssociativeOperator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/utility/functional/binary_function\">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>."
        }
      ],
      "title": "inclusive_scan_by_key",
      "type": "__host__ __device__ OutputIterator",
      "typePlain": "__host__ __device__ OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-inclusive-scan-by-key",
      "argsString": "(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "OutputIterator thrust::inclusive_scan_by_key",
      "deleted": false,
      "details": "<code>inclusive&#95;scan&#95;by&#95;key</code> computes an inclusive key-value or 'segmented' prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate inclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\nThis version of <code>inclusive&#95;scan&#95;by&#95;key</code> uses the associative operator <code>binary&#95;op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\n\nThe following code snippet demonstrates how to use <code>inclusive&#95;scan&#95;by&#95;key</code>\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n\nint data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\n\nthrust::equal_to<int> binary_pred;\nthrust::plus<int>     binary_op;\n\nthrust::inclusive_scan_by_key(keys, keys + 10, data, data, binary_pred, binary_op); // in-place scan\n\n// data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::inclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1086
      },
      "name": "inclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "binary_pred",
          "text": "The binary predicate used to determine equality of keys. "
        },
        {
          "name": "binary_op",
          "text": "The associatve operator used to 'sum' values. "
        }
      ],
      "params": [
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "binary_pred",
          "type": "BinaryPredicate",
          "typePlain": "BinaryPredicate"
        },
        {
          "name": "binary_op",
          "type": "AssociativeOperator",
          "typePlain": "AssociativeOperator"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::inclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1gaf735a58d04225b29ee16a6cafed7689a",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "inclusive_scan ",
        "exclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename BinaryPredicate",
          "typePlain": "typename BinaryPredicate"
        },
        {
          "name": "",
          "type": "typename AssociativeOperator",
          "typePlain": "typename AssociativeOperator"
        }
      ],
      "templateParamsList": [
        {
          "name": "InputIterator1",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a>"
        },
        {
          "name": "InputIterator2",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "OutputIterator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/output_iterator\">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. "
        },
        {
          "name": "BinaryPredicate",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/named_req/BinaryPredicate\">Binary Predicate</a>. "
        },
        {
          "name": "AssociativeOperator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/utility/functional/binary_function\">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>."
        }
      ],
      "title": "inclusive_scan_by_key",
      "type": "OutputIterator",
      "typePlain": "OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-inclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-exclusive-scan-by-key",
      "argsString": "(const thrust::detail::execution_policy_base< DerivedPolicy > &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "__host__ __device__ OutputIterator thrust::exclusive_scan_by_key",
      "deleted": false,
      "details": "<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive segmented prefix\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>0</code> to initialize the exclusive scan operation.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> assumes <code><a href=\"{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html\">equal&#95;to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1</code> belong to the same segment if <code>&#42;i == &#42;(i+1)</code>, and belong to different segments otherwise.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\nRefer to the most general form of <code>exclusive&#95;scan&#95;by&#95;key</code> for additional details.\n\nThe algorithm's execution is parallelized as determined by <code>exec</code>.\n\n\nThe following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/execution_policy.h>\n...\n\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\nint vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nthrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals); // in-place scan\n\n// vals is now {0, 1, 2, 0, 1, 0, 0, 1, 2, 3};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::exclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1150
      },
      "name": "exclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "exec",
          "text": "The execution policy to use for parallelization. "
        },
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence."
        }
      ],
      "params": [
        {
          "name": "exec",
          "type": "const thrust::detail::execution_policy_base< DerivedPolicy > &",
          "typePlain": "const thrust::detail::execution_policy_base< DerivedPolicy > &"
        },
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::exclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga1c90ddaacc12dd7daafaa8e18fefb3b9",
      "see": [
        "exclusive_scan "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename DerivedPolicy",
          "typePlain": "typename DerivedPolicy"
        },
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        }
      ],
      "title": "exclusive_scan_by_key",
      "type": "__host__ __device__ OutputIterator",
      "typePlain": "__host__ __device__ OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-exclusive-scan-by-key",
      "argsString": "(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "OutputIterator thrust::exclusive_scan_by_key",
      "deleted": false,
      "details": "<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive segmented prefix\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>0</code> to initialize the exclusive scan operation.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> assumes <code>plus</code> as the associative operator used to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> assumes <code><a href=\"{{ site.baseurl }}/api/classes/structthrust_1_1equal__to.html\">equal&#95;to</a></code> as the binary predicate used to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1</code> belong to the same segment if <code>&#42;i == &#42;(i+1)</code>, and belong to different segments otherwise.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\nRefer to the most general form of <code>exclusive&#95;scan&#95;by&#95;key</code> for additional details.\n\n\nThe following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code>.\n\n\n\n```cpp\n#include <thrust/scan.h>\n\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\nint vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nthrust::exclusive_scan_by_key(key, key + 10, vals, vals); // in-place scan\n\n// vals is now {0, 1, 2, 0, 1, 0, 0, 1, 2, 3};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::exclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1205
      },
      "name": "exclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence."
        }
      ],
      "params": [
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::exclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga115ffd69c3e45736772cbdf2b74b9097",
      "see": [
        "exclusive_scan "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        }
      ],
      "title": "exclusive_scan_by_key",
      "type": "OutputIterator",
      "typePlain": "OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-exclusive-scan-by-key",
      "argsString": "(const thrust::detail::execution_policy_base< DerivedPolicy > &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "__host__ __device__ OutputIterator thrust::exclusive_scan_by_key",
      "deleted": false,
      "details": "<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\nThe algorithm's execution is parallelized as determined by <code>exec</code>.\n\n\nThe following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n#include <thrust/execution_policy.h>\n...\n\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\nint vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nint init = 5;\n\nthrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals, init); // in-place scan\n\n// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::exclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1267
      },
      "name": "exclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "exec",
          "text": "The execution policy to use for parallelization. "
        },
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "init",
          "text": "The initial of the exclusive sum value. "
        }
      ],
      "params": [
        {
          "name": "exec",
          "type": "const thrust::detail::execution_policy_base< DerivedPolicy > &",
          "typePlain": "const thrust::detail::execution_policy_base< DerivedPolicy > &"
        },
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "init",
          "type": "T",
          "typePlain": "T"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::exclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga49d16201188d12d536eb12aea693db47",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "exclusive_scan ",
        "inclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename DerivedPolicy",
          "typePlain": "typename DerivedPolicy"
        },
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename T",
          "typePlain": "typename T"
        }
      ],
      "title": "exclusive_scan_by_key",
      "type": "__host__ __device__ OutputIterator",
      "typePlain": "__host__ __device__ OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-exclusive-scan-by-key",
      "argsString": "(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "OutputIterator thrust::exclusive_scan_by_key",
      "deleted": false,
      "details": "<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\n\nThe following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code>\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\nint vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nint init = 5;\n\nthrust::exclusive_scan_by_key(key, key + 10, vals, vals, init); // in-place scan\n\n// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::exclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1323
      },
      "name": "exclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "init",
          "text": "The initial of the exclusive sum value. "
        }
      ],
      "params": [
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "init",
          "type": "T",
          "typePlain": "T"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::exclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga42d9779f3889cce6a259685b6a170bad",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "exclusive_scan ",
        "inclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename T",
          "typePlain": "typename T"
        }
      ],
      "title": "exclusive_scan_by_key",
      "type": "OutputIterator",
      "typePlain": "OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-exclusive-scan-by-key",
      "argsString": "(const thrust::detail::execution_policy_base< DerivedPolicy > &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "__host__ __device__ OutputIterator thrust::exclusive_scan_by_key",
      "deleted": false,
      "details": "<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>binary&#95;pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\nThe algorithm's execution is parallelized as determined by <code>exec</code>.\n\n\nThe following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n#include <thrust/execution_policy.h>\n...\n\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\nint vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nint init = 5;\n\nthrust::equal_to<int> binary_pred;\n\nthrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals, init, binary_pred); // in-place scan\n\n// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::exclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1395
      },
      "name": "exclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "exec",
          "text": "The execution policy to use for parallelization. "
        },
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "init",
          "text": "The initial of the exclusive sum value. "
        },
        {
          "name": "binary_pred",
          "text": "The binary predicate used to determine equality of keys. "
        }
      ],
      "params": [
        {
          "name": "exec",
          "type": "const thrust::detail::execution_policy_base< DerivedPolicy > &",
          "typePlain": "const thrust::detail::execution_policy_base< DerivedPolicy > &"
        },
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "init",
          "type": "T",
          "typePlain": "T"
        },
        {
          "name": "binary_pred",
          "type": "BinaryPredicate",
          "typePlain": "BinaryPredicate"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::exclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga5627b0f2a62d2b1b1f9d29e4fd626987",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "exclusive_scan ",
        "inclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename DerivedPolicy",
          "typePlain": "typename DerivedPolicy"
        },
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename T",
          "typePlain": "typename T"
        },
        {
          "name": "",
          "type": "typename BinaryPredicate",
          "typePlain": "typename BinaryPredicate"
        }
      ],
      "title": "exclusive_scan_by_key",
      "type": "__host__ __device__ OutputIterator",
      "typePlain": "__host__ __device__ OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-exclusive-scan-by-key",
      "argsString": "(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "OutputIterator thrust::exclusive_scan_by_key",
      "deleted": false,
      "details": "<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>binary&#95;pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\n\nThe following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code>\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\nint vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nint init = 5;\n\nthrust::equal_to<int> binary_pred;\n\nthrust::exclusive_scan_by_key(key, key + 10, vals, vals, init, binary_pred); // in-place scan\n\n// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::exclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1461
      },
      "name": "exclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "init",
          "text": "The initial of the exclusive sum value. "
        },
        {
          "name": "binary_pred",
          "text": "The binary predicate used to determine equality of keys. "
        }
      ],
      "params": [
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "init",
          "type": "T",
          "typePlain": "T"
        },
        {
          "name": "binary_pred",
          "type": "BinaryPredicate",
          "typePlain": "BinaryPredicate"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::exclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga3db491d008839bace57f17ce846b1919",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "exclusive_scan ",
        "inclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename T",
          "typePlain": "typename T"
        },
        {
          "name": "",
          "type": "typename BinaryPredicate",
          "typePlain": "typename BinaryPredicate"
        }
      ],
      "title": "exclusive_scan_by_key",
      "type": "OutputIterator",
      "typePlain": "OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-exclusive-scan-by-key",
      "argsString": "(const thrust::detail::execution_policy_base< DerivedPolicy > &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "__host__ __device__ OutputIterator thrust::exclusive_scan_by_key",
      "deleted": false,
      "details": "<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>binary&#95;pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the associative operator <code>binary&#95;op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\nThe algorithm's execution is parallelized as determined by <code>exec</code>.\n\n\nThe following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code> using the <code>thrust::host</code> execution policy for parallelization:\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n#include <thrust/execution_policy.h>\n...\n\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\nint vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nint init = 5;\n\nthrust::equal_to<int> binary_pred;\nthrust::plus<int>     binary_op;\n\nthrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals, init, binary_pred, binary_op); // in-place scan\n\n// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::exclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1553
      },
      "name": "exclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "exec",
          "text": "The execution policy to use for parallelization. "
        },
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "init",
          "text": "The initial of the exclusive sum value. "
        },
        {
          "name": "binary_pred",
          "text": "The binary predicate used to determine equality of keys. "
        },
        {
          "name": "binary_op",
          "text": "The associatve operator used to 'sum' values. "
        }
      ],
      "params": [
        {
          "name": "exec",
          "type": "const thrust::detail::execution_policy_base< DerivedPolicy > &",
          "typePlain": "const thrust::detail::execution_policy_base< DerivedPolicy > &"
        },
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "init",
          "type": "T",
          "typePlain": "T"
        },
        {
          "name": "binary_pred",
          "type": "BinaryPredicate",
          "typePlain": "BinaryPredicate"
        },
        {
          "name": "binary_op",
          "type": "AssociativeOperator",
          "typePlain": "AssociativeOperator"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::exclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1gafd9ada3c6c491c4b676760612168f663",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "exclusive_scan ",
        "inclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename DerivedPolicy",
          "typePlain": "typename DerivedPolicy"
        },
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename T",
          "typePlain": "typename T"
        },
        {
          "name": "",
          "type": "typename BinaryPredicate",
          "typePlain": "typename BinaryPredicate"
        },
        {
          "name": "",
          "type": "typename AssociativeOperator",
          "typePlain": "typename AssociativeOperator"
        }
      ],
      "templateParamsList": [
        {
          "name": "DerivedPolicy",
          "text": "The name of the derived execution policy. "
        },
        {
          "name": "InputIterator1",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a>"
        },
        {
          "name": "InputIterator2",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "OutputIterator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/output_iterator\">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. "
        },
        {
          "name": "T",
          "text": "is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "BinaryPredicate",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/named_req/BinaryPredicate\">Binary Predicate</a>. "
        },
        {
          "name": "AssociativeOperator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/utility/functional/binary_function\">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>."
        }
      ],
      "title": "exclusive_scan_by_key",
      "type": "__host__ __device__ OutputIterator",
      "typePlain": "__host__ __device__ OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    },
    {
      "abstract": false,
      "anchor": "#function-exclusive-scan-by-key",
      "argsString": "(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op)",
      "category": "functions",
      "const": false,
      "default": false,
      "definition": "OutputIterator thrust::exclusive_scan_by_key",
      "deleted": false,
      "details": "<code>exclusive&#95;scan&#95;by&#95;key</code> computes an exclusive key-value or 'segmented' prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. The term 'segmented' means that the partial sums are broken into distinct segments. In other words, within each segment a separate exclusive scan operation is computed. Refer to the code sample below for example usage.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the value <code>init</code> to initialize the exclusive scan operation.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the binary predicate <code>binary&#95;pred</code> to compare adjacent keys. Specifically, consecutive iterators <code>i</code> and <code>i+1</code> in the range <code>[first1, last1)</code> belong to the same segment if <code>binary&#95;pred(&#42;i, &#42;(i+1))</code> is true, and belong to different segments otherwise.\n\nThis version of <code>exclusive&#95;scan&#95;by&#95;key</code> uses the associative operator <code>binary&#95;op</code> to perform the prefix sum. When the input and output sequences are the same, the scan is performed in-place.\n\nResults are not deterministic for pseudo-associative operators (e.g., addition of floating-point types). Results for pseudo-associative operators may vary from run to run.\n\n\nThe following code snippet demonstrates how to use <code>exclusive&#95;scan&#95;by&#95;key</code>\n\n\n\n```cpp\n#include <thrust/scan.h>\n#include <thrust/functional.h>\n\nint keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};\nint vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nint init = 5;\n\nthrust::equal_to<int> binary_pred;\nthrust::plus<int>     binary_op;\n\nthrust::exclusive_scan_by_key(key, key + 10, vals, vals, init, binary_pred, binary_op); // in-place scan\n\n// vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};\n```",
      "explicit": false,
      "fullname": "segmentedprefixsums::exclusive_scan_by_key",
      "hasDetails": true,
      "inline": false,
      "kind": "function",
      "language": "",
      "location": {
        "column": 18,
        "file": "thrust/scan.h",
        "line": 1638
      },
      "name": "exclusive_scan_by_key",
      "override": false,
      "paramList": [
        {
          "name": "first1",
          "text": "The beginning of the key sequence. "
        },
        {
          "name": "last1",
          "text": "The end of the key sequence. "
        },
        {
          "name": "first2",
          "text": "The beginning of the input value sequence. "
        },
        {
          "name": "result",
          "text": "The beginning of the output value sequence. "
        },
        {
          "name": "init",
          "text": "The initial of the exclusive sum value. "
        },
        {
          "name": "binary_pred",
          "text": "The binary predicate used to determine equality of keys. "
        },
        {
          "name": "binary_op",
          "text": "The associatve operator used to 'sum' values. "
        }
      ],
      "params": [
        {
          "name": "first1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "last1",
          "type": "InputIterator1",
          "typePlain": "InputIterator1"
        },
        {
          "name": "first2",
          "type": "InputIterator2",
          "typePlain": "InputIterator2"
        },
        {
          "name": "result",
          "type": "OutputIterator",
          "typePlain": "OutputIterator"
        },
        {
          "name": "init",
          "type": "T",
          "typePlain": "T"
        },
        {
          "name": "binary_pred",
          "type": "BinaryPredicate",
          "typePlain": "BinaryPredicate"
        },
        {
          "name": "binary_op",
          "type": "AssociativeOperator",
          "typePlain": "AssociativeOperator"
        }
      ],
      "pre": [
        "<code>first1</code> may equal <code>result</code> but the range <code>[first1, last1)</code> and the range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise. ",
        "<code>first2</code> may equal <code>result</code> but the range <code>[first2, first2 + (last1 - first1)</code> and range <code>[result, result + (last1 - first1))</code> shall not overlap otherwise."
      ],
      "pureVirtual": false,
      "qualifiedname": "thrust::exclusive_scan_by_key",
      "refid": "group__segmentedprefixsums_1ga1281d7a3f03c0f0d1c7b185af6896b29",
      "returns": [
        "The end of the output sequence."
      ],
      "see": [
        "exclusive_scan ",
        "inclusive_scan_by_key "
      ],
      "static": false,
      "strong": false,
      "templateParams": [
        {
          "name": "",
          "type": "typename InputIterator1",
          "typePlain": "typename InputIterator1"
        },
        {
          "name": "",
          "type": "typename InputIterator2",
          "typePlain": "typename InputIterator2"
        },
        {
          "name": "",
          "type": "typename OutputIterator",
          "typePlain": "typename OutputIterator"
        },
        {
          "name": "",
          "type": "typename T",
          "typePlain": "typename T"
        },
        {
          "name": "",
          "type": "typename BinaryPredicate",
          "typePlain": "typename BinaryPredicate"
        },
        {
          "name": "",
          "type": "typename AssociativeOperator",
          "typePlain": "typename AssociativeOperator"
        }
      ],
      "templateParamsList": [
        {
          "name": "InputIterator1",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a>"
        },
        {
          "name": "InputIterator2",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/input_iterator\">Input Iterator</a> and <code>InputIterator2's</code><code>value&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "OutputIterator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/iterator/output_iterator\">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code><code>value&#95;type</code>, then <code>binary&#95;op(x,y)</code> is defined. "
        },
        {
          "name": "T",
          "text": "is convertible to <code>OutputIterator's</code><code>value&#95;type</code>. "
        },
        {
          "name": "BinaryPredicate",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/named_req/BinaryPredicate\">Binary Predicate</a>. "
        },
        {
          "name": "AssociativeOperator",
          "text": "is a model of <a href=\"https://en.cppreference.com/w/cpp/utility/functional/binary_function\">Binary Function</a> and <code>AssociativeOperator's</code><code>result&#95;type</code> is convertible to <code>OutputIterator's</code><code>value&#95;type</code>."
        }
      ],
      "title": "exclusive_scan_by_key",
      "type": "OutputIterator",
      "typePlain": "OutputIterator",
      "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html#function-exclusive-scan-by-key",
      "virtual": false,
      "visibility": "public"
    }
  ],
  "qualifiedname": "segmentedprefixsums",
  "refid": "group__segmentedprefixsums",
  "static": false,
  "strong": false,
  "title": "Segmented Prefix Sums",
  "url": "{{ site.baseurl }}/api/groups/group__segmentedprefixsums.html",
  "visibility": "public"
}